/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "D:\\workspace\\testprj\\1git_html\\AiEXifCool\\git_source\\AiEXifCool\\dist";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 180);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(44)('wks')
  , uid        = __webpack_require__(33)
  , Symbol     = __webpack_require__(2).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(15)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(2)
  , core      = __webpack_require__(0)
  , ctx       = __webpack_require__(13)
  , hide      = __webpack_require__(10)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(7)
  , IE8_DOM_DEFINE = __webpack_require__(55)
  , toPrimitive    = __webpack_require__(47)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(3) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = Object.create(options.computed || null)
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
    options.computed = computed
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _defineProperties = __webpack_require__(105);

var _defineProperties2 = _interopRequireDefault2(_defineProperties);

var _preventExtensions = __webpack_require__(112);

var _preventExtensions2 = _interopRequireDefault2(_preventExtensions);

var _isExtensible = __webpack_require__(111);

var _isExtensible2 = _interopRequireDefault2(_isExtensible);

var _stringify3 = __webpack_require__(102);

var _stringify4 = _interopRequireDefault2(_stringify3);

var _map = __webpack_require__(103);

var _map2 = _interopRequireDefault2(_map);

var _setPrototypeOf = __webpack_require__(113);

var _setPrototypeOf2 = _interopRequireDefault2(_setPrototypeOf);

var _getPrototypeOf = __webpack_require__(110);

var _getPrototypeOf2 = _interopRequireDefault2(_getPrototypeOf);

var _getOwnPropertyDescriptor = __webpack_require__(107);

var _getOwnPropertyDescriptor2 = _interopRequireDefault2(_getOwnPropertyDescriptor);

var _isIterable2 = __webpack_require__(101);

var _isIterable3 = _interopRequireDefault2(_isIterable2);

var _getIterator2 = __webpack_require__(100);

var _getIterator3 = _interopRequireDefault2(_getIterator2);

var _getOwnPropertySymbols = __webpack_require__(109);

var _getOwnPropertySymbols2 = _interopRequireDefault2(_getOwnPropertySymbols);

var _getOwnPropertyNames = __webpack_require__(108);

var _getOwnPropertyNames2 = _interopRequireDefault2(_getOwnPropertyNames);

var _create2 = __webpack_require__(104);

var _create3 = _interopRequireDefault2(_create2);

var _keys = __webpack_require__(53);

var _keys2 = _interopRequireDefault2(_keys);

var _defineProperty4 = __webpack_require__(106);

var _defineProperty5 = _interopRequireDefault2(_defineProperty4);

var _typeof5 = __webpack_require__(117);

var _typeof6 = _interopRequireDefault2(_typeof5);

function _interopRequireDefault2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : (0, _typeof6.default)(exports)) === 'object' && ( false ? 'undefined' : (0, _typeof6.default)(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : (0, _typeof6.default)(exports)) === 'object') exports["KeenUI"] = factory();else root["KeenUI"] = factory();
})(undefined, function () {
  return function (modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
      if (installedModules[moduleId]) return installedModules[moduleId].exports;

      var module = installedModules[moduleId] = { i: moduleId,
        l: false,
        exports: {}
      };

      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

      module.l = true;

      return module.exports;
    }

    __webpack_require__.m = modules;

    __webpack_require__.c = installedModules;

    __webpack_require__.i = function (value) {
      return value;
    };

    __webpack_require__.d = function (exports, name, getter) {
      if (!__webpack_require__.o(exports, name)) {
        (0, _defineProperty5.default)(exports, name, { configurable: false,
          enumerable: true,
          get: getter
        });
      }
    };

    __webpack_require__.n = function (module) {
      var getter = module && module.__esModule ? function getDefault() {
        return module['default'];
      } : function getModuleExports() {
        return module;
      };
      __webpack_require__.d(getter, 'a', getter);
      return getter;
    };

    __webpack_require__.o = function (object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };

    __webpack_require__.p = "";

    return __webpack_require__(__webpack_require__.s = 256);
  }([function (module, exports) {

    module.exports = function normalizeComponent(rawScriptExports, compiledTemplate, scopeId, cssModules) {
      var esModule;
      var scriptExports = rawScriptExports = rawScriptExports || {};

      var type = (0, _typeof6.default)(rawScriptExports.default);
      if (type === 'object' || type === 'function') {
        esModule = rawScriptExports;
        scriptExports = rawScriptExports.default;
      }

      var options = typeof scriptExports === 'function' ? scriptExports.options : scriptExports;

      if (compiledTemplate) {
        options.render = compiledTemplate.render;
        options.staticRenderFns = compiledTemplate.staticRenderFns;
      }

      if (scopeId) {
        options._scopeId = scopeId;
      }

      if (cssModules) {
        var computed = options.computed || (options.computed = {});
        (0, _keys2.default)(cssModules).forEach(function (key) {
          var module = cssModules[key];
          computed[key] = function () {
            return module;
          };
        });
      }

      return {
        esModule: esModule,
        exports: scriptExports,
        options: options
      };
    };
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(192);

    var Component = __webpack_require__(0)(__webpack_require__(102), __webpack_require__(242), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiIcon.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiIcon.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-6b61f66a", Component.options);
        } else {
          hotAPI.reload("data-v-6b61f66a", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KeenUiConfig = undefined;

    var _classCallCheck2 = __webpack_require__(129);

    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

    var _createClass2 = __webpack_require__(130);

    var _createClass3 = _interopRequireDefault(_createClass2);

    var _deepAssign = __webpack_require__(164);

    var _deepAssign2 = _interopRequireDefault(_deepAssign);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    var config = {
      disableRipple: false,

      UiAutocomplete: {
        keys: {
          label: 'label',
          value: 'value',
          image: 'image'
        }
      },

      UiCheckboxGroup: {
        keys: {
          id: 'id',
          name: 'name',
          class: 'class',
          label: 'label',
          value: 'value',
          disabled: 'disabled'
        }
      },

      UiMenu: {
        keys: {
          icon: 'icon',
          type: 'type',
          label: 'label',
          secondaryText: 'secondaryText',
          iconProps: 'iconProps',
          disabled: 'disabled'
        }
      },

      UiRadioGroup: {
        keys: {
          id: 'id',
          class: 'class',
          label: 'label',
          value: 'value',
          checked: 'checked',
          disabled: 'disabled'
        }
      },

      UiSelect: {
        keys: {
          label: 'label',
          value: 'value',
          image: 'image'
        }
      }
    };

    var KeenUiConfig = exports.KeenUiConfig = function () {
      function KeenUiConfig() {
        (0, _classCallCheck3.default)(this, KeenUiConfig);

        this.data = (0, _deepAssign2.default)(config, window.KeenUiConfig ? window.KeenUiConfig : {});
      }

      (0, _createClass3.default)(KeenUiConfig, [{
        key: 'set',
        value: function set() {
          var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this.data = (0, _deepAssign2.default)(this.data, config);
        }
      }]);
      return KeenUiConfig;
    }();

    exports.default = new KeenUiConfig();
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(170);

    var Component = __webpack_require__(0)(__webpack_require__(113), __webpack_require__(220), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiRippleInk.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiRippleInk.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-14e906f5", Component.options);
        } else {
          hotAPI.reload("data-v-14e906f5", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports) {
    var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
    if (typeof __g == 'number') __g = global;
  }, function (module, exports, __webpack_require__) {
    module.exports = !__webpack_require__(20)(function () {
      return Object.defineProperty({}, 'a', { get: function get() {
          return 7;
        } }).a != 7;
    });
  }, function (module, exports) {

    var hasOwnProperty = {}.hasOwnProperty;
    module.exports = function (it, key) {
      return hasOwnProperty.call(it, key);
    };
  }, function (module, exports, __webpack_require__) {

    var anObject = __webpack_require__(19),
        IE8_DOM_DEFINE = __webpack_require__(54),
        toPrimitive = __webpack_require__(39),
        dP = _defineProperty5.default;

    exports.f = __webpack_require__(5) ? _defineProperty5.default : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return dP(O, P, Attributes);
      } catch (e) {}
      if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
      if ('value' in Attributes) O[P] = Attributes.value;
      return O;
    };
  }, function (module, exports, __webpack_require__) {
    var IObject = __webpack_require__(142),
        defined = __webpack_require__(29);
    module.exports = function (it) {
      return IObject(defined(it));
    };
  }, function (module, exports, __webpack_require__) {

    var dP = __webpack_require__(7),
        createDesc = __webpack_require__(23);
    module.exports = __webpack_require__(5) ? function (object, key, value) {
      return dP.f(object, key, createDesc(1, value));
    } : function (object, key, value) {
      object[key] = value;
      return object;
    };
  }, function (module, exports, __webpack_require__) {

    var store = __webpack_require__(37)('wks'),
        uid = __webpack_require__(24),
        _Symbol = __webpack_require__(4).Symbol,
        USE_SYMBOL = typeof _Symbol == 'function';

    var $exports = module.exports = function (name) {
      return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
    };

    $exports.store = store;
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _typeof2 = __webpack_require__(51);

    var _typeof3 = _interopRequireDefault(_typeof2);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    var trim = /^\s+|\s+$/g;
    var whitespace = /\s+/g;

    function interpret(input) {
      return typeof input === 'string' ? input.replace(trim, '').split(whitespace) : input;
    }

    function classes(el) {
      if (isElement(el)) {
        return el.className.replace(trim, '').split(whitespace);
      }

      return [];
    }

    function set(el, input) {
      if (isElement(el)) {
        el.className = interpret(input).join(' ');
      }
    }

    function add(el, input) {
      var current = remove(el, input);
      var values = interpret(input);

      current.push.apply(current, values);
      set(el, current);

      return current;
    }

    function remove(el, input) {
      var current = classes(el);
      var values = interpret(input);

      values.forEach(function (value) {
        var i = current.indexOf(value);
        if (i !== -1) {
          current.splice(i, 1);
        }
      });

      set(el, current);

      return current;
    }

    function contains(el, input) {
      var current = classes(el);
      var values = interpret(input);

      return values.every(function (value) {
        return current.indexOf(value) !== -1;
      });
    }

    function isElement(o) {
      var elementObjects = (typeof HTMLElement === 'undefined' ? 'undefined' : (0, _typeof3.default)(HTMLElement)) === 'object';
      return elementObjects ? o instanceof HTMLElement : isElementObject(o);
    }

    function isElementObject(o) {
      return o && (typeof o === 'undefined' ? 'undefined' : (0, _typeof3.default)(o)) === 'object' && typeof o.nodeName === 'string' && o.nodeType === 1;
    }

    exports.default = {
      add: add,
      remove: remove,
      contains: contains,
      has: contains,
      set: set,
      get: classes
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getDayFull = getDayFull;
    exports.getDayInitial = getDayInitial;
    exports.getDayAbbreviated = getDayAbbreviated;
    exports.getMonthFull = getMonthFull;
    exports.getMonthAbbreviated = getMonthAbbreviated;
    exports.getDayOfMonth = getDayOfMonth;
    exports.humanize = humanize;
    exports.clone = clone;
    exports.moveToDayOfWeek = moveToDayOfWeek;
    exports.isSameDay = isSameDay;
    exports.isBefore = isBefore;
    exports.isAfter = isAfter;
    var defaultLang = exports.defaultLang = {
      months: {
        full: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],

        abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
      },

      days: {
        full: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],

        abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],

        initials: ['S', 'M', 'T', 'W', 'T', 'F', 'S']
      }
    };

    function pad(value, length) {
      while (value.length < length) {
        value = '0' + value;
      }

      return value;
    }

    function getDayFull(date) {
      var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLang;

      return lang.days.full[date.getDay()];
    }

    function getDayInitial(date) {
      var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLang;

      return lang.days.initials[date.getDay()];
    }

    function getDayAbbreviated(date) {
      var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLang;

      return lang.days.abbreviated[date.getDay()];
    }

    function getMonthFull(date) {
      var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLang;

      return lang.months.full[date.getMonth()];
    }

    function getMonthAbbreviated(date) {
      var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLang;

      return lang.months.abbreviated[date.getMonth()];
    }

    function getDayOfMonth(date) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { pad: true };

      var day = date.getDate().toString();
      return options.pad ? pad(day) : day;
    }

    function humanize(date) {
      var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLang;

      var days = lang.days.abbreviated;
      var months = lang.months.full;

      return days[date.getDay()] + ', ' + months[date.getMonth()] + ' ' + date.getDate() + ', ' + date.getFullYear();
    }

    function clone(date) {
      return new Date(date.getTime());
    }

    function moveToDayOfWeek(date, dayOfWeek) {
      while (date.getDay() !== dayOfWeek) {
        date.setDate(date.getDate() - 1);
      }

      return date;
    }

    function isSameDay(date1, date2) {
      return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
    }

    function isBefore(date1, date2) {
      return date1.getTime() < date2.getTime();
    }

    function isAfter(date1, date2) {
      return date1.getTime() > date2.getTime();
    }

    exports.default = {
      defaultLang: defaultLang,
      getDayFull: getDayFull,
      getDayInitial: getDayInitial,
      getDayAbbreviated: getDayAbbreviated,
      getMonthFull: getMonthFull,
      getMonthAbbreviated: getMonthAbbreviated,
      getDayOfMonth: getDayOfMonth,
      humanize: humanize,
      clone: clone,
      moveToDayOfWeek: moveToDayOfWeek,
      isSameDay: isSameDay,
      isBefore: isBefore,
      isAfter: isAfter
    };
  }, function (module, exports) {

    var core = module.exports = { version: '2.4.0' };
    if (typeof __e == 'number') __e = core;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(202);

    var Component = __webpack_require__(0)(__webpack_require__(89), __webpack_require__(252), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiButton.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiButton.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-e69d6b3a", Component.options);
        } else {
          hotAPI.reload("data-v-e69d6b3a", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(204);

    var Component = __webpack_require__(0)(__webpack_require__(107), __webpack_require__(254), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiPopover.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiPopover.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-fb51df78", Component.options);
        } else {
          hotAPI.reload("data-v-fb51df78", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(174);

    var Component = __webpack_require__(0)(__webpack_require__(109), __webpack_require__(224), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiProgressCircular.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiProgressCircular.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-20257add", Component.options);
        } else {
          hotAPI.reload("data-v-20257add", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _stringify = __webpack_require__(18);

    var _stringify2 = _interopRequireDefault(_stringify);

    var _typeof2 = __webpack_require__(51);

    var _typeof3 = _interopRequireDefault(_typeof2);

    exports.isObject = isObject;
    exports.looseEqual = looseEqual;
    exports.looseIndexOf = looseIndexOf;
    exports.startsWith = startsWith;

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function isObject(obj) {
      return obj !== null && (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === 'object';
    }

    function looseEqual(a, b) {
      return a == b || (isObject(a) && isObject(b) ? (0, _stringify2.default)(a) === (0, _stringify2.default)(b) : false);
    }

    function looseIndexOf(arr, val) {
      for (var i = 0; i < arr.length; i++) {
        if (looseEqual(arr[i], val)) {
          return i;
        }
      }

      return -1;
    }

    function startsWith(string, query) {
      var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      return string.substr(position, query.length) === query;
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { "default": __webpack_require__(132), __esModule: true };
  }, function (module, exports, __webpack_require__) {

    var isObject = __webpack_require__(21);
    module.exports = function (it) {
      if (!isObject(it)) throw TypeError(it + ' is not an object!');
      return it;
    };
  }, function (module, exports) {

    module.exports = function (exec) {
      try {
        return !!exec();
      } catch (e) {
        return true;
      }
    };
  }, function (module, exports) {

    module.exports = function (it) {
      return (typeof it === 'undefined' ? 'undefined' : (0, _typeof6.default)(it)) === 'object' ? it !== null : typeof it === 'function';
    };
  }, function (module, exports, __webpack_require__) {
    var $keys = __webpack_require__(59),
        enumBugKeys = __webpack_require__(30);

    module.exports = _keys2.default || function keys(O) {
      return $keys(O, enumBugKeys);
    };
  }, function (module, exports) {

    module.exports = function (bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
      };
    };
  }, function (module, exports) {

    var id = 0,
        px = Math.random();
    module.exports = function (key) {
      return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
    };
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(198);

    var Component = __webpack_require__(0)(__webpack_require__(103), __webpack_require__(248), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiIconButton.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiIconButton.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-8ced2988", Component.options);
        } else {
          hotAPI.reload("data-v-8ced2988", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(185);

    var Component = __webpack_require__(0)(__webpack_require__(106), __webpack_require__(235), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiModal.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiModal.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-509bc3e8", Component.options);
        } else {
          hotAPI.reload("data-v-509bc3e8", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(200);

    var Component = __webpack_require__(0)(__webpack_require__(125), __webpack_require__(250), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiTooltip.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiTooltip.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-b226babc", Component.options);
        } else {
          hotAPI.reload("data-v-b226babc", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _lodash = __webpack_require__(206);

    var _lodash2 = _interopRequireDefault(_lodash);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      data: function data() {
        return {
          windowResizeListener: null
        };
      },
      mounted: function mounted() {
        var _this = this;

        this.windowResizeListener = (0, _lodash2.default)(function () {
          _this.$emit('window-resize');
        }, 200);

        window.addEventListener('resize', this.windowResizeListener);
      },
      beforeDestroy: function beforeDestroy() {
        window.removeEventListener('resize', this.windowResizeListener);
      }
    };
  }, function (module, exports) {
    module.exports = function (it) {
      if (it == undefined) throw TypeError("Can't call method on  " + it);
      return it;
    };
  }, function (module, exports) {
    module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
  }, function (module, exports, __webpack_require__) {

    var global = __webpack_require__(4),
        core = __webpack_require__(13),
        ctx = __webpack_require__(139),
        hide = __webpack_require__(9),
        PROTOTYPE = 'prototype';

    var $export = function $export(type, name, source) {
      var IS_FORCED = type & $export.F,
          IS_GLOBAL = type & $export.G,
          IS_STATIC = type & $export.S,
          IS_PROTO = type & $export.P,
          IS_BIND = type & $export.B,
          IS_WRAP = type & $export.W,
          exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
          expProto = exports[PROTOTYPE],
          target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
          key,
          own,
          out;
      if (IS_GLOBAL) source = name;
      for (key in source) {
        own = !IS_FORCED && target && target[key] !== undefined;
        if (own && key in exports) continue;

        out = own ? target[key] : source[key];

        exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function (C) {
          var F = function F(a, b, c) {
            if (this instanceof C) {
              switch (arguments.length) {
                case 0:
                  return new C();
                case 1:
                  return new C(a);
                case 2:
                  return new C(a, b);
              }return new C(a, b, c);
            }return C.apply(this, arguments);
          };
          F[PROTOTYPE] = C[PROTOTYPE];
          return F;
        }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;

        if (IS_PROTO) {
          (exports.virtual || (exports.virtual = {}))[key] = out;

          if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
        }
      }
    };

    $export.F = 1;
    $export.G = 2;
    $export.S = 4;
    $export.P = 8;
    $export.B = 16;
    $export.W = 32;
    $export.U = 64;
    $export.R = 128;
    module.exports = $export;
  }, function (module, exports) {

    module.exports = {};
  }, function (module, exports) {

    module.exports = true;
  }, function (module, exports) {

    exports.f = {}.propertyIsEnumerable;
  }, function (module, exports, __webpack_require__) {

    var def = __webpack_require__(7).f,
        has = __webpack_require__(6),
        TAG = __webpack_require__(10)('toStringTag');

    module.exports = function (it, tag, stat) {
      if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
    };
  }, function (module, exports, __webpack_require__) {

    var shared = __webpack_require__(37)('keys'),
        uid = __webpack_require__(24);
    module.exports = function (key) {
      return shared[key] || (shared[key] = uid(key));
    };
  }, function (module, exports, __webpack_require__) {

    var global = __webpack_require__(4),
        SHARED = '__core-js_shared__',
        store = global[SHARED] || (global[SHARED] = {});
    module.exports = function (key) {
      return store[key] || (store[key] = {});
    };
  }, function (module, exports) {
    var ceil = Math.ceil,
        floor = Math.floor;
    module.exports = function (it) {
      return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
    };
  }, function (module, exports, __webpack_require__) {
    var isObject = __webpack_require__(21);

    module.exports = function (it, S) {
      if (!isObject(it)) return it;
      var fn, val;
      if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
      if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
      if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
  }, function (module, exports, __webpack_require__) {

    var global = __webpack_require__(4),
        core = __webpack_require__(13),
        LIBRARY = __webpack_require__(33),
        wksExt = __webpack_require__(41),
        defineProperty = __webpack_require__(7).f;
    module.exports = function (name) {
      var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
      if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
    };
  }, function (module, exports, __webpack_require__) {

    exports.f = __webpack_require__(10);
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(171);

    var Component = __webpack_require__(0)(__webpack_require__(90), __webpack_require__(221), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiCalendar.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiCalendar.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-16dd362f", Component.options);
        } else {
          hotAPI.reload("data-v-16dd362f", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(193);

    var Component = __webpack_require__(0)(__webpack_require__(94), __webpack_require__(243), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiCheckbox.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiCheckbox.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-6d48e798", Component.options);
        } else {
          hotAPI.reload("data-v-6d48e798", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(179);

    var Component = __webpack_require__(0)(__webpack_require__(110), __webpack_require__(229), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiProgressLinear.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiProgressLinear.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-363761e3", Component.options);
        } else {
          hotAPI.reload("data-v-363761e3", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(172);

    var Component = __webpack_require__(0)(__webpack_require__(111), __webpack_require__(222), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiRadio.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiRadio.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-1c88e05a", Component.options);
        } else {
          hotAPI.reload("data-v-1c88e05a", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(183);

    var Component = __webpack_require__(0)(__webpack_require__(117), __webpack_require__(233), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiSnackbar.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiSnackbar.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-4f182f14", Component.options);
        } else {
          hotAPI.reload("data-v-4f182f14", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      inserted: function inserted(el, _ref) {
        var value = _ref.value;

        if (value) {
          el.focus();
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inView = inView;
    exports.scrollIntoView = scrollIntoView;
    exports.resetScroll = resetScroll;
    function inView(element, container) {
      if (!element) {
        return;
      }

      container = container || element.parentElement;

      var top = element.offsetTop;
      var parentTop = container.scrollTop;
      var bottom = top + element.offsetHeight;
      var parentBottom = container.offsetHeight;

      return top >= parentTop && bottom <= parentBottom;
    }

    function scrollIntoView(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { container: null, marginTop: 0 };

      if (!element) {
        return;
      }

      options.container = options.container || element.parentElement;

      if (inView(element, options.container)) {
        return;
      }

      options.container.scrollTop = element.offsetTop - options.marginTop;
    }

    function resetScroll(element) {
      if (!element) {
        return;
      }

      element.scrollTop = 0;
    }

    exports.default = {
      inView: inView,
      scrollIntoView: scrollIntoView,
      resetScroll: resetScroll
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Fast UUID generator, RFC4122 version 4 compliant.
     * @author Jeff Ward (jcward.com).
     * @license MIT license
     * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
     */

    var lut = [];

    for (var i = 0; i < 256; i++) {
      lut[i] = (i < 16 ? '0' : '') + i.toString(16);
    }

    var generate = function generate() {
      var d0 = Math.random() * 0xffffffff | 0;
      var d1 = Math.random() * 0xffffffff | 0;
      var d2 = Math.random() * 0xffffffff | 0;
      var d3 = Math.random() * 0xffffffff | 0;

      return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
    };

    var short = function short(prefix) {
      prefix = prefix || '';

      var uuid = generate();

      return prefix + uuid.split('-')[0];
    };

    exports.default = {
      generate: generate,
      short: short
    };
  }, function (module, exports, __webpack_require__) {

    module.exports = { "default": __webpack_require__(133), __esModule: true };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    exports.__esModule = true;

    var _iterator = __webpack_require__(128);

    var _iterator2 = _interopRequireDefault(_iterator);

    var _symbol = __webpack_require__(127);

    var _symbol2 = _interopRequireDefault(_symbol);

    var _typeof = typeof _symbol2.default === "function" && (0, _typeof6.default)(_iterator2.default) === "symbol" ? function (obj) {
      return typeof obj === 'undefined' ? 'undefined' : (0, _typeof6.default)(obj);
    } : function (obj) {
      return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : (0, _typeof6.default)(obj);
    };

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
      return typeof obj === "undefined" ? "undefined" : _typeof(obj);
    } : function (obj) {
      return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
    };
  }, function (module, exports) {

    var toString = {}.toString;

    module.exports = function (it) {
      return toString.call(it).slice(8, -1);
    };
  }, function (module, exports, __webpack_require__) {

    var isObject = __webpack_require__(21),
        document = __webpack_require__(4).document,
        is = isObject(document) && isObject(document.createElement);
    module.exports = function (it) {
      return is ? document.createElement(it) : {};
    };
  }, function (module, exports, __webpack_require__) {

    module.exports = !__webpack_require__(5) && !__webpack_require__(20)(function () {
      return Object.defineProperty(__webpack_require__(53)('div'), 'a', { get: function get() {
          return 7;
        } }).a != 7;
    });
  }, function (module, exports, __webpack_require__) {

    "use strict";

    var LIBRARY = __webpack_require__(33),
        $export = __webpack_require__(31),
        redefine = __webpack_require__(60),
        hide = __webpack_require__(9),
        has = __webpack_require__(6),
        Iterators = __webpack_require__(32),
        $iterCreate = __webpack_require__(144),
        setToStringTag = __webpack_require__(35),
        getPrototypeOf = __webpack_require__(151),
        ITERATOR = __webpack_require__(10)('iterator'),
        BUGGY = !([].keys && 'next' in [].keys()),
        FF_ITERATOR = '@@iterator',
        KEYS = 'keys',
        VALUES = 'values';

    var returnThis = function returnThis() {
      return this;
    };

    module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
      $iterCreate(Constructor, NAME, next);
      var getMethod = function getMethod(kind) {
        if (!BUGGY && kind in proto) return proto[kind];
        switch (kind) {
          case KEYS:
            return function keys() {
              return new Constructor(this, kind);
            };
          case VALUES:
            return function values() {
              return new Constructor(this, kind);
            };
        }return function entries() {
          return new Constructor(this, kind);
        };
      };
      var TAG = NAME + ' Iterator',
          DEF_VALUES = DEFAULT == VALUES,
          VALUES_BUG = false,
          proto = Base.prototype,
          $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
          $default = $native || getMethod(DEFAULT),
          $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined,
          $anyNative = NAME == 'Array' ? proto.entries || $native : $native,
          methods,
          key,
          IteratorPrototype;

      if ($anyNative) {
        IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
        if (IteratorPrototype !== Object.prototype) {
          setToStringTag(IteratorPrototype, TAG, true);

          if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
        }
      }

      if (DEF_VALUES && $native && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }

      if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
        hide(proto, ITERATOR, $default);
      }

      Iterators[NAME] = $default;
      Iterators[TAG] = returnThis;
      if (DEFAULT) {
        methods = {
          values: DEF_VALUES ? $default : getMethod(VALUES),
          keys: IS_SET ? $default : getMethod(KEYS),
          entries: $entries
        };
        if (FORCED) for (key in methods) {
          if (!(key in proto)) redefine(proto, key, methods[key]);
        } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
      }
      return methods;
    };
  }, function (module, exports, __webpack_require__) {
    var anObject = __webpack_require__(19),
        dPs = __webpack_require__(148),
        enumBugKeys = __webpack_require__(30),
        IE_PROTO = __webpack_require__(36)('IE_PROTO'),
        Empty = function Empty() {},
        PROTOTYPE = 'prototype';

    var _createDict = function createDict() {
      var iframe = __webpack_require__(53)('iframe'),
          i = enumBugKeys.length,
          lt = '<',
          gt = '>',
          iframeDocument;
      iframe.style.display = 'none';
      __webpack_require__(141).appendChild(iframe);
      iframe.src = 'javascript:';
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
      iframeDocument.close();
      _createDict = iframeDocument.F;
      while (i--) {
        delete _createDict[PROTOTYPE][enumBugKeys[i]];
      }return _createDict();
    };

    module.exports = _create3.default || function create(O, Properties) {
      var result;
      if (O !== null) {
        Empty[PROTOTYPE] = anObject(O);
        result = new Empty();
        Empty[PROTOTYPE] = null;

        result[IE_PROTO] = O;
      } else result = _createDict();
      return Properties === undefined ? result : dPs(result, Properties);
    };
  }, function (module, exports, __webpack_require__) {
    var $keys = __webpack_require__(59),
        hiddenKeys = __webpack_require__(30).concat('length', 'prototype');

    exports.f = _getOwnPropertyNames2.default || function getOwnPropertyNames(O) {
      return $keys(O, hiddenKeys);
    };
  }, function (module, exports) {

    exports.f = _getOwnPropertySymbols2.default;
  }, function (module, exports, __webpack_require__) {

    var has = __webpack_require__(6),
        toIObject = __webpack_require__(8),
        arrayIndexOf = __webpack_require__(138)(false),
        IE_PROTO = __webpack_require__(36)('IE_PROTO');

    module.exports = function (object, names) {
      var O = toIObject(object),
          i = 0,
          result = [],
          key;
      for (key in O) {
        if (key != IE_PROTO) has(O, key) && result.push(key);
      }
      while (names.length > i) {
        if (has(O, key = names[i++])) {
          ~arrayIndexOf(result, key) || result.push(key);
        }
      }return result;
    };
  }, function (module, exports, __webpack_require__) {

    module.exports = __webpack_require__(9);
  }, function (module, exports, __webpack_require__) {

    "use strict";

    function fuzzysearch(needle, haystack) {
      var tlen = haystack.length;
      var qlen = needle.length;
      if (qlen > tlen) {
        return false;
      }
      if (qlen === tlen) {
        return needle === haystack;
      }
      outer: for (var i = 0, j = 0; i < qlen; i++) {
        var nch = needle.charCodeAt(i);
        while (j < tlen) {
          if (haystack.charCodeAt(j++) === nch) {
            continue outer;
          }
        }
        return false;
      }
      return true;
    }

    module.exports = fuzzysearch;
  }, function (module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

    (function (root, factory) {
      if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(63)], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else if ((typeof exports === 'undefined' ? 'undefined' : (0, _typeof6.default)(exports)) === 'object') {
        module.exports = factory(require('tether'));
      } else {
        root.Drop = factory(root.Tether);
      }
    })(this, function (Tether) {
      'use strict';

      var _bind = Function.prototype.bind;

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i['return']) _i['return']();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if ((0, _isIterable3.default)(Object(arr))) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError('Invalid attempt to destructure non-iterable instance');
          }
        };
      }();

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;(0, _defineProperty5.default)(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _get = function get(_x2, _x3, _x4) {
        var _again = true;_function: while (_again) {
          var object = _x2,
              property = _x3,
              receiver = _x4;_again = false;if (object === null) object = Function.prototype;var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);if (desc === undefined) {
            var parent = (0, _getPrototypeOf2.default)(object);if (parent === null) {
              return undefined;
            } else {
              _x2 = parent;_x3 = property;_x4 = receiver;_again = true;desc = parent = undefined;continue _function;
            }
          } else if ('value' in desc) {
            return desc.value;
          } else {
            var getter = desc.get;if (getter === undefined) {
              return undefined;
            }return getter.call(receiver);
          }
        }
      };

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function');
        }
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
          throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : (0, _typeof6.default)(superClass)));
        }subClass.prototype = (0, _create3.default)(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var _Tether$Utils = Tether.Utils;
      var extend = _Tether$Utils.extend;
      var addClass = _Tether$Utils.addClass;
      var removeClass = _Tether$Utils.removeClass;
      var hasClass = _Tether$Utils.hasClass;
      var Evented = _Tether$Utils.Evented;

      function sortAttach(str) {
        var _str$split = str.split(' ');

        var _str$split2 = _slicedToArray(_str$split, 2);

        var first = _str$split2[0];
        var second = _str$split2[1];

        if (['left', 'right'].indexOf(first) >= 0) {
          var _ref = [second, first];
          first = _ref[0];
          second = _ref[1];
        }
        return [first, second].join(' ');
      }

      function removeFromArray(arr, item) {
        var index = undefined;
        var results = [];
        while ((index = arr.indexOf(item)) !== -1) {
          results.push(arr.splice(index, 1));
        }
        return results;
      }

      var clickEvents = ['click'];
      if ('ontouchstart' in document.documentElement) {
        clickEvents.push('touchstart');
      }

      var transitionEndEvents = {
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'otransitionend',
        'transition': 'transitionend'
      };

      var transitionEndEvent = '';
      for (var _name in transitionEndEvents) {
        if ({}.hasOwnProperty.call(transitionEndEvents, _name)) {
          var tempEl = document.createElement('p');
          if (typeof tempEl.style[_name] !== 'undefined') {
            transitionEndEvent = transitionEndEvents[_name];
          }
        }
      }

      var MIRROR_ATTACH = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top',
        middle: 'middle',
        center: 'center'
      };

      var allDrops = {};

      function createContext() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var drop = function drop() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return new (_bind.apply(DropInstance, [null].concat(args)))();
        };

        extend(drop, {
          createContext: createContext,
          drops: [],
          defaults: {}
        });

        var defaultOptions = {
          classPrefix: 'drop',
          defaults: {
            position: 'bottom left',
            openOn: 'click',
            beforeClose: null,
            constrainToScrollParent: true,
            constrainToWindow: true,
            classes: '',
            remove: false,
            openDelay: 0,
            closeDelay: 50,

            focusDelay: null,
            blurDelay: null,
            hoverOpenDelay: null,
            hoverCloseDelay: null,
            tetherOptions: {}
          }
        };

        extend(drop, defaultOptions, options);
        extend(drop.defaults, defaultOptions.defaults, options.defaults);

        if (typeof allDrops[drop.classPrefix] === 'undefined') {
          allDrops[drop.classPrefix] = [];
        }

        drop.updateBodyClasses = function () {

          var anyOpen = false;
          var drops = allDrops[drop.classPrefix];
          var len = drops.length;
          for (var i = 0; i < len; ++i) {
            if (drops[i].isOpened()) {
              anyOpen = true;
              break;
            }
          }

          if (anyOpen) {
            addClass(document.body, drop.classPrefix + '-open');
          } else {
            removeClass(document.body, drop.classPrefix + '-open');
          }
        };

        var DropInstance = function (_Evented) {
          _inherits(DropInstance, _Evented);

          function DropInstance(opts) {
            _classCallCheck(this, DropInstance);

            _get((0, _getPrototypeOf2.default)(DropInstance.prototype), 'constructor', this).call(this);
            this.options = extend({}, drop.defaults, opts);
            this.target = this.options.target;

            if (typeof this.target === 'undefined') {
              throw new Error('Drop Error: You must provide a target.');
            }

            var dataPrefix = 'data-' + drop.classPrefix;

            var contentAttr = this.target.getAttribute(dataPrefix);
            if (contentAttr && this.options.content == null) {
              this.options.content = contentAttr;
            }

            var attrsOverride = ['position', 'openOn'];
            for (var i = 0; i < attrsOverride.length; ++i) {

              var override = this.target.getAttribute(dataPrefix + '-' + attrsOverride[i]);
              if (override && this.options[attrsOverride[i]] == null) {
                this.options[attrsOverride[i]] = override;
              }
            }

            if (this.options.classes && this.options.addTargetClasses !== false) {
              addClass(this.target, this.options.classes);
            }

            drop.drops.push(this);
            allDrops[drop.classPrefix].push(this);

            this._boundEvents = [];
            this.bindMethods();
            this.setupElements();
            this.setupEvents();
            this.setupTether();
          }

          _createClass(DropInstance, [{
            key: '_on',
            value: function _on(element, event, handler) {
              this._boundEvents.push({ element: element, event: event, handler: handler });
              element.addEventListener(event, handler);
            }
          }, {
            key: 'bindMethods',
            value: function bindMethods() {
              this.transitionEndHandler = this._transitionEndHandler.bind(this);
            }
          }, {
            key: 'setupElements',
            value: function setupElements() {
              var _this = this;

              this.drop = document.createElement('div');
              addClass(this.drop, drop.classPrefix);

              if (this.options.classes) {
                addClass(this.drop, this.options.classes);
              }

              this.content = document.createElement('div');
              addClass(this.content, drop.classPrefix + '-content');

              if (typeof this.options.content === 'function') {
                var generateAndSetContent = function generateAndSetContent() {
                  var contentElementOrHTML = _this.options.content.call(_this, _this);

                  if (typeof contentElementOrHTML === 'string') {
                    _this.content.innerHTML = contentElementOrHTML;
                  } else if ((typeof contentElementOrHTML === 'undefined' ? 'undefined' : (0, _typeof6.default)(contentElementOrHTML)) === 'object') {
                    _this.content.innerHTML = '';
                    _this.content.appendChild(contentElementOrHTML);
                  } else {
                    throw new Error('Drop Error: Content function should return a string or HTMLElement.');
                  }
                };

                generateAndSetContent();
                this.on('open', generateAndSetContent.bind(this));
              } else if ((0, _typeof6.default)(this.options.content) === 'object') {
                this.content.appendChild(this.options.content);
              } else {
                this.content.innerHTML = this.options.content;
              }

              this.drop.appendChild(this.content);
            }
          }, {
            key: 'setupTether',
            value: function setupTether() {
              var dropAttach = this.options.position.split(' ');
              dropAttach[0] = MIRROR_ATTACH[dropAttach[0]];
              dropAttach = dropAttach.join(' ');

              var constraints = [];
              if (this.options.constrainToScrollParent) {
                constraints.push({
                  to: 'scrollParent',
                  pin: 'top, bottom',
                  attachment: 'together none'
                });
              } else {
                constraints.push({
                  to: 'scrollParent'
                });
              }

              if (this.options.constrainToWindow !== false) {
                constraints.push({
                  to: 'window',
                  attachment: 'together'
                });
              } else {
                constraints.push({
                  to: 'window'
                });
              }

              var opts = {
                element: this.drop,
                target: this.target,
                attachment: sortAttach(dropAttach),
                targetAttachment: sortAttach(this.options.position),
                classPrefix: drop.classPrefix,
                offset: '0 0',
                targetOffset: '0 0',
                enabled: false,
                constraints: constraints,
                addTargetClasses: this.options.addTargetClasses
              };

              if (this.options.tetherOptions !== false) {
                this.tether = new Tether(extend({}, opts, this.options.tetherOptions));
              }
            }
          }, {
            key: 'setupEvents',
            value: function setupEvents() {
              var _this2 = this;

              if (!this.options.openOn) {
                return;
              }

              if (this.options.openOn === 'always') {
                setTimeout(this.open.bind(this));
                return;
              }

              var events = this.options.openOn.split(' ');

              if (events.indexOf('click') >= 0) {
                var openHandler = function openHandler(event) {
                  _this2.toggle(event);
                  event.preventDefault();
                };

                var closeHandler = function closeHandler(event) {
                  if (!_this2.isOpened()) {
                    return;
                  }

                  if (event.target === _this2.drop || _this2.drop.contains(event.target)) {
                    return;
                  }

                  if (event.target === _this2.target || _this2.target.contains(event.target)) {
                    return;
                  }

                  _this2.close(event);
                };

                for (var i = 0; i < clickEvents.length; ++i) {
                  var clickEvent = clickEvents[i];
                  this._on(this.target, clickEvent, openHandler);
                  this._on(document, clickEvent, closeHandler);
                }
              }

              var inTimeout = null;
              var outTimeout = null;

              var inHandler = function inHandler(event) {
                if (outTimeout !== null) {
                  clearTimeout(outTimeout);
                } else {
                  inTimeout = setTimeout(function () {
                    _this2.open(event);
                    inTimeout = null;
                  }, (event.type === 'focus' ? _this2.options.focusDelay : _this2.options.hoverOpenDelay) || _this2.options.openDelay);
                }
              };

              var outHandler = function outHandler(event) {
                if (inTimeout !== null) {
                  clearTimeout(inTimeout);
                } else {
                  outTimeout = setTimeout(function () {
                    _this2.close(event);
                    outTimeout = null;
                  }, (event.type === 'blur' ? _this2.options.blurDelay : _this2.options.hoverCloseDelay) || _this2.options.closeDelay);
                }
              };

              if (events.indexOf('hover') >= 0) {
                this._on(this.target, 'mouseover', inHandler);
                this._on(this.drop, 'mouseover', inHandler);
                this._on(this.target, 'mouseout', outHandler);
                this._on(this.drop, 'mouseout', outHandler);
              }

              if (events.indexOf('focus') >= 0) {
                this._on(this.target, 'focus', inHandler);
                this._on(this.drop, 'focus', inHandler);
                this._on(this.target, 'blur', outHandler);
                this._on(this.drop, 'blur', outHandler);
              }
            }
          }, {
            key: 'isOpened',
            value: function isOpened() {
              if (this.drop) {
                return hasClass(this.drop, drop.classPrefix + '-open');
              }
            }
          }, {
            key: 'toggle',
            value: function toggle(event) {
              if (this.isOpened()) {
                this.close(event);
              } else {
                this.open(event);
              }
            }
          }, {
            key: 'open',
            value: function open(event) {
              var _this3 = this;

              if (this.isOpened()) {
                return;
              }

              if (!this.drop.parentNode) {
                document.body.appendChild(this.drop);
              }

              if (typeof this.tether !== 'undefined') {
                this.tether.enable();
              }

              addClass(this.drop, drop.classPrefix + '-open');
              addClass(this.drop, drop.classPrefix + '-open-transitionend');

              setTimeout(function () {
                if (_this3.drop) {
                  addClass(_this3.drop, drop.classPrefix + '-after-open');
                }
              });

              if (typeof this.tether !== 'undefined') {
                this.tether.position();
              }

              this.trigger('open');

              drop.updateBodyClasses();
            }
          }, {
            key: '_transitionEndHandler',
            value: function _transitionEndHandler(e) {
              if (e.target !== e.currentTarget) {
                return;
              }

              if (!hasClass(this.drop, drop.classPrefix + '-open')) {
                removeClass(this.drop, drop.classPrefix + '-open-transitionend');
              }
              this.drop.removeEventListener(transitionEndEvent, this.transitionEndHandler);
            }
          }, {
            key: 'beforeCloseHandler',
            value: function beforeCloseHandler(event) {
              var shouldClose = true;

              if (!this.isClosing && typeof this.options.beforeClose === 'function') {
                this.isClosing = true;
                shouldClose = this.options.beforeClose(event, this) !== false;
              }

              this.isClosing = false;

              return shouldClose;
            }
          }, {
            key: 'close',
            value: function close(event) {
              if (!this.isOpened()) {
                return;
              }

              if (!this.beforeCloseHandler(event)) {
                return;
              }

              removeClass(this.drop, drop.classPrefix + '-open');
              removeClass(this.drop, drop.classPrefix + '-after-open');

              this.drop.addEventListener(transitionEndEvent, this.transitionEndHandler);

              this.trigger('close');

              if (typeof this.tether !== 'undefined') {
                this.tether.disable();
              }

              drop.updateBodyClasses();

              if (this.options.remove) {
                this.remove(event);
              }
            }
          }, {
            key: 'remove',
            value: function remove(event) {
              this.close(event);
              if (this.drop.parentNode) {
                this.drop.parentNode.removeChild(this.drop);
              }
            }
          }, {
            key: 'position',
            value: function position() {
              if (this.isOpened() && typeof this.tether !== 'undefined') {
                this.tether.position();
              }
            }
          }, {
            key: 'destroy',
            value: function destroy() {
              this.remove();

              if (typeof this.tether !== 'undefined') {
                this.tether.destroy();
              }

              for (var i = 0; i < this._boundEvents.length; ++i) {
                var _boundEvents$i = this._boundEvents[i];
                var element = _boundEvents$i.element;
                var _event = _boundEvents$i.event;
                var handler = _boundEvents$i.handler;

                element.removeEventListener(_event, handler);
              }

              this._boundEvents = [];

              this.tether = null;
              this.drop = null;
              this.content = null;
              this.target = null;

              removeFromArray(allDrops[drop.classPrefix], this);
              removeFromArray(drop.drops, this);
            }
          }]);

          return DropInstance;
        }(Evented);

        return drop;
      }

      var Drop = createContext();

      document.addEventListener('DOMContentLoaded', function () {
        Drop.updateBodyClasses();
      });
      return Drop;
    });
  }, function (module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

    (function (root, factory) {
      if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else if ((typeof exports === 'undefined' ? 'undefined' : (0, _typeof6.default)(exports)) === 'object') {
        module.exports = factory(require, exports, module);
      } else {
        root.Tether = factory();
      }
    })(this, function (require, exports, module) {

      'use strict';

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;(0, _defineProperty5.default)(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function');
        }
      }

      var TetherBase = undefined;
      if (typeof TetherBase === 'undefined') {
        TetherBase = { modules: [] };
      }

      var zeroElement = null;

      function getActualBoundingClientRect(node) {
        var boundingRect = node.getBoundingClientRect();

        var rect = {};
        for (var k in boundingRect) {
          rect[k] = boundingRect[k];
        }

        if (node.ownerDocument !== document) {
          var _frameElement = node.ownerDocument.defaultView.frameElement;
          if (_frameElement) {
            var frameRect = getActualBoundingClientRect(_frameElement);
            rect.top += frameRect.top;
            rect.bottom += frameRect.top;
            rect.left += frameRect.left;
            rect.right += frameRect.left;
          }
        }

        return rect;
      }

      function getScrollParents(el) {
        var computedStyle = getComputedStyle(el) || {};
        var position = computedStyle.position;
        var parents = [];

        if (position === 'fixed') {
          return [el];
        }

        var parent = el;
        while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {
          var style = undefined;
          try {
            style = getComputedStyle(parent);
          } catch (err) {}

          if (typeof style === 'undefined' || style === null) {
            parents.push(parent);
            return parents;
          }

          var _style = style;
          var overflow = _style.overflow;
          var overflowX = _style.overflowX;
          var overflowY = _style.overflowY;

          if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
            if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {
              parents.push(parent);
            }
          }
        }

        parents.push(el.ownerDocument.body);

        if (el.ownerDocument !== document) {
          parents.push(el.ownerDocument.defaultView);
        }

        return parents;
      }

      var uniqueId = function () {
        var id = 0;
        return function () {
          return ++id;
        };
      }();

      var zeroPosCache = {};
      var getOrigin = function getOrigin() {
        var node = zeroElement;
        if (!node || !document.body.contains(node)) {
          node = document.createElement('div');
          node.setAttribute('data-tether-id', uniqueId());
          extend(node.style, {
            top: 0,
            left: 0,
            position: 'absolute'
          });

          document.body.appendChild(node);

          zeroElement = node;
        }

        var id = node.getAttribute('data-tether-id');
        if (typeof zeroPosCache[id] === 'undefined') {
          zeroPosCache[id] = getActualBoundingClientRect(node);

          defer(function () {
            delete zeroPosCache[id];
          });
        }

        return zeroPosCache[id];
      };

      function removeUtilElements() {
        if (zeroElement) {
          document.body.removeChild(zeroElement);
        }
        zeroElement = null;
      };

      function getBounds(el) {
        var doc = undefined;
        if (el === document) {
          doc = document;
          el = document.documentElement;
        } else {
          doc = el.ownerDocument;
        }

        var docEl = doc.documentElement;

        var box = getActualBoundingClientRect(el);

        var origin = getOrigin();

        box.top -= origin.top;
        box.left -= origin.left;

        if (typeof box.width === 'undefined') {
          box.width = document.body.scrollWidth - box.left - box.right;
        }
        if (typeof box.height === 'undefined') {
          box.height = document.body.scrollHeight - box.top - box.bottom;
        }

        box.top = box.top - docEl.clientTop;
        box.left = box.left - docEl.clientLeft;
        box.right = doc.body.clientWidth - box.width - box.left;
        box.bottom = doc.body.clientHeight - box.height - box.top;

        return box;
      }

      function getOffsetParent(el) {
        return el.offsetParent || document.documentElement;
      }

      var _scrollBarSize = null;
      function getScrollBarSize() {
        if (_scrollBarSize) {
          return _scrollBarSize;
        }
        var inner = document.createElement('div');
        inner.style.width = '100%';
        inner.style.height = '200px';

        var outer = document.createElement('div');
        extend(outer.style, {
          position: 'absolute',
          top: 0,
          left: 0,
          pointerEvents: 'none',
          visibility: 'hidden',
          width: '200px',
          height: '150px',
          overflow: 'hidden'
        });

        outer.appendChild(inner);

        document.body.appendChild(outer);

        var widthContained = inner.offsetWidth;
        outer.style.overflow = 'scroll';
        var widthScroll = inner.offsetWidth;

        if (widthContained === widthScroll) {
          widthScroll = outer.clientWidth;
        }

        document.body.removeChild(outer);

        var width = widthContained - widthScroll;

        _scrollBarSize = { width: width, height: width };
        return _scrollBarSize;
      }

      function extend() {
        var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var args = [];

        Array.prototype.push.apply(args, arguments);

        args.slice(1).forEach(function (obj) {
          if (obj) {
            for (var key in obj) {
              if ({}.hasOwnProperty.call(obj, key)) {
                out[key] = obj[key];
              }
            }
          }
        });

        return out;
      }

      function removeClass(el, name) {
        if (typeof el.classList !== 'undefined') {
          name.split(' ').forEach(function (cls) {
            if (cls.trim()) {
              el.classList.remove(cls);
            }
          });
        } else {
          var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');
          var className = getClassName(el).replace(regex, ' ');
          setClassName(el, className);
        }
      }

      function addClass(el, name) {
        if (typeof el.classList !== 'undefined') {
          name.split(' ').forEach(function (cls) {
            if (cls.trim()) {
              el.classList.add(cls);
            }
          });
        } else {
          removeClass(el, name);
          var cls = getClassName(el) + (' ' + name);
          setClassName(el, cls);
        }
      }

      function hasClass(el, name) {
        if (typeof el.classList !== 'undefined') {
          return el.classList.contains(name);
        }
        var className = getClassName(el);
        return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);
      }

      function getClassName(el) {
        if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {
          return el.className.baseVal;
        }
        return el.className;
      }

      function setClassName(el, className) {
        el.setAttribute('class', className);
      }

      function updateClasses(el, add, all) {
        all.forEach(function (cls) {
          if (add.indexOf(cls) === -1 && hasClass(el, cls)) {
            removeClass(el, cls);
          }
        });

        add.forEach(function (cls) {
          if (!hasClass(el, cls)) {
            addClass(el, cls);
          }
        });
      }

      var deferred = [];

      var defer = function defer(fn) {
        deferred.push(fn);
      };

      var flush = function flush() {
        var fn = undefined;
        while (fn = deferred.pop()) {
          fn();
        }
      };

      var Evented = function () {
        function Evented() {
          _classCallCheck(this, Evented);
        }

        _createClass(Evented, [{
          key: 'on',
          value: function on(event, handler, ctx) {
            var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

            if (typeof this.bindings === 'undefined') {
              this.bindings = {};
            }
            if (typeof this.bindings[event] === 'undefined') {
              this.bindings[event] = [];
            }
            this.bindings[event].push({ handler: handler, ctx: ctx, once: once });
          }
        }, {
          key: 'once',
          value: function once(event, handler, ctx) {
            this.on(event, handler, ctx, true);
          }
        }, {
          key: 'off',
          value: function off(event, handler) {
            if (typeof this.bindings === 'undefined' || typeof this.bindings[event] === 'undefined') {
              return;
            }

            if (typeof handler === 'undefined') {
              delete this.bindings[event];
            } else {
              var i = 0;
              while (i < this.bindings[event].length) {
                if (this.bindings[event][i].handler === handler) {
                  this.bindings[event].splice(i, 1);
                } else {
                  ++i;
                }
              }
            }
          }
        }, {
          key: 'trigger',
          value: function trigger(event) {
            if (typeof this.bindings !== 'undefined' && this.bindings[event]) {
              var i = 0;

              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }

              while (i < this.bindings[event].length) {
                var _bindings$event$i = this.bindings[event][i];
                var handler = _bindings$event$i.handler;
                var ctx = _bindings$event$i.ctx;
                var once = _bindings$event$i.once;

                var context = ctx;
                if (typeof context === 'undefined') {
                  context = this;
                }

                handler.apply(context, args);

                if (once) {
                  this.bindings[event].splice(i, 1);
                } else {
                  ++i;
                }
              }
            }
          }
        }]);

        return Evented;
      }();

      TetherBase.Utils = {
        getActualBoundingClientRect: getActualBoundingClientRect,
        getScrollParents: getScrollParents,
        getBounds: getBounds,
        getOffsetParent: getOffsetParent,
        extend: extend,
        addClass: addClass,
        removeClass: removeClass,
        hasClass: hasClass,
        updateClasses: updateClasses,
        defer: defer,
        flush: flush,
        uniqueId: uniqueId,
        Evented: Evented,
        getScrollBarSize: getScrollBarSize,
        removeUtilElements: removeUtilElements
      };


      'use strict';

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i['return']) _i['return']();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if ((0, _isIterable3.default)(Object(arr))) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError('Invalid attempt to destructure non-iterable instance');
          }
        };
      }();

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;(0, _defineProperty5.default)(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _get = function get(_x6, _x7, _x8) {
        var _again = true;_function: while (_again) {
          var object = _x6,
              property = _x7,
              receiver = _x8;_again = false;if (object === null) object = Function.prototype;var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);if (desc === undefined) {
            var parent = (0, _getPrototypeOf2.default)(object);if (parent === null) {
              return undefined;
            } else {
              _x6 = parent;_x7 = property;_x8 = receiver;_again = true;desc = parent = undefined;continue _function;
            }
          } else if ('value' in desc) {
            return desc.value;
          } else {
            var getter = desc.get;if (getter === undefined) {
              return undefined;
            }return getter.call(receiver);
          }
        }
      };

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function');
        }
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
          throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : (0, _typeof6.default)(superClass)));
        }subClass.prototype = (0, _create3.default)(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
      }

      if (typeof TetherBase === 'undefined') {
        throw new Error('You must include the utils.js file before tether.js');
      }

      var _TetherBase$Utils = TetherBase.Utils;
      var getScrollParents = _TetherBase$Utils.getScrollParents;
      var getBounds = _TetherBase$Utils.getBounds;
      var getOffsetParent = _TetherBase$Utils.getOffsetParent;
      var extend = _TetherBase$Utils.extend;
      var addClass = _TetherBase$Utils.addClass;
      var removeClass = _TetherBase$Utils.removeClass;
      var updateClasses = _TetherBase$Utils.updateClasses;
      var defer = _TetherBase$Utils.defer;
      var flush = _TetherBase$Utils.flush;
      var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;
      var removeUtilElements = _TetherBase$Utils.removeUtilElements;

      function within(a, b) {
        var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

        return a + diff >= b && b >= a - diff;
      }

      var transformKey = function () {
        if (typeof document === 'undefined') {
          return '';
        }
        var el = document.createElement('div');

        var transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];
        for (var i = 0; i < transforms.length; ++i) {
          var key = transforms[i];
          if (el.style[key] !== undefined) {
            return key;
          }
        }
      }();

      var tethers = [];

      var position = function position() {
        tethers.forEach(function (tether) {
          tether.position(false);
        });
        flush();
      };

      function now() {
        if (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') {
          return performance.now();
        }
        return +new Date();
      }

      (function () {
        var lastCall = null;
        var lastDuration = null;
        var pendingTimeout = null;

        var tick = function tick() {
          if (typeof lastDuration !== 'undefined' && lastDuration > 16) {
            lastDuration = Math.min(lastDuration - 16, 250);

            pendingTimeout = setTimeout(tick, 250);
            return;
          }

          if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {
            return;
          }

          if (pendingTimeout != null) {
            clearTimeout(pendingTimeout);
            pendingTimeout = null;
          }

          lastCall = now();
          position();
          lastDuration = now() - lastCall;
        };

        if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {
          ['resize', 'scroll', 'touchmove'].forEach(function (event) {
            window.addEventListener(event, tick);
          });
        }
      })();

      var MIRROR_LR = {
        center: 'center',
        left: 'right',
        right: 'left'
      };

      var MIRROR_TB = {
        middle: 'middle',
        top: 'bottom',
        bottom: 'top'
      };

      var OFFSET_MAP = {
        top: 0,
        left: 0,
        middle: '50%',
        center: '50%',
        bottom: '100%',
        right: '100%'
      };

      var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {
        var left = attachment.left;
        var top = attachment.top;

        if (left === 'auto') {
          left = MIRROR_LR[relativeToAttachment.left];
        }

        if (top === 'auto') {
          top = MIRROR_TB[relativeToAttachment.top];
        }

        return { left: left, top: top };
      };

      var attachmentToOffset = function attachmentToOffset(attachment) {
        var left = attachment.left;
        var top = attachment.top;

        if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {
          left = OFFSET_MAP[attachment.left];
        }

        if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {
          top = OFFSET_MAP[attachment.top];
        }

        return { left: left, top: top };
      };

      function addOffset() {
        var out = { top: 0, left: 0 };

        for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {
          offsets[_key] = arguments[_key];
        }

        offsets.forEach(function (_ref) {
          var top = _ref.top;
          var left = _ref.left;

          if (typeof top === 'string') {
            top = parseFloat(top, 10);
          }
          if (typeof left === 'string') {
            left = parseFloat(left, 10);
          }

          out.top += top;
          out.left += left;
        });

        return out;
      }

      function offsetToPx(offset, size) {
        if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {
          offset.left = parseFloat(offset.left, 10) / 100 * size.width;
        }
        if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {
          offset.top = parseFloat(offset.top, 10) / 100 * size.height;
        }

        return offset;
      }

      var parseOffset = function parseOffset(value) {
        var _value$split = value.split(' ');

        var _value$split2 = _slicedToArray(_value$split, 2);

        var top = _value$split2[0];
        var left = _value$split2[1];

        return { top: top, left: left };
      };
      var parseAttachment = parseOffset;

      var TetherClass = function (_Evented) {
        _inherits(TetherClass, _Evented);

        function TetherClass(options) {
          var _this = this;

          _classCallCheck(this, TetherClass);

          _get((0, _getPrototypeOf2.default)(TetherClass.prototype), 'constructor', this).call(this);
          this.position = this.position.bind(this);

          tethers.push(this);

          this.history = [];

          this.setOptions(options, false);

          TetherBase.modules.forEach(function (module) {
            if (typeof module.initialize !== 'undefined') {
              module.initialize.call(_this);
            }
          });

          this.position();
        }

        _createClass(TetherClass, [{
          key: 'getClass',
          value: function getClass() {
            var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
            var classes = this.options.classes;

            if (typeof classes !== 'undefined' && classes[key]) {
              return this.options.classes[key];
            } else if (this.options.classPrefix) {
              return this.options.classPrefix + '-' + key;
            } else {
              return key;
            }
          }
        }, {
          key: 'setOptions',
          value: function setOptions(options) {
            var _this2 = this;

            var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

            var defaults = {
              offset: '0 0',
              targetOffset: '0 0',
              targetAttachment: 'auto auto',
              classPrefix: 'tether'
            };

            this.options = extend(defaults, options);

            var _options = this.options;
            var element = _options.element;
            var target = _options.target;
            var targetModifier = _options.targetModifier;

            this.element = element;
            this.target = target;
            this.targetModifier = targetModifier;

            if (this.target === 'viewport') {
              this.target = document.body;
              this.targetModifier = 'visible';
            } else if (this.target === 'scroll-handle') {
              this.target = document.body;
              this.targetModifier = 'scroll-handle';
            }

            ['element', 'target'].forEach(function (key) {
              if (typeof _this2[key] === 'undefined') {
                throw new Error('Tether Error: Both element and target must be defined');
              }

              if (typeof _this2[key].jquery !== 'undefined') {
                _this2[key] = _this2[key][0];
              } else if (typeof _this2[key] === 'string') {
                _this2[key] = document.querySelector(_this2[key]);
              }
            });

            addClass(this.element, this.getClass('element'));
            if (!(this.options.addTargetClasses === false)) {
              addClass(this.target, this.getClass('target'));
            }

            if (!this.options.attachment) {
              throw new Error('Tether Error: You must provide an attachment');
            }

            this.targetAttachment = parseAttachment(this.options.targetAttachment);
            this.attachment = parseAttachment(this.options.attachment);
            this.offset = parseOffset(this.options.offset);
            this.targetOffset = parseOffset(this.options.targetOffset);

            if (typeof this.scrollParents !== 'undefined') {
              this.disable();
            }

            if (this.targetModifier === 'scroll-handle') {
              this.scrollParents = [this.target];
            } else {
              this.scrollParents = getScrollParents(this.target);
            }

            if (!(this.options.enabled === false)) {
              this.enable(pos);
            }
          }
        }, {
          key: 'getTargetBounds',
          value: function getTargetBounds() {
            if (typeof this.targetModifier !== 'undefined') {
              if (this.targetModifier === 'visible') {
                if (this.target === document.body) {
                  return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };
                } else {
                  var bounds = getBounds(this.target);

                  var out = {
                    height: bounds.height,
                    width: bounds.width,
                    top: bounds.top,
                    left: bounds.left
                  };

                  out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
                  out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));
                  out.height = Math.min(innerHeight, out.height);
                  out.height -= 2;

                  out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
                  out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));
                  out.width = Math.min(innerWidth, out.width);
                  out.width -= 2;

                  if (out.top < pageYOffset) {
                    out.top = pageYOffset;
                  }
                  if (out.left < pageXOffset) {
                    out.left = pageXOffset;
                  }

                  return out;
                }
              } else if (this.targetModifier === 'scroll-handle') {
                var bounds = undefined;
                var target = this.target;
                if (target === document.body) {
                  target = document.documentElement;

                  bounds = {
                    left: pageXOffset,
                    top: pageYOffset,
                    height: innerHeight,
                    width: innerWidth
                  };
                } else {
                  bounds = getBounds(target);
                }

                var style = getComputedStyle(target);

                var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;

                var scrollBottom = 0;
                if (hasBottomScroll) {
                  scrollBottom = 15;
                }

                var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;

                var out = {
                  width: 15,
                  height: height * 0.975 * (height / target.scrollHeight),
                  left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15
                };

                var fitAdj = 0;
                if (height < 408 && this.target === document.body) {
                  fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
                }

                if (this.target !== document.body) {
                  out.height = Math.max(out.height, 24);
                }

                var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
                out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);

                if (this.target === document.body) {
                  out.height = Math.max(out.height, 24);
                }

                return out;
              }
            } else {
              return getBounds(this.target);
            }
          }
        }, {
          key: 'clearCache',
          value: function clearCache() {
            this._cache = {};
          }
        }, {
          key: 'cache',
          value: function cache(k, getter) {
            if (typeof this._cache === 'undefined') {
              this._cache = {};
            }

            if (typeof this._cache[k] === 'undefined') {
              this._cache[k] = getter.call(this);
            }

            return this._cache[k];
          }
        }, {
          key: 'enable',
          value: function enable() {
            var _this3 = this;

            var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

            if (!(this.options.addTargetClasses === false)) {
              addClass(this.target, this.getClass('enabled'));
            }
            addClass(this.element, this.getClass('enabled'));
            this.enabled = true;

            this.scrollParents.forEach(function (parent) {
              if (parent !== _this3.target.ownerDocument) {
                parent.addEventListener('scroll', _this3.position);
              }
            });

            if (pos) {
              this.position();
            }
          }
        }, {
          key: 'disable',
          value: function disable() {
            var _this4 = this;

            removeClass(this.target, this.getClass('enabled'));
            removeClass(this.element, this.getClass('enabled'));
            this.enabled = false;

            if (typeof this.scrollParents !== 'undefined') {
              this.scrollParents.forEach(function (parent) {
                parent.removeEventListener('scroll', _this4.position);
              });
            }
          }
        }, {
          key: 'destroy',
          value: function destroy() {
            var _this5 = this;

            this.disable();

            tethers.forEach(function (tether, i) {
              if (tether === _this5) {
                tethers.splice(i, 1);
              }
            });

            if (tethers.length === 0) {
              removeUtilElements();
            }
          }
        }, {
          key: 'updateAttachClasses',
          value: function updateAttachClasses(elementAttach, targetAttach) {
            var _this6 = this;

            elementAttach = elementAttach || this.attachment;
            targetAttach = targetAttach || this.targetAttachment;
            var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];

            if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {
              this._addAttachClasses.splice(0, this._addAttachClasses.length);
            }

            if (typeof this._addAttachClasses === 'undefined') {
              this._addAttachClasses = [];
            }
            var add = this._addAttachClasses;

            if (elementAttach.top) {
              add.push(this.getClass('element-attached') + '-' + elementAttach.top);
            }
            if (elementAttach.left) {
              add.push(this.getClass('element-attached') + '-' + elementAttach.left);
            }
            if (targetAttach.top) {
              add.push(this.getClass('target-attached') + '-' + targetAttach.top);
            }
            if (targetAttach.left) {
              add.push(this.getClass('target-attached') + '-' + targetAttach.left);
            }

            var all = [];
            sides.forEach(function (side) {
              all.push(_this6.getClass('element-attached') + '-' + side);
              all.push(_this6.getClass('target-attached') + '-' + side);
            });

            defer(function () {
              if (!(typeof _this6._addAttachClasses !== 'undefined')) {
                return;
              }

              updateClasses(_this6.element, _this6._addAttachClasses, all);
              if (!(_this6.options.addTargetClasses === false)) {
                updateClasses(_this6.target, _this6._addAttachClasses, all);
              }

              delete _this6._addAttachClasses;
            });
          }
        }, {
          key: 'position',
          value: function position() {
            var _this7 = this;

            var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

            if (!this.enabled) {
              return;
            }

            this.clearCache();

            var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);

            this.updateAttachClasses(this.attachment, targetAttachment);

            var elementPos = this.cache('element-bounds', function () {
              return getBounds(_this7.element);
            });

            var width = elementPos.width;
            var height = elementPos.height;

            if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
              var _lastSize = this.lastSize;

              width = _lastSize.width;
              height = _lastSize.height;
            } else {
              this.lastSize = { width: width, height: height };
            }

            var targetPos = this.cache('target-bounds', function () {
              return _this7.getTargetBounds();
            });
            var targetSize = targetPos;

            var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });
            var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);

            var manualOffset = offsetToPx(this.offset, { width: width, height: height });
            var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);

            offset = addOffset(offset, manualOffset);
            targetOffset = addOffset(targetOffset, manualTargetOffset);

            var left = targetPos.left + targetOffset.left - offset.left;
            var top = targetPos.top + targetOffset.top - offset.top;

            for (var i = 0; i < TetherBase.modules.length; ++i) {
              var _module2 = TetherBase.modules[i];
              var ret = _module2.position.call(this, {
                left: left,
                top: top,
                targetAttachment: targetAttachment,
                targetPos: targetPos,
                elementPos: elementPos,
                offset: offset,
                targetOffset: targetOffset,
                manualOffset: manualOffset,
                manualTargetOffset: manualTargetOffset,
                scrollbarSize: scrollbarSize,
                attachment: this.attachment
              });

              if (ret === false) {
                return false;
              } else if (typeof ret === 'undefined' || (typeof ret === 'undefined' ? 'undefined' : (0, _typeof6.default)(ret)) !== 'object') {
                continue;
              } else {
                top = ret.top;
                left = ret.left;
              }
            }

            var next = {
              page: {
                top: top,
                left: left
              },

              viewport: {
                top: top - pageYOffset,
                bottom: pageYOffset - top - height + innerHeight,
                left: left - pageXOffset,
                right: pageXOffset - left - width + innerWidth
              }
            };

            var doc = this.target.ownerDocument;
            var win = doc.defaultView;

            var scrollbarSize = undefined;
            if (win.innerHeight > doc.documentElement.clientHeight) {
              scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
              next.viewport.bottom -= scrollbarSize.height;
            }

            if (win.innerWidth > doc.documentElement.clientWidth) {
              scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
              next.viewport.right -= scrollbarSize.width;
            }

            if (['', 'static'].indexOf(doc.body.style.position) === -1 || ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {
              next.page.bottom = doc.body.scrollHeight - top - height;
              next.page.right = doc.body.scrollWidth - left - width;
            }

            if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {
              (function () {
                var offsetParent = _this7.cache('target-offsetparent', function () {
                  return getOffsetParent(_this7.target);
                });
                var offsetPosition = _this7.cache('target-offsetparent-bounds', function () {
                  return getBounds(offsetParent);
                });
                var offsetParentStyle = getComputedStyle(offsetParent);
                var offsetParentSize = offsetPosition;

                var offsetBorder = {};
                ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {
                  offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);
                });

                offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;
                offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;

                if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {
                  if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {
                    var scrollTop = offsetParent.scrollTop;
                    var scrollLeft = offsetParent.scrollLeft;

                    next.offset = {
                      top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,
                      left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left
                    };
                  }
                }
              })();
            }

            this.move(next);

            this.history.unshift(next);

            if (this.history.length > 3) {
              this.history.pop();
            }

            if (flushChanges) {
              flush();
            }

            return true;
          }

        }, {
          key: 'move',
          value: function move(pos) {
            var _this8 = this;

            if (!(typeof this.element.parentNode !== 'undefined')) {
              return;
            }

            var same = {};

            for (var type in pos) {
              same[type] = {};

              for (var key in pos[type]) {
                var found = false;

                for (var i = 0; i < this.history.length; ++i) {
                  var point = this.history[i];
                  if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {
                    found = true;
                    break;
                  }
                }

                if (!found) {
                  same[type][key] = true;
                }
              }
            }

            var css = { top: '', left: '', right: '', bottom: '' };

            var transcribe = function transcribe(_same, _pos) {
              var hasOptimizations = typeof _this8.options.optimizations !== 'undefined';
              var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;
              if (gpu !== false) {
                var yPos = undefined,
                    xPos = undefined;
                if (_same.top) {
                  css.top = 0;
                  yPos = _pos.top;
                } else {
                  css.bottom = 0;
                  yPos = -_pos.bottom;
                }

                if (_same.left) {
                  css.left = 0;
                  xPos = _pos.left;
                } else {
                  css.right = 0;
                  xPos = -_pos.right;
                }

                if (window.matchMedia) {
                  var retina = window.matchMedia('only screen and (min-resolution: 1.3dppx)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3)').matches;
                  if (!retina) {
                    xPos = Math.round(xPos);
                    yPos = Math.round(yPos);
                  }
                }

                css[transformKey] = 'translateX(' + xPos + 'px) translateY(' + yPos + 'px)';

                if (transformKey !== 'msTransform') {
                  css[transformKey] += " translateZ(0)";
                }
              } else {
                if (_same.top) {
                  css.top = _pos.top + 'px';
                } else {
                  css.bottom = _pos.bottom + 'px';
                }

                if (_same.left) {
                  css.left = _pos.left + 'px';
                } else {
                  css.right = _pos.right + 'px';
                }
              }
            };

            var moved = false;
            if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
              css.position = 'absolute';
              transcribe(same.page, pos.page);
            } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
              css.position = 'fixed';
              transcribe(same.viewport, pos.viewport);
            } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {
              (function () {
                css.position = 'absolute';
                var offsetParent = _this8.cache('target-offsetparent', function () {
                  return getOffsetParent(_this8.target);
                });

                if (getOffsetParent(_this8.element) !== offsetParent) {
                  defer(function () {
                    _this8.element.parentNode.removeChild(_this8.element);
                    offsetParent.appendChild(_this8.element);
                  });
                }

                transcribe(same.offset, pos.offset);
                moved = true;
              })();
            } else {
              css.position = 'absolute';
              transcribe({ top: true, left: true }, pos.page);
            }

            if (!moved) {
              if (this.options.bodyElement) {
                this.options.bodyElement.appendChild(this.element);
              } else {
                var offsetParentIsBody = true;
                var currentNode = this.element.parentNode;
                while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY') {
                  if (getComputedStyle(currentNode).position !== 'static') {
                    offsetParentIsBody = false;
                    break;
                  }

                  currentNode = currentNode.parentNode;
                }

                if (!offsetParentIsBody) {
                  this.element.parentNode.removeChild(this.element);
                  this.element.ownerDocument.body.appendChild(this.element);
                }
              }
            }

            var writeCSS = {};
            var write = false;
            for (var key in css) {
              var val = css[key];
              var elVal = this.element.style[key];

              if (elVal !== val) {
                write = true;
                writeCSS[key] = val;
              }
            }

            if (write) {
              defer(function () {
                extend(_this8.element.style, writeCSS);
                _this8.trigger('repositioned');
              });
            }
          }
        }]);

        return TetherClass;
      }(Evented);

      TetherClass.modules = [];

      TetherBase.position = position;

      var Tether = extend(TetherClass, TetherBase);


      'use strict';

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i['return']) _i['return']();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if ((0, _isIterable3.default)(Object(arr))) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError('Invalid attempt to destructure non-iterable instance');
          }
        };
      }();

      var _TetherBase$Utils = TetherBase.Utils;
      var getBounds = _TetherBase$Utils.getBounds;
      var extend = _TetherBase$Utils.extend;
      var updateClasses = _TetherBase$Utils.updateClasses;
      var defer = _TetherBase$Utils.defer;

      var BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];

      function getBoundingRect(tether, to) {
        if (to === 'scrollParent') {
          to = tether.scrollParents[0];
        } else if (to === 'window') {
          to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];
        }

        if (to === document) {
          to = to.documentElement;
        }

        if (typeof to.nodeType !== 'undefined') {
          (function () {
            var node = to;
            var size = getBounds(to);
            var pos = size;
            var style = getComputedStyle(to);

            to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];

            if (node.ownerDocument !== document) {
              var win = node.ownerDocument.defaultView;
              to[0] += win.pageXOffset;
              to[1] += win.pageYOffset;
              to[2] += win.pageXOffset;
              to[3] += win.pageYOffset;
            }

            BOUNDS_FORMAT.forEach(function (side, i) {
              side = side[0].toUpperCase() + side.substr(1);
              if (side === 'Top' || side === 'Left') {
                to[i] += parseFloat(style['border' + side + 'Width']);
              } else {
                to[i] -= parseFloat(style['border' + side + 'Width']);
              }
            });
          })();
        }

        return to;
      }

      TetherBase.modules.push({
        position: function position(_ref) {
          var _this = this;

          var top = _ref.top;
          var left = _ref.left;
          var targetAttachment = _ref.targetAttachment;

          if (!this.options.constraints) {
            return true;
          }

          var _cache = this.cache('element-bounds', function () {
            return getBounds(_this.element);
          });

          var height = _cache.height;
          var width = _cache.width;

          if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
            var _lastSize = this.lastSize;

            width = _lastSize.width;
            height = _lastSize.height;
          }

          var targetSize = this.cache('target-bounds', function () {
            return _this.getTargetBounds();
          });

          var targetHeight = targetSize.height;
          var targetWidth = targetSize.width;

          var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];

          this.options.constraints.forEach(function (constraint) {
            var outOfBoundsClass = constraint.outOfBoundsClass;
            var pinnedClass = constraint.pinnedClass;

            if (outOfBoundsClass) {
              allClasses.push(outOfBoundsClass);
            }
            if (pinnedClass) {
              allClasses.push(pinnedClass);
            }
          });

          allClasses.forEach(function (cls) {
            ['left', 'top', 'right', 'bottom'].forEach(function (side) {
              allClasses.push(cls + '-' + side);
            });
          });

          var addClasses = [];

          var tAttachment = extend({}, targetAttachment);
          var eAttachment = extend({}, this.attachment);

          this.options.constraints.forEach(function (constraint) {
            var to = constraint.to;
            var attachment = constraint.attachment;
            var pin = constraint.pin;

            if (typeof attachment === 'undefined') {
              attachment = '';
            }

            var changeAttachX = undefined,
                changeAttachY = undefined;
            if (attachment.indexOf(' ') >= 0) {
              var _attachment$split = attachment.split(' ');

              var _attachment$split2 = _slicedToArray(_attachment$split, 2);

              changeAttachY = _attachment$split2[0];
              changeAttachX = _attachment$split2[1];
            } else {
              changeAttachX = changeAttachY = attachment;
            }

            var bounds = getBoundingRect(_this, to);

            if (changeAttachY === 'target' || changeAttachY === 'both') {
              if (top < bounds[1] && tAttachment.top === 'top') {
                top += targetHeight;
                tAttachment.top = 'bottom';
              }

              if (top + height > bounds[3] && tAttachment.top === 'bottom') {
                top -= targetHeight;
                tAttachment.top = 'top';
              }
            }

            if (changeAttachY === 'together') {
              if (tAttachment.top === 'top') {
                if (eAttachment.top === 'bottom' && top < bounds[1]) {
                  top += targetHeight;
                  tAttachment.top = 'bottom';

                  top += height;
                  eAttachment.top = 'top';
                } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {
                  top -= height - targetHeight;
                  tAttachment.top = 'bottom';

                  eAttachment.top = 'bottom';
                }
              }

              if (tAttachment.top === 'bottom') {
                if (eAttachment.top === 'top' && top + height > bounds[3]) {
                  top -= targetHeight;
                  tAttachment.top = 'top';

                  top -= height;
                  eAttachment.top = 'bottom';
                } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {
                  top += height - targetHeight;
                  tAttachment.top = 'top';

                  eAttachment.top = 'top';
                }
              }

              if (tAttachment.top === 'middle') {
                if (top + height > bounds[3] && eAttachment.top === 'top') {
                  top -= height;
                  eAttachment.top = 'bottom';
                } else if (top < bounds[1] && eAttachment.top === 'bottom') {
                  top += height;
                  eAttachment.top = 'top';
                }
              }
            }

            if (changeAttachX === 'target' || changeAttachX === 'both') {
              if (left < bounds[0] && tAttachment.left === 'left') {
                left += targetWidth;
                tAttachment.left = 'right';
              }

              if (left + width > bounds[2] && tAttachment.left === 'right') {
                left -= targetWidth;
                tAttachment.left = 'left';
              }
            }

            if (changeAttachX === 'together') {
              if (left < bounds[0] && tAttachment.left === 'left') {
                if (eAttachment.left === 'right') {
                  left += targetWidth;
                  tAttachment.left = 'right';

                  left += width;
                  eAttachment.left = 'left';
                } else if (eAttachment.left === 'left') {
                  left += targetWidth;
                  tAttachment.left = 'right';

                  left -= width;
                  eAttachment.left = 'right';
                }
              } else if (left + width > bounds[2] && tAttachment.left === 'right') {
                if (eAttachment.left === 'left') {
                  left -= targetWidth;
                  tAttachment.left = 'left';

                  left -= width;
                  eAttachment.left = 'right';
                } else if (eAttachment.left === 'right') {
                  left -= targetWidth;
                  tAttachment.left = 'left';

                  left += width;
                  eAttachment.left = 'left';
                }
              } else if (tAttachment.left === 'center') {
                if (left + width > bounds[2] && eAttachment.left === 'left') {
                  left -= width;
                  eAttachment.left = 'right';
                } else if (left < bounds[0] && eAttachment.left === 'right') {
                  left += width;
                  eAttachment.left = 'left';
                }
              }
            }

            if (changeAttachY === 'element' || changeAttachY === 'both') {
              if (top < bounds[1] && eAttachment.top === 'bottom') {
                top += height;
                eAttachment.top = 'top';
              }

              if (top + height > bounds[3] && eAttachment.top === 'top') {
                top -= height;
                eAttachment.top = 'bottom';
              }
            }

            if (changeAttachX === 'element' || changeAttachX === 'both') {
              if (left < bounds[0]) {
                if (eAttachment.left === 'right') {
                  left += width;
                  eAttachment.left = 'left';
                } else if (eAttachment.left === 'center') {
                  left += width / 2;
                  eAttachment.left = 'left';
                }
              }

              if (left + width > bounds[2]) {
                if (eAttachment.left === 'left') {
                  left -= width;
                  eAttachment.left = 'right';
                } else if (eAttachment.left === 'center') {
                  left -= width / 2;
                  eAttachment.left = 'right';
                }
              }
            }

            if (typeof pin === 'string') {
              pin = pin.split(',').map(function (p) {
                return p.trim();
              });
            } else if (pin === true) {
              pin = ['top', 'left', 'right', 'bottom'];
            }

            pin = pin || [];

            var pinned = [];
            var oob = [];

            if (top < bounds[1]) {
              if (pin.indexOf('top') >= 0) {
                top = bounds[1];
                pinned.push('top');
              } else {
                oob.push('top');
              }
            }

            if (top + height > bounds[3]) {
              if (pin.indexOf('bottom') >= 0) {
                top = bounds[3] - height;
                pinned.push('bottom');
              } else {
                oob.push('bottom');
              }
            }

            if (left < bounds[0]) {
              if (pin.indexOf('left') >= 0) {
                left = bounds[0];
                pinned.push('left');
              } else {
                oob.push('left');
              }
            }

            if (left + width > bounds[2]) {
              if (pin.indexOf('right') >= 0) {
                left = bounds[2] - width;
                pinned.push('right');
              } else {
                oob.push('right');
              }
            }

            if (pinned.length) {
              (function () {
                var pinnedClass = undefined;
                if (typeof _this.options.pinnedClass !== 'undefined') {
                  pinnedClass = _this.options.pinnedClass;
                } else {
                  pinnedClass = _this.getClass('pinned');
                }

                addClasses.push(pinnedClass);
                pinned.forEach(function (side) {
                  addClasses.push(pinnedClass + '-' + side);
                });
              })();
            }

            if (oob.length) {
              (function () {
                var oobClass = undefined;
                if (typeof _this.options.outOfBoundsClass !== 'undefined') {
                  oobClass = _this.options.outOfBoundsClass;
                } else {
                  oobClass = _this.getClass('out-of-bounds');
                }

                addClasses.push(oobClass);
                oob.forEach(function (side) {
                  addClasses.push(oobClass + '-' + side);
                });
              })();
            }

            if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {
              eAttachment.left = tAttachment.left = false;
            }
            if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {
              eAttachment.top = tAttachment.top = false;
            }

            if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {
              _this.updateAttachClasses(eAttachment, tAttachment);
              _this.trigger('update', {
                attachment: eAttachment,
                targetAttachment: tAttachment
              });
            }
          });

          defer(function () {
            if (!(_this.options.addTargetClasses === false)) {
              updateClasses(_this.target, addClasses, allClasses);
            }
            updateClasses(_this.element, addClasses, allClasses);
          });

          return { top: top, left: left };
        }
      });


      'use strict';

      var _TetherBase$Utils = TetherBase.Utils;
      var getBounds = _TetherBase$Utils.getBounds;
      var updateClasses = _TetherBase$Utils.updateClasses;
      var defer = _TetherBase$Utils.defer;

      TetherBase.modules.push({
        position: function position(_ref) {
          var _this = this;

          var top = _ref.top;
          var left = _ref.left;

          var _cache = this.cache('element-bounds', function () {
            return getBounds(_this.element);
          });

          var height = _cache.height;
          var width = _cache.width;

          var targetPos = this.getTargetBounds();

          var bottom = top + height;
          var right = left + width;

          var abutted = [];
          if (top <= targetPos.bottom && bottom >= targetPos.top) {
            ['left', 'right'].forEach(function (side) {
              var targetPosSide = targetPos[side];
              if (targetPosSide === left || targetPosSide === right) {
                abutted.push(side);
              }
            });
          }

          if (left <= targetPos.right && right >= targetPos.left) {
            ['top', 'bottom'].forEach(function (side) {
              var targetPosSide = targetPos[side];
              if (targetPosSide === top || targetPosSide === bottom) {
                abutted.push(side);
              }
            });
          }

          var allClasses = [];
          var addClasses = [];

          var sides = ['left', 'top', 'right', 'bottom'];
          allClasses.push(this.getClass('abutted'));
          sides.forEach(function (side) {
            allClasses.push(_this.getClass('abutted') + '-' + side);
          });

          if (abutted.length) {
            addClasses.push(this.getClass('abutted'));
          }

          abutted.forEach(function (side) {
            addClasses.push(_this.getClass('abutted') + '-' + side);
          });

          defer(function () {
            if (!(_this.options.addTargetClasses === false)) {
              updateClasses(_this.target, addClasses, allClasses);
            }
            updateClasses(_this.element, addClasses, allClasses);
          });

          return true;
        }
      });


      'use strict';

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i['return']) _i['return']();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if ((0, _isIterable3.default)(Object(arr))) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError('Invalid attempt to destructure non-iterable instance');
          }
        };
      }();

      TetherBase.modules.push({
        position: function position(_ref) {
          var top = _ref.top;
          var left = _ref.left;

          if (!this.options.shift) {
            return;
          }

          var shift = this.options.shift;
          if (typeof this.options.shift === 'function') {
            shift = this.options.shift.call(this, { top: top, left: left });
          }

          var shiftTop = undefined,
              shiftLeft = undefined;
          if (typeof shift === 'string') {
            shift = shift.split(' ');
            shift[1] = shift[1] || shift[0];

            var _shift = shift;

            var _shift2 = _slicedToArray(_shift, 2);

            shiftTop = _shift2[0];
            shiftLeft = _shift2[1];

            shiftTop = parseFloat(shiftTop, 10);
            shiftLeft = parseFloat(shiftLeft, 10);
          } else {
            shiftTop = shift.top;
            shiftLeft = shift.left;
          }

          top += shiftTop;
          left += shiftLeft;

          return { top: top, left: left };
        }
      });
      return Tether;
    });
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(195);

    var Component = __webpack_require__(0)(__webpack_require__(96), __webpack_require__(245), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiCloseButton.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiCloseButton.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-73775a2e", Component.options);
        } else {
          hotAPI.reload("data-v-73775a2e", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {

    "use strict";

    __webpack_require__(126);
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(165);

    var Component = __webpack_require__(0)(__webpack_require__(86), __webpack_require__(215), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiAlert.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiAlert.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-019a858a", Component.options);
        } else {
          hotAPI.reload("data-v-019a858a", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(166);

    var Component = __webpack_require__(0)(__webpack_require__(87), __webpack_require__(216), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiAutocomplete.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiAutocomplete.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-049f1d4e", Component.options);
        } else {
          hotAPI.reload("data-v-049f1d4e", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(186);

    var Component = __webpack_require__(0)(__webpack_require__(95), __webpack_require__(236), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiCheckboxGroup.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiCheckboxGroup.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-53e98d4a", Component.options);
        } else {
          hotAPI.reload("data-v-53e98d4a", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(201);

    var Component = __webpack_require__(0)(__webpack_require__(97), __webpack_require__(251), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiCollapsible.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiCollapsible.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-c1d568ae", Component.options);
        } else {
          hotAPI.reload("data-v-c1d568ae", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(203);

    var Component = __webpack_require__(0)(__webpack_require__(98), __webpack_require__(253), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiConfirm.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiConfirm.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-ed03da42", Component.options);
        } else {
          hotAPI.reload("data-v-ed03da42", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(196);

    var Component = __webpack_require__(0)(__webpack_require__(99), __webpack_require__(246), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiDatepicker.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiDatepicker.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-7cb5576d", Component.options);
        } else {
          hotAPI.reload("data-v-7cb5576d", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(187);

    var Component = __webpack_require__(0)(__webpack_require__(100), __webpack_require__(237), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiFab.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiFab.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-58451726", Component.options);
        } else {
          hotAPI.reload("data-v-58451726", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(197);

    var Component = __webpack_require__(0)(__webpack_require__(101), __webpack_require__(247), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiFileupload.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiFileupload.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-8595f0a4", Component.options);
        } else {
          hotAPI.reload("data-v-8595f0a4", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(194);

    var Component = __webpack_require__(0)(__webpack_require__(104), __webpack_require__(244), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiMenu.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiMenu.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-7360ec50", Component.options);
        } else {
          hotAPI.reload("data-v-7360ec50", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(176);

    var Component = __webpack_require__(0)(__webpack_require__(108), __webpack_require__(226), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiPreloader.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiPreloader.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-2e7f9056", Component.options);
        } else {
          hotAPI.reload("data-v-2e7f9056", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(167);

    var Component = __webpack_require__(0)(__webpack_require__(112), __webpack_require__(217), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiRadioGroup.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiRadioGroup.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-0eea8cf5", Component.options);
        } else {
          hotAPI.reload("data-v-0eea8cf5", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(169);

    var Component = __webpack_require__(0)(__webpack_require__(114), __webpack_require__(219), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiSelect.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiSelect.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-149e632d", Component.options);
        } else {
          hotAPI.reload("data-v-149e632d", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(199);

    var Component = __webpack_require__(0)(__webpack_require__(116), __webpack_require__(249), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiSlider.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiSlider.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-8d7da6dc", Component.options);
        } else {
          hotAPI.reload("data-v-8d7da6dc", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(173);

    var Component = __webpack_require__(0)(__webpack_require__(118), __webpack_require__(223), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiSnackbarContainer.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiSnackbarContainer.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-1daceb4a", Component.options);
        } else {
          hotAPI.reload("data-v-1daceb4a", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(190);

    var Component = __webpack_require__(0)(__webpack_require__(119), __webpack_require__(240), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiSwitch.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiSwitch.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-629f0965", Component.options);
        } else {
          hotAPI.reload("data-v-629f0965", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(181);

    var Component = __webpack_require__(0)(__webpack_require__(120), __webpack_require__(231), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiTab.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiTab.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-3cdc54b4", Component.options);
        } else {
          hotAPI.reload("data-v-3cdc54b4", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(189);

    var Component = __webpack_require__(0)(__webpack_require__(122), __webpack_require__(239), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiTabs.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiTabs.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-6259e2ef", Component.options);
        } else {
          hotAPI.reload("data-v-6259e2ef", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(180);

    var Component = __webpack_require__(0)(__webpack_require__(123), __webpack_require__(230), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiTextbox.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiTextbox.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-3805aac6", Component.options);
        } else {
          hotAPI.reload("data-v-3805aac6", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(182);

    var Component = __webpack_require__(0)(__webpack_require__(124), __webpack_require__(232), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiToolbar.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiToolbar.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-3d9c3bcc", Component.options);
        } else {
          hotAPI.reload("data-v-3d9c3bcc", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    (function (global, factory) {
      if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
        factory(exports, module);
      } else {
        var mod = {
          exports: {}
        };
        factory(mod.exports, mod);
        global.autosize = mod.exports;
      }
    })(this, function (exports, module) {
      'use strict';

      var map = typeof _map2.default === "function" ? new _map2.default() : function () {
        var keys = [];
        var values = [];

        return {
          has: function has(key) {
            return keys.indexOf(key) > -1;
          },
          get: function get(key) {
            return values[keys.indexOf(key)];
          },
          set: function set(key, value) {
            if (keys.indexOf(key) === -1) {
              keys.push(key);
              values.push(value);
            }
          },
          'delete': function _delete(key) {
            var index = keys.indexOf(key);
            if (index > -1) {
              keys.splice(index, 1);
              values.splice(index, 1);
            }
          }
        };
      }();

      var createEvent = function createEvent(name) {
        return new Event(name, { bubbles: true });
      };
      try {
        new Event('test');
      } catch (e) {
        createEvent = function createEvent(name) {
          var evt = document.createEvent('Event');
          evt.initEvent(name, true, false);
          return evt;
        };
      }

      function assign(ta) {
        if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

        var heightOffset = null;
        var clientWidth = ta.clientWidth;
        var cachedHeight = null;

        function init() {
          var style = window.getComputedStyle(ta, null);

          if (style.resize === 'vertical') {
            ta.style.resize = 'none';
          } else if (style.resize === 'both') {
            ta.style.resize = 'horizontal';
          }

          if (style.boxSizing === 'content-box') {
            heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
          } else {
            heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
          }

          if (isNaN(heightOffset)) {
            heightOffset = 0;
          }

          update();
        }

        function changeOverflow(value) {
          {
            var width = ta.style.width;
            ta.style.width = '0px';

            ta.offsetWidth;

            ta.style.width = width;
          }

          ta.style.overflowY = value;
        }

        function getParentOverflows(el) {
          var arr = [];

          while (el && el.parentNode && el.parentNode instanceof Element) {
            if (el.parentNode.scrollTop) {
              arr.push({
                node: el.parentNode,
                scrollTop: el.parentNode.scrollTop
              });
            }
            el = el.parentNode;
          }

          return arr;
        }

        function resize() {
          var originalHeight = ta.style.height;
          var overflows = getParentOverflows(ta);
          var docTop = document.documentElement && document.documentElement.scrollTop;

          ta.style.height = 'auto';

          var endHeight = ta.scrollHeight + heightOffset;

          if (ta.scrollHeight === 0) {
            ta.style.height = originalHeight;
            return;
          }

          ta.style.height = endHeight + 'px';

          clientWidth = ta.clientWidth;

          overflows.forEach(function (el) {
            el.node.scrollTop = el.scrollTop;
          });

          if (docTop) {
            document.documentElement.scrollTop = docTop;
          }
        }

        function update() {
          resize();

          var styleHeight = Math.round(parseFloat(ta.style.height));
          var computed = window.getComputedStyle(ta, null);
          var actualHeight = Math.round(parseFloat(computed.height));

          if (actualHeight !== styleHeight) {
            if (computed.overflowY !== 'visible') {
              changeOverflow('visible');
              resize();
              actualHeight = Math.round(parseFloat(window.getComputedStyle(ta, null).height));
            }
          } else {
            if (computed.overflowY !== 'hidden') {
              changeOverflow('hidden');
              resize();
              actualHeight = Math.round(parseFloat(window.getComputedStyle(ta, null).height));
            }
          }

          if (cachedHeight !== actualHeight) {
            cachedHeight = actualHeight;
            var evt = createEvent('autosize:resized');
            try {
              ta.dispatchEvent(evt);
            } catch (err) {}
          }
        }

        var pageResize = function pageResize() {
          if (ta.clientWidth !== clientWidth) {
            update();
          }
        };

        var destroy = function (style) {
          window.removeEventListener('resize', pageResize, false);
          ta.removeEventListener('input', update, false);
          ta.removeEventListener('keyup', update, false);
          ta.removeEventListener('autosize:destroy', destroy, false);
          ta.removeEventListener('autosize:update', update, false);

          (0, _keys2.default)(style).forEach(function (key) {
            ta.style[key] = style[key];
          });

          map['delete'](ta);
        }.bind(ta, {
          height: ta.style.height,
          resize: ta.style.resize,
          overflowY: ta.style.overflowY,
          overflowX: ta.style.overflowX,
          wordWrap: ta.style.wordWrap
        });

        ta.addEventListener('autosize:destroy', destroy, false);

        if ('onpropertychange' in ta && 'oninput' in ta) {
          ta.addEventListener('keyup', update, false);
        }

        window.addEventListener('resize', pageResize, false);
        ta.addEventListener('input', update, false);
        ta.addEventListener('autosize:update', update, false);
        ta.style.overflowX = 'hidden';
        ta.style.wordWrap = 'break-word';

        map.set(ta, {
          destroy: destroy,
          update: update
        });

        init();
      }

      function destroy(ta) {
        var methods = map.get(ta);
        if (methods) {
          methods.destroy();
        }
      }

      function update(ta) {
        var methods = map.get(ta);
        if (methods) {
          methods.update();
        }
      }

      var autosize = null;

      if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
        autosize = function autosize(el) {
          return el;
        };
        autosize.destroy = function (el) {
          return el;
        };
        autosize.update = function (el) {
          return el;
        };
      } else {
        autosize = function autosize(el, options) {
          if (el) {
            Array.prototype.forEach.call(el.length ? el : [el], function (x) {
              return assign(x, options);
            });
          }
          return el;
        };
        autosize.destroy = function (el) {
          if (el) {
            Array.prototype.forEach.call(el.length ? el : [el], destroy);
          }
          return el;
        };
        autosize.update = function (el) {
          if (el) {
            Array.prototype.forEach.call(el.length ? el : [el], update);
          }
          return el;
        };
      }

      module.exports = autosize;
    });
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiCloseButton = __webpack_require__(64);

    var _UiCloseButton2 = _interopRequireDefault(_UiCloseButton);

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-alert',

      props: {
        type: {
          type: String,
          default: 'info' },
        removeIcon: {
          type: Boolean,
          default: false
        },
        dismissible: {
          type: Boolean,
          default: true
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-alert--type-' + this.type];
        }
      },

      methods: {
        dismissAlert: function dismissAlert() {
          this.$emit('dismiss');
        }
      },

      components: {
        UiCloseButton: _UiCloseButton2.default,
        UiIcon: _UiIcon2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _autofocus = __webpack_require__(47);

    var _autofocus2 = _interopRequireDefault(_autofocus);

    var _UiAutocompleteSuggestion = __webpack_require__(208);

    var _UiAutocompleteSuggestion2 = _interopRequireDefault(_UiAutocompleteSuggestion);

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    var _fuzzysearch = __webpack_require__(61);

    var _fuzzysearch2 = _interopRequireDefault(_fuzzysearch);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-autocomplete',

      props: {
        name: String,
        placeholder: String,
        value: {
          type: [String, Number],
          required: true
        },
        icon: String,
        iconPosition: {
          type: String,
          default: 'left' },
        label: String,
        floatingLabel: {
          type: Boolean,
          default: false
        },
        help: String,
        error: String,
        readonly: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: 'simple' },
        suggestions: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        limit: {
          type: Number,
          default: 8
        },
        append: {
          type: Boolean,
          default: false
        },
        appendDelimiter: {
          type: String,
          default: ', '
        },
        minChars: {
          type: Number,
          default: 2
        },
        showOnUpDown: {
          type: Boolean,
          default: true
        },
        autofocus: {
          type: Boolean,
          default: false
        },
        filter: Function,
        highlightOnFirstMatch: {
          type: Boolean,
          default: true
        },
        cycleHighlight: {
          type: Boolean,
          default: true
        },
        keys: {
          type: Object,
          default: function _default() {
            return _config2.default.data.UiAutocomplete.keys;
          }
        },
        invalid: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          initialValue: this.value,
          isActive: false,
          isTouched: false,
          showDropdown: false,
          highlightedIndex: -1
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-autocomplete--type-' + this.type, 'ui-autocomplete--icon-position-' + this.iconPosition, { 'is-active': this.isActive }, { 'is-invalid': this.invalid }, { 'is-touched': this.isTouched }, { 'is-disabled': this.disabled }, { 'has-label': this.hasLabel }, { 'has-floating-label': this.hasFloatingLabel }];
        },
        labelClasses: function labelClasses() {
          return {
            'is-inline': this.hasFloatingLabel && this.isLabelInline,
            'is-floating': this.hasFloatingLabel && !this.isLabelInline
          };
        },
        hasLabel: function hasLabel() {
          return Boolean(this.label) || Boolean(this.$slots.default);
        },
        hasFloatingLabel: function hasFloatingLabel() {
          return this.hasLabel && this.floatingLabel;
        },
        isLabelInline: function isLabelInline() {
          return this.value.length === 0 && !this.isActive;
        },
        hasFeedback: function hasFeedback() {
          return Boolean(this.help) || Boolean(this.error);
        },
        showError: function showError() {
          return this.invalid && Boolean(this.error);
        },
        showHelp: function showHelp() {
          return !this.showError && Boolean(this.help);
        },
        matchingSuggestions: function matchingSuggestions() {
          var _this = this;

          return this.suggestions.filter(function (suggestion, index) {
            if (_this.filter) {
              return _this.filter(suggestion, _this.value);
            }

            return _this.defaultFilter(suggestion, index);
          }).slice(0, this.limit);
        }
      },

      watch: {
        value: function value() {
          if (this.isActive && this.value.length >= this.minChars) {
            this.openDropdown();
          }

          this.highlightedIndex = this.highlightOnFirstMatch ? 0 : -1;
        }
      },

      mounted: function mounted() {
        document.addEventListener('click', this.onExternalClick);
      },
      beforeDestroy: function beforeDestroy() {
        document.removeEventListener('click', this.onExternalClick);
      },

      methods: {
        defaultFilter: function defaultFilter(suggestion) {
          var text = suggestion[this.keys.label] || suggestion;
          var query = this.value;

          if (typeof query === 'string') {
            query = query.toLowerCase();
          }

          return (0, _fuzzysearch2.default)(query, text.toLowerCase());
        },
        selectSuggestion: function selectSuggestion(suggestion) {
          var _this2 = this;

          var value = void 0;

          if (this.append) {
            value += this.appendDelimiter + (suggestion[this.keys.value] || suggestion);
          } else {
            value = suggestion[this.keys.value] || suggestion;
          }

          this.updateValue(value);
          this.$emit('select', suggestion);

          this.$nextTick(function () {
            _this2.closeDropdown();
            _this2.$refs.input.focus();
          });
        },
        highlightSuggestion: function highlightSuggestion(index) {
          var firstIndex = 0;
          var lastIndex = this.$refs.suggestions.length - 1;

          if (index === -2) {
            index = lastIndex;
          } else if (index < firstIndex) {
            index = this.cycleHighlight ? lastIndex : index;
          } else if (index > lastIndex) {
            index = this.cycleHighlight ? firstIndex : -1;
          }

          this.highlightedIndex = index;

          if (this.showOnUpDown) {
            this.openDropdown();
          }

          if (index < firstIndex || index > lastIndex) {
            this.$emit('highlight-overflow', index);
          } else {
            this.$emit('highlight', this.$refs.suggestions[index].suggestion, index);
          }
        },
        selectHighlighted: function selectHighlighted(index, e) {
          if (this.showDropdown && this.$refs.suggestions.length > 0) {
            e.preventDefault();
            this.selectSuggestion(this.$refs.suggestions[index].suggestion);
          }
        },
        openDropdown: function openDropdown() {
          if (!this.showDropdown) {
            this.showDropdown = true;
            this.$emit('dropdown-open');
          }
        },
        closeDropdown: function closeDropdown() {
          var _this3 = this;

          if (this.showDropdown) {
            this.$nextTick(function () {
              _this3.showDropdown = false;
              _this3.highlightedIndex = -1;
              _this3.$emit('dropdown-close');
            });
          }
        },
        updateValue: function updateValue(value) {
          this.$emit('input', value);
        },
        onFocus: function onFocus(e) {
          this.isActive = true;
          this.$emit('focus', e);
        },
        onChange: function onChange(e) {
          this.$emit('change', this.value, e);
        },
        onBlur: function onBlur(e) {
          this.isActive = false;
          this.$emit('blur', e);

          if (!this.isTouched) {
            this.isTouched = true;
            this.$emit('touch');
          }
        },
        onExternalClick: function onExternalClick(e) {
          if (!this.$el.contains(e.target) && this.showDropdown) {
            this.closeDropdown();
          }
        },
        reset: function reset() {
          if (document.isActiveElement === this.$refs.input) {
            document.isActiveElement.blur();
          }

          this.$emit('input', this.initialValue);
          this.isTouched = false;
        }
      },

      components: {
        UiAutocompleteSuggestion: _UiAutocompleteSuggestion2.default,
        UiIcon: _UiIcon2.default
      },

      directives: {
        autofocus: _autofocus2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      name: 'ui-autocomplete-suggestion',

      props: {
        suggestion: {
          type: [String, Object],
          required: true
        },
        type: {
          type: String,
          default: 'simple' },
        highlighted: {
          type: Boolean,
          default: false
        },
        keys: {
          type: Object,
          default: function _default() {
            return {
              label: 'label',
              image: 'image'
            };
          }
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-autocomplete-suggestion--type-' + this.type, { 'is-highlighted': this.highlighted }];
        },
        imageStyle: function imageStyle() {
          return { 'background-image': 'url(' + this.suggestion[this.keys.image] + ')' };
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiPopover = __webpack_require__(15);

    var _UiPopover2 = _interopRequireDefault(_UiPopover);

    var _UiProgressCircular = __webpack_require__(16);

    var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);

    var _UiRippleInk = __webpack_require__(3);

    var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-button',

      props: {
        type: {
          type: String,
          default: 'primary' },
        buttonType: {
          type: String,
          default: 'submit' },
        color: {
          type: String,
          default: 'default' },
        size: {
          type: String,
          default: 'normal' },
        raised: {
          type: Boolean,
          default: false
        },
        icon: String,
        iconPosition: {
          type: String,
          default: 'left' },
        loading: {
          type: Boolean,
          default: false
        },
        hasDropdown: {
          type: Boolean,
          default: false
        },
        dropdownPosition: {
          type: String,
          default: 'bottom left'
        },
        openDropdownOn: {
          type: String,
          default: 'click' },
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          focusRing: {
            top: 0,
            left: 0,
            size: 0
          }
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-button--type-' + this.type, 'ui-button--color-' + this.color, 'ui-button--icon-position-' + this.iconPosition, 'ui-button--size-' + this.size, { 'is-raised': this.raised }, { 'is-loading': this.loading }, { 'is-disabled': this.disabled || this.loading }, { 'has-dropdown': this.hasDropdown }];
        },
        focusRingStyle: function focusRingStyle() {
          return {
            height: this.focusRing.size + 'px',
            width: this.focusRing.size + 'px',
            top: this.focusRing.top + 'px',
            left: this.focusRing.left + 'px'
          };
        },
        progressColor: function progressColor() {
          if (this.color === 'default' || this.type === 'secondary') {
            return 'black';
          }

          return 'white';
        }
      },

      methods: {
        onClick: function onClick(e) {
          this.$emit('click', e);
        },
        onFocus: function onFocus() {
          var bounds = {
            width: this.$el.clientWidth,
            height: this.$el.clientHeight
          };

          this.focusRing.size = bounds.width - 16;
          this.focusRing.top = -1 * (this.focusRing.size - bounds.height) / 2;
          this.focusRing.left = (bounds.width - this.focusRing.size) / 2;
        },
        onDropdownOpen: function onDropdownOpen() {
          this.$emit('dropdown-open');
        },
        onDropdownClose: function onDropdownClose() {
          this.$emit('dropdown-close');
        },
        openDropdown: function openDropdown() {
          if (this.$refs.dropdown) {
            this.$refs.dropdown.open();
          }
        },
        closeDropdown: function closeDropdown() {
          if (this.$refs.dropdown) {
            this.$refs.dropdown.close();
          }
        },
        toggleDropdown: function toggleDropdown() {
          if (this.$refs.dropdown) {
            this.$refs.dropdown.toggle();
          }
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiPopover: _UiPopover2.default,
        UiProgressCircular: _UiProgressCircular2.default,
        UiRippleInk: _UiRippleInk2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiCalendarControls = __webpack_require__(209);

    var _UiCalendarControls2 = _interopRequireDefault(_UiCalendarControls);

    var _UiCalendarMonth = __webpack_require__(210);

    var _UiCalendarMonth2 = _interopRequireDefault(_UiCalendarMonth);

    var _date = __webpack_require__(12);

    var _date2 = _interopRequireDefault(_date);

    var _elementScroll = __webpack_require__(48);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-calendar',

      props: {
        value: Date,
        minDate: Date,
        maxDate: Date,
        lang: {
          type: Object,
          default: function _default() {
            return _date2.default.defaultLang;
          }
        },
        yearRange: {
          type: Array,
          default: function _default() {
            var thisYear = new Date().getFullYear();

            return Array.apply(null, Array(200)).map(function (item, index) {
              return thisYear - 100 + index;
            });
          }
        },
        dateFilter: Function,
        color: {
          type: String,
          default: 'primary' },
        orientation: {
          type: String,
          default: 'portrait' }
      },

      data: function data() {
        return {
          today: new Date(),
          dateInView: this.getDateInRange(this.value, new Date()),
          showYearPicker: false
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-calendar--color-' + this.color, 'ui-calendar--orientation-' + this.orientation];
        },
        headerYear: function headerYear() {
          return this.value ? this.value.getFullYear() : this.today.getFullYear();
        },
        headerDay: function headerDay() {
          return this.value ? _date2.default.getDayAbbreviated(this.value, this.lang) : _date2.default.getDayAbbreviated(this.today, this.lang);
        },
        headerDate: function headerDate() {
          var date = this.value ? this.value : this.today;

          return _date2.default.getMonthAbbreviated(date, this.lang) + ' ' + _date2.default.getDayOfMonth(date, this.lang);
        }
      },

      watch: {
        value: function value() {
          if (this.value) {
            this.dateInView = _date2.default.clone(this.value);
          }
        },
        showYearPicker: function showYearPicker() {
          var _this = this;

          if (this.showYearPicker) {
            this.$nextTick(function () {
              var el = _this.$refs.years.querySelector('.is-selected') || _this.$refs.years.querySelector('.is-current-year');

              (0, _elementScroll.scrollIntoView)(el, { marginTop: 126 });
            });
          }
        }
      },

      methods: {
        selectYear: function selectYear(year) {
          var newDate = _date2.default.clone(this.dateInView);
          newDate.setFullYear(year);

          this.dateInView = this.getDateInRange(newDate);
          this.showYearPicker = false;
        },
        getDateInRange: function getDateInRange(date, fallback) {
          date = date || fallback;

          if (this.minDate && date.getTime() < this.minDate.getTime()) {
            return this.minDate;
          }

          if (this.maxDate && date.getTime() > this.maxDate.getTime()) {
            return this.maxDate;
          }

          return date;
        },
        getYearClasses: function getYearClasses(year) {
          return {
            'is-current-year': this.isYearCurrent(year),
            'is-selected': this.isYearSelected(year)
          };
        },
        isYearCurrent: function isYearCurrent(year) {
          return year === this.today.getFullYear();
        },
        isYearSelected: function isYearSelected(year) {
          return this.value && year === this.value.getFullYear();
        },
        isYearOutOfRange: function isYearOutOfRange(year) {
          if (this.minDate && year < this.minDate.getFullYear()) {
            return true;
          }

          if (this.maxDate && year > this.maxDate.getFullYear()) {
            return true;
          }

          return false;
        },
        onDateSelect: function onDateSelect(date) {
          this.$emit('input', date);
          this.$emit('date-select', date);
        },
        onGoToDate: function onGoToDate(date) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { isForward: true };

          this.$refs.month.goToDate(date, options);
        },
        onMonthChange: function onMonthChange(newDate) {
          this.dateInView = newDate;
          this.$emit('month-change', newDate);
        }
      },

      components: {
        UiCalendarControls: _UiCalendarControls2.default,
        UiCalendarMonth: _UiCalendarMonth2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiIconButton = __webpack_require__(25);

    var _UiIconButton2 = _interopRequireDefault(_UiIconButton);

    var _date = __webpack_require__(12);

    var _date2 = _interopRequireDefault(_date);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-calendar-controls',

      props: {
        lang: Object,
        dateInView: Date,
        minDate: Date,
        maxDate: Date
      },

      computed: {
        monthAndYear: function monthAndYear() {
          return _date2.default.getMonthFull(this.dateInView, this.lang) + ' ' + this.dateInView.getFullYear();
        },
        previousMonthDisabled: function previousMonthDisabled() {
          if (!this.minDate) {
            return false;
          }

          var lastDayOfPreviousMonth = _date2.default.clone(this.dateInView);

          lastDayOfPreviousMonth.setDate(0);

          return this.minDate.getTime() > lastDayOfPreviousMonth.getTime();
        },
        nextMonthDisabled: function nextMonthDisabled() {
          if (!this.maxDate) {
            return false;
          }

          var firstDayOfNextMonth = _date2.default.clone(this.dateInView);

          firstDayOfNextMonth.setMonth(this.dateInView.getMonth() + 1, 1);

          return this.maxDate.getTime() < firstDayOfNextMonth.getTime();
        }
      },

      methods: {
        goToPreviousMonth: function goToPreviousMonth() {
          var date = _date2.default.clone(this.dateInView);
          date.setMonth(date.getMonth() - 1);

          this.goToDate(date, { isForward: false });
        },
        goToNextMonth: function goToNextMonth() {
          var date = _date2.default.clone(this.dateInView);
          date.setMonth(date.getMonth() + 1);

          this.goToDate(date, { isForward: true });
        },
        goToDate: function goToDate(date) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { isForward: true };

          this.$emit('go-to-date', date, options);
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiIconButton: _UiIconButton2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _defineProperty2 = __webpack_require__(131);

    var _defineProperty3 = _interopRequireDefault(_defineProperty2);

    var _UiCalendarWeek = __webpack_require__(211);

    var _UiCalendarWeek2 = _interopRequireDefault(_UiCalendarWeek);

    var _date = __webpack_require__(12);

    var _date2 = _interopRequireDefault(_date);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-calendar-month',

      props: {
        lang: Object,
        dateFilter: Function,
        dateInView: Date,
        selected: Date,
        maxDate: Date,
        minDate: Date
      },

      data: function data() {
        return {
          dateOutOfView: _date2.default.clone(this.dateInView),
          isSliding: false,
          slideDirection: '',

          isIE: Boolean(window.MSInputMethodContext) && Boolean(document.documentMode),
          ieTimeout: null
        };
      },

      computed: {
        weekClasses: function weekClasses() {
          return [(0, _defineProperty3.default)({}, 'ui-calendar-month--slide-' + this.slideDirection, this.isSliding), { 'is-sliding': this.isSliding }];
        },
        currentWeekStartDates: function currentWeekStartDates() {
          return this.getWeekStartDates(this.dateInView);
        },
        otherWeekStartDates: function otherWeekStartDates() {
          return this.getWeekStartDates(this.dateOutOfView);
        }
      },

      methods: {
        getWeekStartDates: function getWeekStartDates(dateInWeek) {
          var date = _date2.default.clone(dateInWeek);

          date.setDate(1);
          date = _date2.default.moveToDayOfWeek(date, 0);

          var current = _date2.default.clone(date);
          current.setDate(current.getDate() + 7);

          var starts = [date];
          var month = current.getMonth();

          while (current.getMonth() === month) {
            starts.push(_date2.default.clone(current));
            current.setDate(current.getDate() + 7);
          }

          return starts;
        },
        goToDate: function goToDate(date) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { isForward: true };

          this.isSliding = true;
          this.slideDirection = options.isForward ? 'left' : 'right';
          this.dateOutOfView = _date2.default.clone(date);

          if (this.isIE) {
            this.ieTimeout = setTimeout(this.onTransitionEnd, 300);
          }
        },
        onDateSelect: function onDateSelect(date) {
          this.$emit('date-select', date);
        },
        onTransitionEnd: function onTransitionEnd() {
          if (this.ieTimeout) {
            clearTimeout(this.ieTimeout);
            this.ieTimeout = null;

            if (!this.isSliding) {
              return;
            }
          }

          this.isSliding = false;
          this.slideDirection = '';

          this.$emit('change', _date2.default.clone(this.dateOutOfView));
          this.$emit('transition-end');
        }
      },

      components: {
        UiCalendarWeek: _UiCalendarWeek2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _date = __webpack_require__(12);

    var _date2 = _interopRequireDefault(_date);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-calendar-week',

      props: {
        month: Number,
        weekStart: Date,
        minDate: Date,
        maxDate: Date,
        selected: Date,
        dateFilter: Function,
        visible: {
          type: Boolean,
          default: true
        }
      },

      data: function data() {
        return {
          today: new Date()
        };
      },

      computed: {
        dates: function dates() {
          return this.buildDays(this.weekStart);
        }
      },

      methods: {
        buildDays: function buildDays(weekStart) {
          var days = [_date2.default.clone(weekStart)];
          var day = _date2.default.clone(weekStart);

          for (var i = 1; i <= 6; i++) {
            day = _date2.default.clone(day);
            day.setDate(day.getDate() + 1);

            days.push(day);
          }

          return days;
        },
        getDateClasses: function getDateClasses(date) {
          return [{ 'is-today': _date2.default.isSameDay(date, this.today) }, { 'is-in-other-month': this.isDateInOtherMonth(date) }, { 'is-selected': this.selected && _date2.default.isSameDay(date, this.selected) }, { 'is-disabled': this.isDateDisabled(date) }];
        },
        selectDate: function selectDate(date) {
          if (this.isDateDisabled(date)) {
            return;
          }

          this.$emit('date-select', date);
        },
        getDayOfMonth: function getDayOfMonth(date) {
          return _date2.default.getDayOfMonth(date);
        },
        isDateInOtherMonth: function isDateInOtherMonth(date) {
          return this.month !== date.getMonth();
        },
        isDateDisabled: function isDateDisabled(date) {
          var isDisabled = this.minDate && _date2.default.isBefore(date, this.minDate) || this.maxDate && _date2.default.isAfter(date, this.maxDate);

          if (isDisabled) {
            return true;
          }

          return this.dateFilter ? !this.dateFilter(date) : false;
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _util = __webpack_require__(17);

    exports.default = {
      name: 'ui-checkbox',

      props: {
        name: String,
        label: String,
        value: {
          required: true
        },
        trueValue: {
          default: true
        },
        falseValue: {
          default: false
        },
        submittedValue: {
          type: String,
          default: 'on' },
        checked: {
          type: Boolean,
          default: false
        },
        boxPosition: {
          type: String,
          default: 'left' },
        color: {
          type: String,
          default: 'primary' },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          isActive: false,
          isChecked: (0, _util.looseEqual)(this.value, this.trueValue) || this.checked
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-checkbox--color-' + this.color, 'ui-checkbox--box-position-' + this.boxPosition, { 'is-checked': this.isChecked }, { 'is-active': this.isActive }, { 'is-disabled': this.disabled }];
        }
      },

      watch: {
        value: function value() {
          this.isChecked = (0, _util.looseEqual)(this.value, this.trueValue);
        }
      },

      created: function created() {
        this.$emit('input', this.isChecked ? this.trueValue : this.falseValue);
      },

      methods: {
        onClick: function onClick(e) {
          this.isChecked = e.target.checked;
          this.$emit('input', e.target.checked ? this.trueValue : this.falseValue);
        },
        onChange: function onChange(e) {
          this.$emit('change', this.isChecked ? this.trueValue : this.falseValue, e);
        },
        onFocus: function onFocus(e) {
          this.isActive = true;
          this.$emit('focus', e);
        },
        onBlur: function onBlur(e) {
          this.isActive = false;
          this.$emit('blur', e);
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _stringify = __webpack_require__(18);

    var _stringify2 = _interopRequireDefault(_stringify);

    var _UiCheckbox = __webpack_require__(43);

    var _UiCheckbox2 = _interopRequireDefault(_UiCheckbox);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    var _util = __webpack_require__(17);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-checkbox-group',

      props: {
        name: String,
        options: {
          type: Array,
          required: true
        },
        value: {
          type: Array,
          required: true
        },
        keys: {
          type: Object,
          default: function _default() {
            return _config2.default.data.UiCheckboxGroup.keys;
          }
        },
        label: String,
        color: {
          type: String,
          default: 'primary' },
        boxPosition: {
          type: String,
          default: 'left' },
        vertical: {
          type: Boolean,
          default: false
        },
        help: String,
        error: String,
        invalid: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          isActive: false,
          ignoreChange: false,
          checkboxValues: [],
          initialValue: JSON.parse((0, _stringify2.default)(this.value))
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-checkbox-group--color-' + this.color, 'ui-checkbox-group--box-position-' + this.boxPosition, { 'is-vertical': this.vertical }, { 'is-active': this.isActive }, { 'is-invalid': this.invalid }, { 'is-disabled': this.disabled }];
        },
        hasFeedback: function hasFeedback() {
          return Boolean(this.help) || this.showError;
        },
        showError: function showError() {
          return this.invalid && Boolean(this.error);
        },
        showHelp: function showHelp() {
          return !this.showError && Boolean(this.help);
        }
      },

      methods: {
        reset: function reset() {
          var _this = this;

          this.ignoreChange = true;
          this.options.forEach(function (option, index) {
            _this.checkboxValues[index] = _this.isOptionCheckedByDefault(option);
          });
          this.ignoreChange = false;

          this.$emit('input', this.initialValue.length > 0 ? [].concat(this.initialValue) : []);
        },
        isOptionCheckedByDefault: function isOptionCheckedByDefault(option) {
          return (0, _util.looseIndexOf)(this.initialValue, option[this.keys.value] || option) > -1;
        },
        onFocus: function onFocus(e) {
          this.isActive = true;
          this.$emit('focus', e);
        },
        onBlur: function onBlur(e) {
          this.isActive = false;
          this.$emit('blur', e);
        },
        onChange: function onChange(args, option) {
          if (this.ignoreChange) {
            return;
          }

          var checked = args[0];
          var e = args[1];

          var value = [];
          var optionValue = option[this.keys.value] || option;
          var i = (0, _util.looseIndexOf)(this.value, optionValue);

          if (checked && i < 0) {
            value = this.value.concat(optionValue);
          }

          if (!checked && i > -1) {
            value = this.value.slice(0, i).concat(this.value.slice(i + 1));
          }

          this.$emit('input', value);
          this.$emit('change', value, e);
        }
      },

      components: {
        UiCheckbox: _UiCheckbox2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiRippleInk = __webpack_require__(3);

    var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-close-button',

      props: {
        size: {
          type: String,
          default: 'normal' },
        color: {
          type: String,
          default: 'black' },
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-close-button--size-' + this.size, 'ui-close-button--color-' + this.color, { 'is-disabled': this.disabled || this.loading }];
        }
      },

      methods: {
        onClick: function onClick(e) {
          this.$emit('click', e);
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiRippleInk: _UiRippleInk2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiRippleInk = __webpack_require__(3);

    var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    var _RespondsToWindowResize = __webpack_require__(28);

    var _RespondsToWindowResize2 = _interopRequireDefault(_RespondsToWindowResize);

    var _uuid = __webpack_require__(49);

    var _uuid2 = _interopRequireDefault(_uuid);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-collapsible',

      props: {
        open: {
          type: Boolean,
          default: false
        },
        title: String,
        removeIcon: {
          type: Boolean,
          default: false
        },
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          height: 0,
          isReady: false,
          isOpen: this.open,
          useInitialHeight: false,
          id: _uuid2.default.short('ui-collapsible-')
        };
      },

      computed: {
        classes: function classes() {
          return [{ 'is-open': this.isOpen }, { 'is-disabled': this.disabled }];
        },
        calculatedHeight: function calculatedHeight() {
          return this.height === 0 || this.useInitialHeight ? 'initial' : this.height + 'px';
        }
      },

      watch: {
        open: function open() {
          if (this.isOpen !== this.open) {
            this.isOpen = this.open;
          }
        }
      },

      mounted: function mounted() {
        var _this = this;

        this.isReady = true;
        this.refreshHeight();

        this.$on('window-resize', function () {
          _this.refreshHeight();
        });
      },

      methods: {
        onEnter: function onEnter() {
          this.$emit('open');
          this.refreshHeight();
        },
        onLeave: function onLeave() {
          this.$emit('close');
        },
        toggleCollapsible: function toggleCollapsible() {
          if (this.disabled) {
            return;
          }

          this.isOpen = !this.isOpen;
        },
        refreshHeight: function refreshHeight() {
          var _this2 = this;

          var body = this.$refs.body;

          this.useInitialHeight = true;
          body.style.display = 'block';

          this.$nextTick(function () {
            _this2.height = body.scrollHeight + 1;
            _this2.useInitialHeight = false;

            if (!_this2.isOpen) {
              body.style.display = 'none';
            }
          });
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiRippleInk: _UiRippleInk2.default
      },

      mixins: [_RespondsToWindowResize2.default]
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiButton = __webpack_require__(14);

    var _UiButton2 = _interopRequireDefault(_UiButton);

    var _UiModal = __webpack_require__(26);

    var _UiModal2 = _interopRequireDefault(_UiModal);

    var _classlist = __webpack_require__(11);

    var _classlist2 = _interopRequireDefault(_classlist);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-confirm',

      props: {
        title: {
          type: String,
          default: 'UiConfirm'
        },
        type: {
          type: String,
          default: 'primary' },
        confirmButtonText: {
          type: String,
          default: 'OK'
        },
        confirmButtonIcon: String,
        denyButtonText: {
          type: String,
          default: 'Cancel'
        },
        denyButtonIcon: String,
        autofocus: {
          type: String,
          default: 'deny-button' },
        closeOnConfirm: {
          type: Boolean,
          default: true
        },
        dismissOn: String,
        transition: String,
        loading: {
          type: Boolean,
          default: false
        }
      },

      computed: {
        confirmButtonColor: function confirmButtonColor() {
          var typeToColor = {
            default: 'default',
            primary: 'primary',
            accent: 'accent',
            success: 'green',
            warning: 'orange',
            danger: 'red'
          };

          return typeToColor[this.type];
        }
      },

      methods: {
        open: function open() {
          this.$refs.modal.open();
        },
        close: function close() {
          this.$refs.modal.close();
        },
        confirm: function confirm() {
          this.$emit('confirm');

          if (this.closeOnConfirm) {
            this.$refs.modal.close();
          }
        },
        deny: function deny() {
          this.$refs.modal.close();
          this.$emit('deny');
        },
        onModalOpen: function onModalOpen() {
          var button = void 0;

          if (this.autofocus === 'confirm-button') {
            button = this.$refs.confirmButton.$el;
          } else if (this.autofocus === 'deny-button') {
            button = this.$refs.denyButton.$el;
          }

          if (button) {
            _classlist2.default.add(button, 'has-focus-ring');
            button.addEventListener('blur', this.removeAutoFocus);
            button.focus();
          }

          this.$emit('open');
        },
        onModalClose: function onModalClose() {
          this.$emit('close');
        },
        removeAutoFocus: function removeAutoFocus() {
          var button = void 0;

          if (this.autofocus === 'confirm-button') {
            button = this.$refs.confirmButton.$el;
          } else if (this.autofocus === 'deny-button') {
            button = this.$refs.denyButton.$el;
          }

          if (button) {
            _classlist2.default.remove(button, 'has-focus-ring');

            button.removeEventListener('blur', this.removeAutoFocus);
          }
        }
      },

      components: {
        UiButton: _UiButton2.default,
        UiModal: _UiModal2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _stringify = __webpack_require__(18);

    var _stringify2 = _interopRequireDefault(_stringify);

    var _UiButton = __webpack_require__(14);

    var _UiButton2 = _interopRequireDefault(_UiButton);

    var _UiCalendar = __webpack_require__(42);

    var _UiCalendar2 = _interopRequireDefault(_UiCalendar);

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiModal = __webpack_require__(26);

    var _UiModal2 = _interopRequireDefault(_UiModal);

    var _UiPopover = __webpack_require__(15);

    var _UiPopover2 = _interopRequireDefault(_UiPopover);

    var _date = __webpack_require__(12);

    var _date2 = _interopRequireDefault(_date);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-datepicker',

      props: {
        name: String,
        value: Date,
        minDate: Date,
        maxDate: Date,
        yearRange: Array,
        lang: {
          type: Object,
          default: function _default() {
            return _date2.default.defaultLang;
          }
        },
        customFormatter: Function,
        dateFilter: Function,
        color: {
          type: String,
          default: 'primary' },
        orientation: {
          type: String,
          default: 'portrait' },
        pickerType: {
          type: String,
          default: 'popover' },
        okButtonText: {
          type: String,
          default: 'OK'
        },
        cancelButtonText: {
          type: String,
          default: 'Cancel'
        },
        placeholder: String,
        icon: String,
        iconPosition: {
          type: String,
          default: 'left' },
        label: String,
        floatingLabel: {
          type: Boolean,
          default: false
        },
        invalid: {
          type: Boolean,
          default: false
        },
        help: String,
        error: String,
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          isActive: false,
          isTouched: false,
          valueAtModalOpen: null,
          initialValue: (0, _stringify2.default)(this.value)
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-datepicker--icon-position-' + this.iconPosition, 'ui-datepicker--orientation-' + this.orientation, { 'is-active': this.isActive }, { 'is-invalid': this.invalid }, { 'is-touched': this.isTouched }, { 'is-disabled': this.disabled }, { 'has-label': this.hasLabel }, { 'has-floating-label': this.hasFloatingLabel }];
        },
        labelClasses: function labelClasses() {
          return {
            'is-inline': this.hasFloatingLabel && this.isLabelInline,
            'is-floating': this.hasFloatingLabel && !this.isLabelInline
          };
        },
        hasLabel: function hasLabel() {
          return Boolean(this.label) || Boolean(this.$slots.default);
        },
        hasFloatingLabel: function hasFloatingLabel() {
          return this.hasLabel && this.floatingLabel;
        },
        isLabelInline: function isLabelInline() {
          return !this.value && !this.isActive;
        },
        hasFeedback: function hasFeedback() {
          return Boolean(this.help) || Boolean(this.error);
        },
        showError: function showError() {
          return this.invalid && Boolean(this.error);
        },
        showHelp: function showHelp() {
          return !this.showError && Boolean(this.help);
        },
        displayText: function displayText() {
          if (!this.value) {
            return '';
          }

          return this.customFormatter ? this.customFormatter(this.value, this.lang) : _date2.default.humanize(this.value, this.lang);
        },
        hasDisplayText: function hasDisplayText() {
          return Boolean(this.displayText.length);
        },
        submittedValue: function submittedValue() {
          return this.value ? this.value.getFullYear() + '-' + this.value.getMonth() + '-' + this.value.getDate() : '';
        },
        usesPopover: function usesPopover() {
          return this.pickerType === 'popover';
        },
        usesModal: function usesModal() {
          return this.pickerType === 'modal';
        }
      },

      mounted: function mounted() {
        document.addEventListener('click', this.onExternalClick);
      },
      beforeDestroy: function beforeDestroy() {
        document.removeEventListener('click', this.onExternalClick);
      },

      methods: {
        onDateSelect: function onDateSelect(date) {
          this.$emit('input', date);
          this.closePicker();
        },
        openPicker: function openPicker() {
          if (this.disabled) {
            return;
          }

          this.$refs[this.usesModal ? 'modal' : 'popover'].open();
        },
        closePicker: function closePicker() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { autoBlur: false };

          if (this.usesPopover) {
            this.$refs.popover.close();
          }

          if (options.autoBlur) {
            this.isActive = false;
          } else {
            this.$refs.label.focus();
          }
        },
        onClick: function onClick() {
          if (this.usesModal && !this.disabled) {
            this.$refs.modal.open();
          }
        },
        onFocus: function onFocus(e) {
          this.isActive = true;
          this.$emit('focus', e);
        },
        onBlur: function onBlur(e) {
          this.isActive = false;
          this.$emit('blur', e);

          if (this.usesPopover && this.$refs.popover.dropInstance.isOpened()) {
            this.closePicker({ autoBlur: true });
          }
        },
        onPickerOpen: function onPickerOpen() {
          if (this.usesModal) {
            this.valueAtModalOpen = this.value ? _date2.default.clone(this.value) : null;
          }

          this.isActive = true;
          this.$emit('open');
        },
        onPickerClose: function onPickerClose() {
          this.$emit('close');

          if (!this.isTouched) {
            this.isTouched = true;
            this.$emit('touch');
          }
        },
        onPickerCancel: function onPickerCancel() {
          this.$emit('input', this.valueAtModalOpen);
          this.$refs.modal.close();
        },
        onExternalClick: function onExternalClick(e) {
          if (this.disabled) {
            return;
          }

          var clickWasInternal = this.$el.contains(e.target) || this.$refs[this.usesPopover ? 'popover' : 'modal'].$el.contains(e.target);

          if (clickWasInternal) {
            return;
          }

          if (this.isActive) {
            this.isActive = false;
          }
        },
        reset: function reset() {
          this.$emit('input', JSON.parse(this.initialValue));
        },
        resetTouched: function resetTouched() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { touched: false };

          this.isTouched = options.touched;
        }
      },

      components: {
        UiButton: _UiButton2.default,
        UiCalendar: _UiCalendar2.default,
        UiIcon: _UiIcon2.default,
        UiModal: _UiModal2.default,
        UiPopover: _UiPopover2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiRippleInk = __webpack_require__(3);

    var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);

    var _UiTooltip = __webpack_require__(27);

    var _UiTooltip2 = _interopRequireDefault(_UiTooltip);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-fab',

      props: {
        size: {
          type: String,
          default: 'normal' },
        color: {
          type: String,
          default: 'default' },
        icon: String,
        ariaLabel: String,
        tooltip: String,
        openTooltipOn: String,
        tooltipPosition: String,
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-fab--color-' + this.color, 'ui-fab--size-' + this.size];
        }
      },

      methods: {
        onClick: function onClick(e) {
          this.$emit('click', e);
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiRippleInk: _UiRippleInk2.default,
        UiTooltip: _UiTooltip2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiRippleInk = __webpack_require__(3);

    var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-fileupload',

      props: {
        name: {
          type: String,
          required: true
        },
        label: String,
        accept: String,
        multiple: {
          type: Boolean,
          default: false
        },
        required: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: 'primary' },
        color: {
          type: String,
          default: 'default' },
        size: {
          type: String,
          default: 'normal' },
        raised: {
          type: Boolean,
          default: false
        },
        iconPosition: {
          type: String,
          default: 'left' },
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          isActive: false,
          hasSelection: false,
          hasMultiple: false,
          displayText: '',
          focusRing: {
            top: 0,
            left: 0,
            size: 0,
            initialized: false
          }
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-fileupload--type-' + this.type, 'ui-fileupload--color-' + this.color, 'ui-fileupload--icon-position-' + this.iconPosition, 'ui-fileupload--size-' + this.size, { 'is-active': this.isActive }, { 'is-multiple': this.hasMultiple }, { 'is-raised': this.raised }, { 'is-disabled': this.disabled }];
        },
        placeholder: function placeholder() {
          if (this.label) {
            return this.label;
          }

          return this.multiple ? 'Choose files' : 'Choose a file';
        },
        focusRingStyle: function focusRingStyle() {
          return {
            height: this.focusRing.size + 'px',
            width: this.focusRing.size + 'px',
            top: this.focusRing.top + 'px',
            left: this.focusRing.left + 'px'
          };
        }
      },

      methods: {
        onFocus: function onFocus(e) {
          this.isActive = true;
          this.$emit('focus', e);

          if (!this.focusRing.initialized) {
            this.initializeFocusRing();
          }
        },
        onBlur: function onBlur(e) {
          this.isActive = false;
          this.$emit('blur', e);
        },
        onChange: function onChange(e) {
          var _this = this;

          var displayText = void 0;
          var input = this.$refs.input;

          if (input.files && input.files.length > 1) {
            displayText = input.files.length + ' files selected';
          } else {
            displayText = e.target.value.split('\\').pop();
          }

          if (displayText) {
            this.hasSelection = true;
            this.displayText = displayText;
            this.hasMultiple = input.files.length > 1;

            this.$nextTick(function () {
              return _this.refreshFocusRing();
            });
          }

          this.$emit('change', input.files, e);
        },
        initializeFocusRing: function initializeFocusRing() {
          this.refreshFocusRing();
          this.focusRing.initialized = true;
        },
        refreshFocusRing: function refreshFocusRing() {
          var bounds = {
            width: this.$el.clientWidth,
            height: this.$el.clientHeight
          };

          this.focusRing.size = bounds.width - 16;
          this.focusRing.top = -1 * (this.focusRing.size - bounds.height) / 2;
          this.focusRing.left = (bounds.width - this.focusRing.size) / 2;
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiRippleInk: _UiRippleInk2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      name: 'ui-icon',

      props: {
        icon: String,
        iconSet: {
          type: String,
          default: 'material-icons'
        },
        ariaLabel: String,
        removeText: {
          type: Boolean,
          default: false
        },
        useSvg: {
          type: Boolean,
          default: false
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiPopover = __webpack_require__(15);

    var _UiPopover2 = _interopRequireDefault(_UiPopover);

    var _UiProgressCircular = __webpack_require__(16);

    var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);

    var _UiRippleInk = __webpack_require__(3);

    var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);

    var _UiTooltip = __webpack_require__(27);

    var _UiTooltip2 = _interopRequireDefault(_UiTooltip);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-icon-button',

      props: {
        type: {
          type: String,
          default: 'primary' },
        buttonType: {
          type: String,
          default: 'button'
        },
        color: {
          type: String,
          default: 'default' },
        size: {
          type: String,
          default: 'normal' },
        icon: String,
        ariaLabel: String,
        loading: {
          type: Boolean,
          default: false
        },
        hasDropdown: {
          type: Boolean,
          default: false
        },
        dropdownPosition: {
          type: String,
          default: 'bottom left'
        },
        openDropdownOn: {
          type: String,
          default: 'click' },
        tooltip: String,
        openTooltipOn: String,
        tooltipPosition: String,
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-icon-button--type-' + this.type, 'ui-icon-button--color-' + this.color, 'ui-icon-button--size-' + this.size, { 'is-loading': this.loading }, { 'is-disabled': this.disabled || this.loading }, { 'has-dropdown': this.hasDropdown }];
        },
        progressColor: function progressColor() {
          if (this.type === 'primary') {
            if (this.color === 'default' || this.color === 'black') {
              return 'black';
            }

            return 'white';
          }

          if (this.color === 'white') {
            return 'white';
          }

          return 'black';
        }
      },

      methods: {
        onClick: function onClick(e) {
          this.$emit('click', e);
        },
        onDropdownOpen: function onDropdownOpen() {
          this.$emit('dropdown-open');
        },
        onDropdownClose: function onDropdownClose() {
          this.$emit('dropdown-close');
        },
        openDropdown: function openDropdown() {
          if (this.$refs.dropdown) {
            this.$refs.dropdown.open();
          }
        },
        closeDropdown: function closeDropdown() {
          if (this.$refs.dropdown) {
            this.$refs.dropdown.close();
          }
        },
        toggleDropdown: function toggleDropdown() {
          if (this.$refs.dropdown) {
            this.$refs.dropdown.toggle();
          }
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiPopover: _UiPopover2.default,
        UiProgressCircular: _UiProgressCircular2.default,
        UiRippleInk: _UiRippleInk2.default,
        UiTooltip: _UiTooltip2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiMenuOption = __webpack_require__(212);

    var _UiMenuOption2 = _interopRequireDefault(_UiMenuOption);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-menu',

      props: {
        options: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        hasIcons: {
          type: Boolean,
          default: false
        },
        iconProps: Object,
        hasSecondaryText: {
          type: Boolean,
          default: false
        },
        containFocus: {
          type: Boolean,
          default: false
        },
        keys: {
          type: Object,
          default: function _default() {
            return _config2.default.data.UiMenu.keys;
          }
        },
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        },
        raised: {
          type: Boolean,
          default: false
        }
      },

      computed: {
        classes: function classes() {
          return {
            'is-raised': this.raised,
            'has-icons': this.hasIcons,
            'has-secondary-text': this.hasSecondaryText
          };
        }
      },

      methods: {
        selectOption: function selectOption(option) {
          if (option.disabled || option.type === 'divider') {
            return;
          }

          this.$emit('select', option);
          this.closeMenu();
        },
        closeMenu: function closeMenu() {
          this.$emit('close');
        },
        redirectFocus: function redirectFocus(e) {
          e.stopPropagation();
          this.$el.querySelector('.ui-menu-option').focus();
        }
      },

      components: {
        UiMenuOption: _UiMenuOption2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiRippleInk = __webpack_require__(3);

    var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-menu-option',

      props: {
        type: String,
        label: String,
        icon: String,
        iconProps: {
          type: Object,
          default: function _default() {
            return {};
          }
        },
        secondaryText: String,
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      computed: {
        classes: function classes() {
          return {
            'is-divider': this.isDivider,
            'is-disabled': this.disabled
          };
        },
        isDivider: function isDivider() {
          return this.type === 'divider';
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiRippleInk: _UiRippleInk2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiCloseButton = __webpack_require__(64);

    var _UiCloseButton2 = _interopRequireDefault(_UiCloseButton);

    var _classlist = __webpack_require__(11);

    var _classlist2 = _interopRequireDefault(_classlist);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-modal',

      props: {
        title: {
          type: String,
          default: 'UiModal title'
        },
        size: {
          type: String,
          default: 'normal' },
        role: {
          type: String,
          default: 'dialog' },
        transition: {
          type: String,
          default: 'scale' },
        removeHeader: {
          type: Boolean,
          default: false
        },
        removeCloseButton: {
          type: Boolean,
          default: false
        },
        preventShift: {
          type: Boolean,
          default: false
        },
        dismissible: {
          type: Boolean,
          default: true
        },
        dismissOn: {
          type: String,
          default: 'backdrop esc close-button'
        }
      },

      data: function data() {
        return {
          isOpen: false,
          lastfocusedElement: null
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-modal--size-' + this.size, { 'has-footer': this.hasFooter }, { 'is-open': this.isOpen }];
        },
        hasFooter: function hasFooter() {
          return Boolean(this.$slots.footer);
        },
        toggleTransition: function toggleTransition() {
          return 'ui-modal--transition-' + this.transition;
        },
        dismissOnBackdrop: function dismissOnBackdrop() {
          return this.dismissOn.indexOf('backdrop') > -1;
        },
        dismissOnCloseButton: function dismissOnCloseButton() {
          return this.dismissOn.indexOf('close-button') > -1;
        },
        dismissOnEsc: function dismissOnEsc() {
          return this.dismissOn.indexOf('esc') > -1;
        }
      },

      watch: {
        isOpen: function isOpen() {
          var _this = this;

          this.$nextTick(function () {
            _this[_this.isOpen ? 'onOpen' : 'onClose']();
          });
        }
      },

      beforeDestroy: function beforeDestroy() {
        if (this.isOpen) {
          this.teardownModal();
        }
      },

      methods: {
        open: function open() {
          this.isOpen = true;
        },
        close: function close() {
          this.isOpen = false;
        },
        closeModal: function closeModal(e) {
          if (!this.dismissible) {
            return;
          }

          if (e.currentTarget === this.$refs.backdrop && e.target !== e.currentTarget) {
            return;
          }

          this.isOpen = false;
        },
        onOpen: function onOpen() {
          this.lastfocusedElement = document.activeElement;
          this.$refs.container.focus();

          _classlist2.default.add(document.body, 'ui-modal--is-open');
          document.addEventListener('focus', this.restrictFocus, true);

          this.$emit('open');
        },
        onClose: function onClose() {
          this.teardownModal();
          this.$emit('close');
        },
        redirectFocus: function redirectFocus() {
          this.$refs.container.focus();
        },
        restrictFocus: function restrictFocus(e) {
          if (!this.$refs.container.contains(e.target)) {
            e.stopPropagation();
            this.$refs.container.focus();
          }
        },
        teardownModal: function teardownModal() {
          document.removeEventListener('focus', this.restrictFocus, true);

          if (this.lastfocusedElement) {
            this.lastfocusedElement.focus();
          }
        },
        onEnter: function onEnter() {
          this.$emit('reveal');
        },
        onLeave: function onLeave() {
          this.$emit('hide');

          _classlist2.default.remove(document.body, 'ui-modal--is-open');
        }
      },

      components: {
        UiCloseButton: _UiCloseButton2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _classlist = __webpack_require__(11);

    var _classlist2 = _interopRequireDefault(_classlist);

    var _tetherDrop = __webpack_require__(62);

    var _tetherDrop2 = _interopRequireDefault(_tetherDrop);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-popover',

      props: {
        trigger: {
          type: String,
          required: true
        },
        dropdownPosition: {
          type: String,
          default: 'bottom left'
        },
        openOn: {
          type: String,
          default: 'click' },
        containFocus: {
          type: Boolean,
          default: false
        },
        focusRedirector: Function,
        raised: {
          type: Boolean,
          default: true
        }
      },

      data: function data() {
        return {
          dropInstance: null,
          lastfocusedElement: null
        };
      },

      computed: {
        triggerEl: function triggerEl() {
          return this.$parent.$refs[this.trigger];
        }
      },

      mounted: function mounted() {
        if (this.triggerEl) {
          this.initializeDropdown();
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (this.dropInstance) {
          this.dropInstance.destroy();
        }
      },

      methods: {
        initializeDropdown: function initializeDropdown() {
          this.dropInstance = new _tetherDrop2.default({
            target: this.triggerEl,
            content: this.$el,
            position: this.dropdownPosition,
            constrainToWindow: true,
            openOn: this.openOn
          });

          if (this.dropdownPosition !== 'bottom left') {
            this.dropInstance.open();
            this.dropInstance.close();
            this.dropInstance.open();
            this.dropInstance.close();
          }

          this.dropInstance.on('open', this.onOpen);
          this.dropInstance.on('close', this.onClose);
        },
        openDropdown: function openDropdown() {
          if (this.dropInstance) {
            this.dropInstance.open();
          }
        },
        closeDropdown: function closeDropdown() {
          if (this.dropInstance) {
            this.dropInstance.close();
          }
        },
        toggleDropdown: function toggleDropdown(e) {
          if (this.dropInstance) {
            this.dropInstance.toggle(e);
          }
        },
        positionDrop: function positionDrop() {
          var drop = this.dropInstance;
          var windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;

          var width = drop.drop.getBoundingClientRect().width;
          var left = drop.target.getBoundingClientRect().left;
          var availableSpace = windowWidth - left;

          if (width > availableSpace) {
            var direction = width > availableSpace ? 'right' : 'left';

            drop.tether.attachment.left = direction;
            drop.tether.targetAttachment.left = direction;

            drop.position();
          }
        },
        onOpen: function onOpen() {
          this.positionDrop();
          _classlist2.default.add(this.triggerEl, 'has-dropdown-open');

          this.lastfocusedElement = document.activeElement;
          this.$el.focus();

          this.$emit('open');
        },
        onClose: function onClose() {
          _classlist2.default.remove(this.triggerEl, 'has-dropdown-open');

          if (this.lastfocusedElement) {
            this.lastfocusedElement.focus();
          }

          this.$emit('close');
        },
        restrictFocus: function restrictFocus(e) {
          if (!this.containFocus) {
            this.closeDropdown();
            return;
          }

          e.stopPropagation();

          if (this.focusRedirector) {
            this.focusRedirector(e);
          } else {
            this.$el.focus();
          }
        },
        open: function open() {
          this.openDropdown();
        },
        close: function close() {
          this.closeDropdown();
        },
        toggle: function toggle() {
          this.toggleDropdown();
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      name: 'ui-preloader',

      props: {
        show: {
          type: Boolean,
          required: true
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      name: 'ui-progress-circular',

      props: {
        type: {
          type: String,
          default: 'indeterminate' },
        color: {
          type: String,
          default: 'primary' },
        progress: {
          type: Number,
          default: 0
        },
        size: {
          type: Number,
          default: 32
        },
        stroke: Number,
        autoStroke: {
          type: Boolean,
          default: true
        },
        disableTransition: {
          type: Boolean,
          default: false
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-progress-circular--color-' + this.color, 'ui-progress-circular--type-' + this.type];
        },
        strokeDashArray: function strokeDashArray() {
          var circumference = 2 * Math.PI * this.radius;

          return Math.round(circumference * 1000) / 1000;
        },
        strokeDashOffset: function strokeDashOffset() {
          var progress = this.moderateProgress(this.progress);
          var circumference = 2 * Math.PI * this.radius;

          return (100 - progress) / 100 * circumference;
        },
        radius: function radius() {
          var stroke = this.stroke ? this.stroke : 4;
          return (this.size - stroke) / 2;
        },
        calculatedStroke: function calculatedStroke() {
          if (this.stroke) {
            return this.stroke;
          }

          if (this.autoStroke) {
            return parseInt(this.size / 8, 10);
          }

          return 4;
        }
      },

      methods: {
        moderateProgress: function moderateProgress(progress) {
          if (isNaN(progress) || progress < 0) {
            return 0;
          }

          if (progress > 100) {
            return 100;
          }

          return progress;
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      name: 'ui-progress-linear',

      props: {
        type: {
          type: String,
          default: 'indeterminate' },
        color: {
          type: String,
          default: 'primary' },
        progress: {
          type: Number,
          default: 0
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-progress-linear--color-' + this.color, 'ui-progress-linear--type-' + this.type];
        },
        moderatedProgress: function moderatedProgress() {
          if (this.progress < 0) {
            return 0;
          }

          if (this.progress > 100) {
            return 100;
          }

          return this.progress;
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      name: 'ui-radio',

      props: {
        name: String,
        label: String,
        value: {
          type: [Number, String],
          required: true
        },
        trueValue: {
          type: [Number, String],
          required: true
        },
        checked: {
          type: Boolean,
          default: false
        },
        color: {
          type: String,
          default: 'primary' },
        buttonPosition: {
          type: String,
          default: 'left' },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          isActive: false
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-radio--color-' + this.color, 'ui-radio--button-position-' + this.buttonPosition, { 'is-active': this.isActive }, { 'is-checked': this.isChecked }, { 'is-disabled': this.disabled }];
        },
        isChecked: function isChecked() {
          return String(this.value).length > 0 && this.value == this.trueValue;
        }
      },

      created: function created() {
        if (this.checked) {
          this.$emit('input', this.trueValue);
        }
      },

      methods: {
        toggleCheck: function toggleCheck() {
          if (!this.disabled) {
            this.$emit('input', this.trueValue);
          }
        },
        onFocus: function onFocus(e) {
          this.isActive = true;
          this.$emit('focus', e);
        },
        onBlur: function onBlur(e) {
          this.isActive = false;
          this.$emit('blur', e);
        },
        onChange: function onChange(e) {
          this.$emit('change', this.isChecked, e);
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiRadio = __webpack_require__(45);

    var _UiRadio2 = _interopRequireDefault(_UiRadio);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-radio-group',

      props: {
        name: {
          type: String,
          required: true
        },
        label: String,
        options: {
          type: Array,
          required: true
        },
        value: {
          type: [Number, String],
          required: true
        },
        keys: {
          type: Object,
          default: function _default() {
            return _config2.default.data.UiRadioGroup.keys;
          }
        },
        color: {
          type: String,
          default: 'primary' },
        buttonPosition: {
          type: String,
          default: 'left' },
        vertical: {
          type: Boolean,
          default: false
        },
        help: String,
        error: String,
        invalid: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          isActive: false,
          initialValue: this.value,
          selectedOptionValue: this.value
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-radio-group--color-' + this.color, 'ui-radio-group--button-position-' + this.buttonPosition, { 'is-vertical': this.vertical }, { 'is-active': this.isActive }, { 'is-invalid': this.invalid }, { 'is-disabled': this.disabled }];
        },
        hasFeedback: function hasFeedback() {
          return Boolean(this.help) || this.showError;
        },
        showError: function showError() {
          return this.invalid && Boolean(this.error);
        },
        showHelp: function showHelp() {
          return !this.showError && Boolean(this.help);
        }
      },

      watch: {
        selectedOptionValue: function selectedOptionValue() {
          this.$emit('input', this.selectedOptionValue);
          this.$emit('change', this.selectedOptionValue);
        },
        value: function value() {
          this.selectedOptionValue = this.value;
        }
      },

      methods: {
        reset: function reset() {
          this.$emit('input', this.initialValue);
        },
        isOptionCheckedByDefault: function isOptionCheckedByDefault(option) {
          return this.initialValue == option[this.keys.value] || this.initialValue == option || option[this.keys.checked];
        },
        onFocus: function onFocus(e) {
          this.isActive = true;
          this.$emit('focus', e);
        },
        onBlur: function onBlur(e) {
          this.isActive = false;
          this.$emit('blur', e);
        }
      },

      components: {
        UiRadio: _UiRadio2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _classlist = __webpack_require__(11);

    var _classlist2 = _interopRequireDefault(_classlist);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    var startRipple = function startRipple(eventType, event) {
      var holder = event.currentTarget || event.target;

      if (holder && !_classlist2.default.has(holder, 'ui-ripple-ink')) {
        holder = holder.querySelector('.ui-ripple-ink');
      }

      if (!holder) {
        return;
      }

      var prev = holder.getAttribute('data-ui-event');

      if (prev && prev !== eventType) {
        return;
      }

      holder.setAttribute('data-ui-event', eventType);

      var rect = holder.getBoundingClientRect();
      var x = event.offsetX;
      var y = void 0;

      if (x === undefined) {
        x = event.clientX - rect.left;
        y = event.clientY - rect.top;
      } else {
        y = event.offsetY;
      }

      var ripple = document.createElement('div');
      var max = void 0;

      if (rect.width === rect.height) {
        max = rect.width * 1.412;
      } else {
        max = Math.sqrt(rect.width * rect.width + rect.height * rect.height);
      }

      var dim = max * 2 + 'px';

      ripple.style.width = dim;
      ripple.style.height = dim;
      ripple.style.marginLeft = -max + x + 'px';
      ripple.style.marginTop = -max + y + 'px';

      ripple.className = 'ui-ripple-ink__ink';
      holder.appendChild(ripple);

      setTimeout(function () {
        _classlist2.default.add(ripple, 'is-held');
      }, 0);

      var releaseEvent = eventType === 'mousedown' ? 'mouseup' : 'touchend';

      var handleRelease = function handleRelease() {
        document.removeEventListener(releaseEvent, handleRelease);

        _classlist2.default.add(ripple, 'is-done');

        setTimeout(function () {
          holder.removeChild(ripple);

          if (holder.children.length === 0) {
            holder.removeAttribute('data-ui-event');
          }
        }, 650);
      };

      document.addEventListener(releaseEvent, handleRelease);
    };

    var handleMouseDown = function handleMouseDown(e) {
      if (e.button === 0) {
        startRipple(e.type, e);
      }
    };

    var handleTouchStart = function handleTouchStart(e) {
      if (e.changedTouches) {
        for (var i = 0; i < e.changedTouches.length; ++i) {
          startRipple(e.type, e.changedTouches[i]);
        }
      }
    };

    exports.default = {
      name: 'ui-ripple-ink',

      props: {
        trigger: {
          type: String,
          required: true
        }
      },

      watch: {
        trigger: function trigger() {
          this.initialize();
        }
      },

      mounted: function mounted() {
        var _this = this;

        this.$nextTick(function () {
          _this.initialize();
        });
      },
      beforeDestroy: function beforeDestroy() {
        var triggerEl = this.trigger ? this.$parent.$refs[this.trigger] : null;

        if (!triggerEl) {
          return;
        }

        triggerEl.removeEventListener('mousedown', handleMouseDown);
        triggerEl.removeEventListener('touchstart', handleTouchStart);
      },

      methods: {
        initialize: function initialize() {
          var triggerEl = this.trigger ? this.$parent.$refs[this.trigger] : null;

          if (!triggerEl) {
            return;
          }

          triggerEl.addEventListener('touchstart', handleTouchStart);
          triggerEl.addEventListener('mousedown', handleMouseDown);
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _stringify = __webpack_require__(18);

    var _stringify2 = _interopRequireDefault(_stringify);

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiProgressCircular = __webpack_require__(16);

    var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);

    var _UiSelectOption = __webpack_require__(213);

    var _UiSelectOption2 = _interopRequireDefault(_UiSelectOption);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    var _fuzzysearch = __webpack_require__(61);

    var _fuzzysearch2 = _interopRequireDefault(_fuzzysearch);

    var _util = __webpack_require__(17);

    var _elementScroll = __webpack_require__(48);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-select',

      props: {
        name: String,
        value: {
          type: [String, Number, Object, Array],
          required: true
        },
        options: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        placeholder: String,
        icon: String,
        iconPosition: {
          type: String,
          default: 'left' },
        label: String,
        floatingLabel: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: 'basic' },
        multiple: {
          type: Boolean,
          default: false
        },
        multipleDelimiter: {
          type: String,
          default: ', '
        },
        hasSearch: {
          type: Boolean,
          default: false
        },
        searchPlaceholder: {
          type: String,
          default: 'Search'
        },
        filter: Function,
        disableFilter: {
          type: Boolean,
          default: false
        },
        loading: {
          type: Boolean,
          default: false
        },
        noResults: {
          type: Boolean,
          default: false
        },
        keys: {
          type: Object,
          default: function _default() {
            return _config2.default.data.UiSelect.keys;
          }
        },
        invalid: {
          type: Boolean,
          default: false
        },
        help: String,
        error: String,
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          query: '',
          isActive: false,
          isTouched: false,
          selectedIndex: -1,
          highlightedIndex: -1,
          showDropdown: false,
          initialValue: (0, _stringify2.default)(this.value)
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-select--type-' + this.type, 'ui-select--icon-position-' + this.iconPosition, { 'is-active': this.isActive }, { 'is-invalid': this.invalid }, { 'is-touched': this.isTouched }, { 'is-disabled': this.disabled }, { 'is-multiple': this.multiple }, { 'has-label': this.hasLabel }, { 'has-floating-label': this.hasFloatingLabel }];
        },
        labelClasses: function labelClasses() {
          return {
            'is-inline': this.hasFloatingLabel && this.isLabelInline,
            'is-floating': this.hasFloatingLabel && !this.isLabelInline
          };
        },
        hasLabel: function hasLabel() {
          return Boolean(this.label) || Boolean(this.$slots.default);
        },
        hasFloatingLabel: function hasFloatingLabel() {
          return this.hasLabel && this.floatingLabel;
        },
        isLabelInline: function isLabelInline() {
          return this.value.length === 0 && !this.isActive;
        },
        hasFeedback: function hasFeedback() {
          return Boolean(this.help) || Boolean(this.error);
        },
        showError: function showError() {
          return this.invalid && Boolean(this.error);
        },
        showHelp: function showHelp() {
          return !this.showError && Boolean(this.help);
        },
        filteredOptions: function filteredOptions() {
          var _this = this;

          if (this.disableFilter) {
            return this.options;
          }

          return this.options.filter(function (option, index) {
            if (_this.filter) {
              return _this.filter(option, _this.query);
            }

            return _this.defaultFilter(option, index);
          });
        },
        displayText: function displayText() {
          var _this2 = this;

          if (this.multiple) {
            if (this.value.length > 0) {
              return this.value.map(function (value) {
                return value[_this2.keys.label] || value;
              }).join(this.multipleDelimiter);
            }

            return '';
          }

          return this.value ? this.value[this.keys.label] || this.value : '';
        },
        hasDisplayText: function hasDisplayText() {
          return Boolean(this.displayText.length);
        },
        hasNoResults: function hasNoResults() {
          if (this.loading || this.query.length === 0) {
            return false;
          }

          return this.disableFilter ? this.noResults : this.filteredOptions.length === 0;
        },
        submittedValue: function submittedValue() {
          var _this3 = this;

          if (!this.name || !this.value) {
            return;
          }

          if (Array.isArray(this.value)) {
            return this.value.map(function (option) {
              return option[_this3.keys.value] || option;
            }).join(',');
          }

          return this.value[this.keys.value] || this.value;
        }
      },

      watch: {
        filteredOptions: function filteredOptions() {
          this.highlightedIndex = 0;
          (0, _elementScroll.resetScroll)(this.$refs.optionsList);
        },
        showDropdown: function showDropdown() {
          if (this.showDropdown) {
            this.onOpen();
            this.$emit('dropdown-open');
          } else {
            this.onClose();
            this.$emit('dropdown-close');
          }
        },
        query: function query() {
          this.$emit('query-change', this.query);
        }
      },

      created: function created() {
        if (!this.value || this.value === '') {
          this.setValue(null);
        }
      },
      mounted: function mounted() {
        document.addEventListener('click', this.onExternalClick);
      },
      beforeDestroy: function beforeDestroy() {
        document.removeEventListener('click', this.onExternalClick);
      },

      methods: {
        setValue: function setValue(value) {
          value = value ? value : this.multiple ? [] : '';

          this.$emit('input', value);
          this.$emit('change', value);
        },
        highlightOption: function highlightOption(index) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { autoScroll: true };

          if (this.highlightedIndex === index || this.$refs.options.length === 0) {
            return;
          }

          var firstIndex = 0;
          var lastIndex = this.$refs.options.length - 1;

          if (index < firstIndex) {
            index = lastIndex;
          } else if (index > lastIndex) {
            index = firstIndex;
          }

          this.highlightedIndex = index;

          if (options.autoScroll) {
            this.scrollOptionIntoView(this.$refs.options[index].$el);
          }
        },
        selectHighlighted: function selectHighlighted(index, e) {
          if (this.$refs.options.length > 0) {
            e.preventDefault();
            this.selectOption(this.$refs.options[index].option, index);
          }
        },
        selectOption: function selectOption(option, index) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { autoClose: true };

          var shouldSelect = this.multiple && !this.isOptionSelected(option);

          if (this.multiple) {
            this.updateOption(option, { select: shouldSelect });
          } else {
            this.setValue(option);
            this.selectedIndex = index;
          }

          this.$emit('select', option, {
            selected: this.multiple ? shouldSelect : true
          });

          this.highlightedIndex = index;
          this.clearQuery();

          if (!this.multiple && options.autoClose) {
            this.closeDropdown();
          }
        },
        isOptionSelected: function isOptionSelected(option) {
          if (this.multiple) {
            return (0, _util.looseIndexOf)(this.value, option) > -1;
          }

          return (0, _util.looseEqual)(this.value, option);
        },
        updateOption: function updateOption(option) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: true };

          var value = [];
          var updated = false;
          var i = (0, _util.looseIndexOf)(this.value, option);

          if (options.select && i < 0) {
            value = this.value.concat(option);
            updated = true;
          }

          if (!options.select && i > -1) {
            value = this.value.slice(0, i).concat(this.value.slice(i + 1));
            updated = true;
          }

          if (updated) {
            this.setValue(value);
          }
        },
        defaultFilter: function defaultFilter(option) {
          var query = this.query.toLowerCase();
          var text = option[this.keys.label] || option;

          if (typeof text === 'string') {
            text = text.toLowerCase();
          }

          return (0, _fuzzysearch2.default)(query, text);
        },
        clearQuery: function clearQuery() {
          this.query = '';
        },
        toggleDropdown: function toggleDropdown() {
          this[this.showDropdown ? 'closeDropdown' : 'openDropdown']();
        },
        openDropdown: function openDropdown() {
          if (this.disabled) {
            return;
          }

          this.showDropdown = true;

          if (!this.isActive) {
            this.isActive = true;
          }
        },
        closeDropdown: function closeDropdown() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { autoBlur: false };

          this.showDropdown = false;

          if (!this.isTouched) {
            this.isTouched = true;
            this.$emit('touch');
          }

          if (options.autoBlur) {
            this.isActive = false;
          } else {
            this.$refs.label.focus();
          }
        },
        onFocus: function onFocus(e) {
          if (this.isActive) {
            return;
          }

          this.isActive = true;
          this.$emit('focus', e);
        },
        onBlur: function onBlur(e) {
          this.isActive = false;
          this.$emit('blur', e);

          if (this.showDropdown) {
            this.closeDropdown({ autoBlur: true });
          }
        },
        onOpen: function onOpen() {
          var _this4 = this;

          this.$nextTick(function () {
            _this4.$refs[_this4.hasSearch ? 'searchInput' : 'dropdown'].focus();
            _this4.scrollOptionIntoView(_this4.$refs.optionsList.querySelector('.is-selected'));
          });
        },
        onClose: function onClose() {
          this.highlightedIndex = this.multiple ? -1 : this.selectedIndex;
        },
        onExternalClick: function onExternalClick(e) {
          if (!this.$el.contains(e.target)) {
            if (this.showDropdown) {
              this.closeDropdown({ autoBlur: true });
            } else if (this.isActive) {
              this.isActive = false;
            }
          }
        },
        scrollOptionIntoView: function scrollOptionIntoView(optionEl) {
          (0, _elementScroll.scrollIntoView)(optionEl, {
            container: this.$refs.optionsList,
            marginTop: 180
          });
        },
        reset: function reset() {
          this.setValue(JSON.parse(this.initialValue));
          this.clearQuery();
          this.resetTouched();

          this.selectedIndex = -1;
          this.highlightedIndex = -1;
        },
        resetTouched: function resetTouched() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { touched: false };

          this.isTouched = options.touched;
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiProgressCircular: _UiProgressCircular2.default,
        UiSelectOption: _UiSelectOption2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-select-option',

      props: {
        option: {
          type: [String, Object],
          required: true
        },
        type: {
          type: String,
          default: 'basic' },
        multiple: {
          type: Boolean,
          default: false
        },
        highlighted: {
          type: Boolean,
          default: false
        },
        selected: {
          type: Boolean,
          default: false
        },
        keys: {
          type: Object,
          default: function _default() {
            return {
              label: 'label',
              image: 'image'
            };
          }
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-select-option--type-' + this.type, { 'is-highlighted': this.highlighted }, { 'is-selected': this.selected }];
        },
        imageStyle: function imageStyle() {
          return { 'background-image': 'url(' + this.option[this.keys.image] + ')' };
        }
      },

      components: {
        UiIcon: _UiIcon2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _classlist = __webpack_require__(11);

    var _classlist2 = _interopRequireDefault(_classlist);

    var _RespondsToWindowResize = __webpack_require__(28);

    var _RespondsToWindowResize2 = _interopRequireDefault(_RespondsToWindowResize);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-slider',

      props: {
        name: String,
        icon: String,
        value: {
          type: Number,
          required: true
        },
        step: {
          type: Number,
          default: 10
        },
        snapToSteps: {
          type: Boolean,
          default: false
        },
        showMarker: {
          type: Boolean,
          default: false
        },
        markerValue: Number,
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          initialValue: this.value,
          isActive: false,
          isDragging: false,
          thumbSize: 0,
          trackLength: 0,
          trackOffset: 0,
          localValue: this.value
        };
      },

      computed: {
        classes: function classes() {
          return [{ 'is-dragging': this.isDragging }, { 'is-disabled': this.disabled }, { 'is-active': this.isActive }, { 'has-icon': this.hasIcon }, { 'has-marker': this.showMarker }];
        },
        hasIcon: function hasIcon() {
          return Boolean(this.$slots.icon) || Boolean(this.icon);
        },
        fillStyle: function fillStyle() {
          return { transform: 'scaleX(' + this.localValue / 100 + ')' };
        },
        thumbStyle: function thumbStyle() {
          return {
            transform: 'translateX(' + (this.localValue / 100 * this.trackLength - this.thumbSize / 2) + 'px)'
          };
        },
        markerText: function markerText() {
          return this.markerValue ? this.markerValue : this.value;
        },
        snapPoints: function snapPoints() {
          var points = [];
          var index = 0;
          var point = index * this.step;

          while (point <= 100) {
            points.push(point);
            index++;
            point = index * this.step;
          }

          return points;
        }
      },

      watch: {
        value: function value() {
          this.setValue(this.value);
        },
        isDragging: function isDragging() {
          var operation = this.isDragging ? 'add' : 'remove';
          _classlist2.default[operation](document.body, 'ui-slider--is-dragging');
        }
      },

      mounted: function mounted() {
        this.initializeSlider();
      },
      beforeDestroy: function beforeDestroy() {
        this.teardownSlider();
      },

      methods: {
        reset: function reset() {
          this.setValue(this.initialValue);
        },
        onFocus: function onFocus() {
          this.isActive = true;
          this.$emit('focus');
        },
        onBlur: function onBlur() {
          this.isActive = false;
          this.$emit('blur');
        },
        onExternalClick: function onExternalClick(e) {
          if (!this.$el.contains(e.target)) {
            this.onBlur();
          }
        },
        setValue: function setValue(value) {
          if (value > 100) {
            value = 100;
          } else if (value < 0) {
            value = 0;
          }

          if (value === this.localValue) {
            return;
          }

          this.localValue = value;
          this.$emit('input', value);
          this.$emit('change', value);
        },
        incrementValue: function incrementValue() {
          this.setValue(this.localValue + this.step);
        },
        decrementValue: function decrementValue() {
          this.setValue(this.localValue - this.step);
        },
        getTrackOffset: function getTrackOffset() {
          var el = this.$refs.track;
          var offset = el.offsetLeft;

          while (el.offsetParent) {
            el = el.offsetParent;
            offset += el.offsetLeft;
          }

          return offset;
        },
        getPointStyle: function getPointStyle(point) {
          return {
            left: point + '%'
          };
        },
        refreshSize: function refreshSize() {
          this.thumbSize = this.$refs.thumb.offsetWidth;
          this.trackLength = this.$refs.track.offsetWidth;
          this.trackOffset = this.getTrackOffset(this.$refs.track);
        },
        initializeSlider: function initializeSlider() {
          var _this = this;

          document.addEventListener('touchend', this.onDragStop);
          document.addEventListener('mouseup', this.onDragStop);
          document.addEventListener('click', this.onExternalClick);

          this.$on('window-resize', function () {
            _this.refreshSize();
            _this.isDragging = false;
          });

          this.refreshSize();
          this.initializeDrag();
        },
        teardownSlider: function teardownSlider() {
          document.removeEventListener('touchend', this.onDragStop);
          document.removeEventListener('mouseup', this.onDragStop);
          document.removeEventListener('click', this.onExternalClick);
        },
        initializeDrag: function initializeDrag() {
          var value = this.getEdge(this.localValue ? this.localValue : 0, 0, 100);
          this.setValue(value);
        },
        onDragStart: function onDragStart(e) {
          if (this.disabled) {
            return;
          }

          if (!this.isActive) {
            this.onFocus();
          }

          this.isDragging = true;
          this.dragUpdate(e);

          document.addEventListener('touchmove', this.onDragMove);
          document.addEventListener('mousemove', this.onDragMove);

          this.$emit('dragstart', this.localValue, e);
        },
        onDragMove: function onDragMove(e) {
          this.dragUpdate(e);
        },
        dragUpdate: function dragUpdate(e) {
          var position = e.touches ? e.touches[0].pageX : e.pageX;
          var value = this.getEdge((position - this.trackOffset) / this.trackLength * 100, 0, 100);

          if (this.isDragging) {
            this.setValue(Math.round(value));
          }
        },
        onDragStop: function onDragStop(e) {
          this.isDragging = false;

          if (this.snapToSteps && this.value % this.step !== 0) {
            this.setValue(this.getNearestSnapPoint());
          }

          document.removeEventListener('touchmove', this.onDragMove);
          document.removeEventListener('mousemove', this.onDragMove);

          this.$emit('dragend', this.localValue, e);
        },
        getNearestSnapPoint: function getNearestSnapPoint() {
          var previousSnapPoint = Math.floor(this.value / this.step) * this.step;
          var nextSnapPoint = previousSnapPoint + this.step;
          var midpoint = (previousSnapPoint + nextSnapPoint) / 2;

          return this.value >= midpoint ? nextSnapPoint : previousSnapPoint;
        },
        getEdge: function getEdge(a, b, c) {
          if (a < b) {
            return b;
          }

          if (a > c) {
            return c;
          }

          return a;
        }
      },

      components: {
        UiIcon: _UiIcon2.default
      },

      mixins: [_RespondsToWindowResize2.default]
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiButton = __webpack_require__(14);

    var _UiButton2 = _interopRequireDefault(_UiButton);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-snackbar',

      props: {
        message: String,
        action: String,
        actionColor: {
          type: String,
          default: 'accent' },
        transition: {
          type: String,
          default: 'slide' }
      },

      computed: {
        transitionName: function transitionName() {
          return 'ui-snackbar--transition-' + this.transition;
        }
      },

      methods: {
        onClick: function onClick() {
          this.$emit('click');
        },
        onActionClick: function onActionClick() {
          this.$emit('action-click');
        },
        onEnter: function onEnter() {
          this.$emit('show');
        },
        onLeave: function onLeave() {
          this.$emit('hide');
        }
      },

      components: {
        UiButton: _UiButton2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiSnackbar = __webpack_require__(46);

    var _UiSnackbar2 = _interopRequireDefault(_UiSnackbar);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-snackbar-container',

      props: {
        queueSnackbars: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 5000
        },
        allowHtml: {
          type: Boolean,
          default: false
        },
        position: {
          type: String,
          default: 'left' },
        transition: {
          type: String,
          default: 'slide' }
      },

      data: function data() {
        return {
          queue: [],
          snackbarTimeout: null
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-snackbar-container--position-' + this.position];
        }
      },

      beforeDestroy: function beforeDestroy() {
        this.resetTimeout();
      },

      methods: {
        createSnackbar: function createSnackbar(snackbar) {
          snackbar.show = false;
          snackbar.duration = snackbar.duration || this.duration;

          this.queue.push(snackbar);

          if (this.queue.length === 1) {
            return this.showNextSnackbar();
          } else if (!this.queueSnackbars) {
            this.queue[0].show = false;
          }
        },
        showNextSnackbar: function showNextSnackbar() {
          if (this.queue.length === 0) {
            return;
          }

          this.queue[0].show = true;
        },
        onShow: function onShow(snackbar) {
          var _this = this;

          if (this.queue.indexOf(snackbar) !== 0) {
            return;
          }

          this.snackbarTimeout = setTimeout(function () {
            _this.queue[0].show = false;
          }, snackbar.duration);

          this.$emit('snackbar-show', snackbar);
          this.callHook('onShow', snackbar);
        },
        onHide: function onHide(snackbar, index) {
          if (this.queueSnackbars || this.queue.length === 1) {
            this.queue.splice(index, 1);
          } else {
            this.queue.splice(index, this.queue.length - 1);
          }

          this.$emit('snackbar-hide', snackbar);
          this.callHook('onHide', snackbar);

          this.resetTimeout();
          this.showNextSnackbar();
        },
        onClick: function onClick(snackbar) {
          snackbar.show = false;
          this.callHook('onClick', snackbar);
        },
        onActionClick: function onActionClick(snackbar) {
          this.callHook('onActionClick', snackbar);
        },
        callHook: function callHook(hook, snackbar) {
          if (typeof snackbar[hook] === 'function') {
            snackbar[hook].call(undefined, snackbar);
          }
        },
        resetTimeout: function resetTimeout() {
          clearTimeout(this.snackbarTimeout);
          this.snackbarTimeout = null;
        }
      },

      components: {
        UiSnackbar: _UiSnackbar2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _util = __webpack_require__(17);

    exports.default = {
      name: 'ui-switch',

      props: {
        name: String,
        label: String,
        value: {
          required: true
        },
        trueValue: {
          default: true
        },
        falseValue: {
          default: false
        },
        submittedValue: {
          type: String,
          default: 'on' },
        checked: {
          type: Boolean,
          default: false
        },
        color: {
          type: String,
          default: 'primary' },
        switchPosition: {
          type: String,
          default: 'left' },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          isActive: false,
          isChecked: (0, _util.looseEqual)(this.value, this.trueValue) || this.checked,
          initialValue: this.value
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-switch--color-' + this.color, 'ui-switch--switch-position-' + this.switchPosition, { 'is-active': this.isActive }, { 'is-checked': this.isChecked }, { 'is-disabled': this.disabled }];
        }
      },

      watch: {
        value: function value() {
          this.isChecked = (0, _util.looseEqual)(this.value, this.trueValue);
        }
      },

      created: function created() {
        this.$emit('input', this.isChecked ? this.trueValue : this.falseValue);
      },

      methods: {
        onClick: function onClick(e) {
          this.isChecked = e.target.checked;
          this.$emit('input', e.target.checked ? this.trueValue : this.falseValue);
        },
        onChange: function onChange(e) {
          this.$emit('change', this.isChecked ? this.trueValue : this.falseValue, e);
        },
        onFocus: function onFocus() {
          this.isActive = true;
          this.$emit('focus');
        },
        onBlur: function onBlur() {
          this.isActive = false;
          this.$emit('blur');
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _uuid = __webpack_require__(49);

    var _uuid2 = _interopRequireDefault(_uuid);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-tab',

      props: {
        id: {
          type: String,
          default: function _default() {
            return _uuid2.default.short('ui-tab-');
          }
        },
        title: String,
        icon: String,
        iconProps: {
          type: Object,
          default: function _default() {
            return {};
          }
        },
        show: {
          type: Boolean,
          default: true
        },
        selected: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          isActive: false
        };
      },

      watch: {
        show: function show() {
          this.$parent.handleTabShowChange(this);
        },
        disabled: function disabled() {
          this.$parent.handleTabDisableChange(this);
        }
      },

      created: function created() {
        this.$parent.registerTab(this);
      },

      methods: {
        activate: function activate() {
          this.isActive = true;
          this.$emit('select', this.id);
        },
        deactivate: function deactivate() {
          this.isActive = false;
          this.$emit('deselect', this.id);
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiRippleInk = __webpack_require__(3);

    var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-tab-header-item',

      props: {
        id: String,
        type: {
          type: String,
          default: 'text' },
        title: String,
        icon: String,
        iconProps: {
          type: Object,
          default: function _default() {
            return {};
          }
        },
        active: {
          type: Boolean,
          default: false
        },
        show: {
          type: Boolean,
          default: true
        },
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-tab-header-item--type-' + this.type, { 'is-active': this.active }, { 'is-disabled': this.disabled }];
        }
      },

      components: {
        UiIcon: _UiIcon2.default,
        UiRippleInk: _UiRippleInk2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _RespondsToWindowResize = __webpack_require__(28);

    var _RespondsToWindowResize2 = _interopRequireDefault(_RespondsToWindowResize);

    var _UiTabHeaderItem = __webpack_require__(214);

    var _UiTabHeaderItem2 = _interopRequireDefault(_UiTabHeaderItem);

    var _config = __webpack_require__(2);

    var _config2 = _interopRequireDefault(_config);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-tabs',

      props: {
        type: {
          type: String,
          default: 'text' },
        backgroundColor: {
          type: String,
          default: 'default' },
        textColor: {
          type: String,
          default: 'black' },
        textColorActive: {
          type: String,
          default: 'primary' },
        indicatorColor: {
          type: String,
          default: 'primary' },
        fullwidth: {
          type: Boolean,
          default: false
        },
        raised: {
          type: Boolean,
          default: false
        },
        disableRipple: {
          type: Boolean,
          default: _config2.default.data.disableRipple
        }
      },

      data: function data() {
        return {
          tabs: [],
          activeTabId: null,
          activeTabIndex: -1,
          activeTabElement: null,
          activeTabPosition: {
            left: 0,
            width: 0
          },
          tabContainerWidth: 0
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-tabs--type-' + this.type, 'ui-tabs--text-color-' + this.textColor, 'ui-tabs--text-color-active-' + this.textColorActive, 'ui-tabs--background-color-' + this.backgroundColor, 'ui-tabs--indicator-color-' + this.textColorActive, { 'is-raised': this.raised }, { 'is-fullwidth': this.fullwidth }];
        },
        indicatorLeft: function indicatorLeft() {
          return this.activeTabPosition.left + 'px';
        },
        indicatorRight: function indicatorRight() {
          return this.tabContainerWidth - (this.activeTabPosition.left + this.activeTabPosition.width) + 'px';
        }
      },

      watch: {
        activeTabId: function activeTabId() {
          var _this = this;

          this.tabs.forEach(function (tab, index) {
            if (_this.activeTabId === tab.id) {
              tab.activate();
              _this.activeTabIndex = index;
            } else if (tab.isActive) {
              tab.deactivate();
            }
          });
        },
        activeTabElement: function activeTabElement() {
          this.refreshIndicator();
        }
      },

      mounted: function mounted() {
        var _this2 = this;

        this.$nextTick(function () {
          _this2.tabContainerWidth = _this2.$refs.tabsContainer.offsetWidth;
          _this2.activeTabElement = _this2.$refs.tabsContainer.querySelector('.is-active');
        });

        this.$on('window-resize', function () {
          _this2.tabContainerWidth = _this2.$refs.tabsContainer.offsetWidth;
          _this2.refreshIndicator();
        });
      },

      methods: {
        registerTab: function registerTab(tab) {
          this.tabs.push(tab);

          if (this.activeTabId === null || tab.selected) {
            this.activeTabId = tab.id;
          }
        },
        handleTabShowChange: function handleTabShowChange(tab) {
          if (this.activeTabId === tab.id && !tab.show) {
            var newTab = this.findNearestAvailableTab({ preferPrevious: true });

            if (newTab) {
              this.selectTab(newTab.$el, newTab);
            }
          }

          this.refreshIndicator();
        },
        handleTabDisableChange: function handleTabDisableChange(tab) {
          if (this.activeTabId === tab.id && tab.disabled) {
            var newTab = this.findNearestAvailableTab({ preferPrevious: true });

            if (newTab) {
              this.selectTab(newTab.$el, newTab);
            }
          }
        },
        selectTab: function selectTab(e, tab) {
          var newTabElement = e.currentTarget ? e.currentTarget : e;

          if (tab.disabled || this.activeTabElement === newTabElement) {
            return;
          }

          this.activeTabElement = newTabElement;
          this.activeTabId = tab.id;

          this.$emit('tab-change', tab.id);
        },
        selectPreviousTab: function selectPreviousTab() {
          if (this.activeTabIndex === 0) {
            return;
          }

          var previousTab = this.findTabByIndex(this.activeTabIndex, { findPrevious: true });

          if (!previousTab) {
            return;
          }

          this.selectTab(previousTab.$el, previousTab);
          this.activeTabElement.focus();
        },
        selectNextTab: function selectNextTab() {
          if (this.activeTabIndex === this.$refs.tabElements.length - 1) {
            return;
          }

          var nextTab = this.findTabByIndex(this.activeTabIndex);

          if (!nextTab) {
            return;
          }

          this.selectTab(nextTab.$el, nextTab);
          this.activeTabElement.focus();
        },
        findTabByIndex: function findTabByIndex(currentTabIndex) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { findPrevious: false };

          var tab = null;

          if (options.findPrevious) {
            for (var i = currentTabIndex - 1; i >= 0; i--) {
              if (!this.$refs.tabElements[i].disabled && this.$refs.tabElements[i].show) {
                tab = this.$refs.tabElements[i];
                break;
              }
            }
          } else {
            for (var _i = currentTabIndex + 1; _i < this.$refs.tabElements.length; _i++) {
              if (!this.$refs.tabElements[_i].disabled && this.$refs.tabElements[_i].show) {
                tab = this.$refs.tabElements[_i];
                break;
              }
            }
          }

          return tab;
        },
        findTabById: function findTabById(id) {
          var tab = null;
          var numberOfTabs = this.$refs.tabElements.length;

          for (var i = 0; i <= numberOfTabs; i++) {
            if (id === this.$refs.tabElements[i].id) {
              tab = this.$refs.tabElements[i];
              break;
            }
          }

          return tab;
        },
        findNearestAvailableTab: function findNearestAvailableTab() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { preferPrevious: false };

          var tab = this.findTabByIndex(this.activeTabIndex, {
            findPrevious: options.preferPrevious
          });

          if (tab) {
            return tab;
          }

          return this.findTabByIndex(this.activeTabIndex, {
            findPrevious: !options.preferPrevious
          });
        },
        setActiveTab: function setActiveTab(tabId) {
          var tab = this.findTabById(tabId);

          if (tab && !tab.disabled) {
            this.selectTab(tab.$el, tab);
          }
        },
        refreshIndicator: function refreshIndicator() {
          this.activeTabPosition = {
            left: this.activeTabElement ? this.activeTabElement.offsetLeft : 0,
            width: this.activeTabElement ? this.activeTabElement.offsetWidth : 0
          };
        }
      },

      components: {
        UiTabHeaderItem: _UiTabHeaderItem2.default,
        RenderVnodes: {
          name: 'render-vnodes',
          functional: true,
          props: ['nodes'],
          render: function render(createElement, context) {
            return createElement('div', context.props.nodes);
          }
        }
      },

      mixins: [_RespondsToWindowResize2.default]
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _autofocus = __webpack_require__(47);

    var _autofocus2 = _interopRequireDefault(_autofocus);

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _autosize = __webpack_require__(85);

    var _autosize2 = _interopRequireDefault(_autosize);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-textbox',

      props: {
        name: String,
        placeholder: String,
        value: {
          type: [String, Number],
          required: true
        },
        icon: String,
        iconPosition: {
          type: String,
          default: 'left' },
        label: String,
        floatingLabel: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: 'text' },
        multiLine: {
          type: Boolean,
          default: false
        },
        rows: {
          type: Number,
          default: 2
        },
        autocomplete: String,
        autofocus: {
          type: Boolean,
          default: false
        },
        autosize: {
          type: Boolean,
          default: true
        },
        min: Number,
        max: Number,
        step: {
          type: String,
          default: 'any'
        },
        maxlength: Number,
        enforceMaxlength: {
          type: Boolean,
          default: false
        },
        required: {
          type: Boolean,
          default: false
        },
        readonly: {
          type: Boolean,
          default: false
        },
        help: String,
        error: String,
        invalid: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },

      data: function data() {
        return {
          isActive: false,
          isTouched: false,
          initialValue: this.value,
          autosizeInitialized: false
        };
      },

      computed: {
        classes: function classes() {
          return ['ui-textbox--icon-position-' + this.iconPosition, { 'is-active': this.isActive }, { 'is-invalid': this.invalid }, { 'is-touched': this.isTouched }, { 'is-multi-line': this.multiLine }, { 'has-counter': this.maxlength }, { 'is-disabled': this.disabled }, { 'has-label': this.hasLabel }, { 'has-floating-label': this.hasFloatingLabel }];
        },
        labelClasses: function labelClasses() {
          return {
            'is-inline': this.hasFloatingLabel && this.isLabelInline,
            'is-floating': this.hasFloatingLabel && !this.isLabelInline
          };
        },
        hasLabel: function hasLabel() {
          return Boolean(this.label) || Boolean(this.$slots.default);
        },
        hasFloatingLabel: function hasFloatingLabel() {
          return this.hasLabel && this.floatingLabel;
        },
        isLabelInline: function isLabelInline() {
          return this.value.length === 0 && !this.isActive;
        },
        minValue: function minValue() {
          if (this.type === 'number' && this.min !== undefined) {
            return this.min;
          }

          return null;
        },
        maxValue: function maxValue() {
          if (this.type === 'number' && this.max !== undefined) {
            return this.max;
          }

          return null;
        },
        stepValue: function stepValue() {
          return this.type === 'number' ? this.step : null;
        },
        hasFeedback: function hasFeedback() {
          return Boolean(this.help) || Boolean(this.error);
        },
        showError: function showError() {
          return this.invalid && Boolean(this.error);
        },
        showHelp: function showHelp() {
          return !this.showError && Boolean(this.help);
        }
      },

      mounted: function mounted() {
        if (this.multiLine && this.autosize) {
          (0, _autosize2.default)(this.$refs.textarea);
          this.autosizeInitialized = true;
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (this.autosizeInitialized) {
          _autosize2.default.destroy(this.$refs.textarea);
        }
      },

      methods: {
        updateValue: function updateValue(value) {
          this.$emit('input', value);
        },
        onChange: function onChange(e) {
          this.$emit('change', this.value, e);
        },
        onFocus: function onFocus(e) {
          this.isActive = true;
          this.$emit('focus', e);
        },
        onBlur: function onBlur(e) {
          this.isActive = false;
          this.$emit('blur', e);

          if (!this.isTouched) {
            this.isTouched = true;
            this.$emit('touch');
          }
        },
        onKeydown: function onKeydown(e) {
          this.$emit('keydown', e);
        },
        onKeydownEnter: function onKeydownEnter(e) {
          this.$emit('keydown-enter', e);
        },
        reset: function reset() {
          if (document.activeElement === this.$refs.input || document.activeElement === this.$refs.textarea) {
            document.activeElement.blur();
          }

          this.updateValue(this.initialValue);
          this.resetTouched();
        },
        resetTouched: function resetTouched() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { touched: false };

          this.isTouched = options.touched;
        },
        refreshSize: function refreshSize() {
          if (this.autosizeInitialized) {
            _autosize2.default.update(this.$refs.textarea);
          }
        }
      },

      components: {
        UiIcon: _UiIcon2.default
      },

      directives: {
        autofocus: _autofocus2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _UiIconButton = __webpack_require__(25);

    var _UiIconButton2 = _interopRequireDefault(_UiIconButton);

    var _UiProgressLinear = __webpack_require__(44);

    var _UiProgressLinear2 = _interopRequireDefault(_UiProgressLinear);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-toolbar',

      props: {
        type: {
          type: String,
          default: 'default' },
        textColor: {
          type: String,
          default: 'black' },
        title: String,
        brand: String,
        removeBrandDivider: {
          type: Boolean,
          default: false
        },
        navIcon: {
          type: String,
          default: 'menu'
        },
        removeNavIcon: {
          type: Boolean,
          default: false
        },
        raised: {
          type: Boolean,
          default: true
        },
        progressPosition: {
          type: String,
          default: 'bottom' },
        loading: {
          type: Boolean,
          default: false
        }
      },

      computed: {
        classes: function classes() {
          return ['ui-toolbar--type-' + this.type, 'ui-toolbar--text-color-' + this.textColor, 'ui-toolbar--progress-position-' + this.progressPosition, { 'is-raised': this.raised }];
        },
        progressColor: function progressColor() {
          return this.textColor === 'black' ? 'primary' : 'white';
        },
        hasBrandDivider: function hasBrandDivider() {
          return this.removeBrandDivider ? false : this.brand || this.$slots.brand;
        }
      },

      methods: {
        navIconClick: function navIconClick() {
          this.$emit('nav-icon-click');
        }
      },

      components: {
        UiIconButton: _UiIconButton2.default,
        UiProgressLinear: _UiProgressLinear2.default
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _tetherTooltip = __webpack_require__(207);

    var _tetherTooltip2 = _interopRequireDefault(_tetherTooltip);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = {
      name: 'ui-tooltip',

      props: {
        trigger: {
          type: String,
          required: true
        },
        position: {
          type: String,
          default: 'bottom center'
        },
        openOn: {
          type: String,
          default: 'hover focus'
        },
        openDelay: {
          type: Number,
          default: 0
        }
      },

      data: function data() {
        return {
          tooltip: null
        };
      },

      watch: {
        trigger: function trigger() {
          if (this.tooltip === null) {
            this.initialize();
          }
        }
      },

      mounted: function mounted() {
        if (this.tooltip === null) {
          this.initialize();
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (this.tooltip !== null) {
          this.tooltip.destroy();
        }
      },

      methods: {
        initialize: function initialize() {
          if (this.trigger !== undefined) {
            this.tooltip = new _tetherTooltip2.default({
              target: this.$parent.$refs[this.trigger],
              content: this.$refs.tooltip,
              classes: 'ui-tooltip--theme-default',
              position: this.position,
              openOn: this.openOn,
              openDelay: this.openDelay
            });
          }
        }
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    document.addEventListener('DOMContentLoaded', function () {
      var hadKeyboardEvent = false;
      var keyboardModalityWhitelist = ['input:not([type])', 'input[type=text]', 'input[type=number]', 'input[type=date]', 'input[type=time]', 'input[type=datetime]', 'textarea', '[role=textbox]', '[supports-modality=keyboard]'].join(',');

      var isHandlingKeyboardThrottle = void 0;

      var matcher = function () {
        var el = document.body;

        if (el.matchesSelector) {
          return el.matchesSelector;
        }

        if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector;
        }

        if (el.mozMatchesSelector) {
          return el.mozMatchesSelector;
        }

        if (el.msMatchesSelector) {
          return el.msMatchesSelector;
        }

        console.error('Couldn\'t find any matchesSelector method on document.body.');
      }();

      var disableFocusRingByDefault = function disableFocusRingByDefault() {
        var css = 'body:not([modality=keyboard]) :focus { outline: none; }';
        var head = document.head || document.getElementsByTagName('head')[0];
        var style = document.createElement('style');

        style.type = 'text/css';
        style.id = 'disable-focus-ring';

        if (style.styleSheet) {
          style.styleSheet.cssText = css;
        } else {
          style.appendChild(document.createTextNode(css));
        }

        head.insertBefore(style, head.firstChild);
      };

      var focusTriggersKeyboardModality = function focusTriggersKeyboardModality(el) {
        var triggers = false;

        if (matcher) {
          triggers = matcher.call(el, keyboardModalityWhitelist) && matcher.call(el, ':not([readonly])');
        }

        return triggers;
      };

      disableFocusRingByDefault();

      document.body.addEventListener('keydown', function () {
        hadKeyboardEvent = true;

        if (isHandlingKeyboardThrottle) {
          clearTimeout(isHandlingKeyboardThrottle);
        }

        isHandlingKeyboardThrottle = setTimeout(function () {
          hadKeyboardEvent = false;
        }, 100);
      }, true);

      document.body.addEventListener('focus', function (e) {
        if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
          document.body.setAttribute('modality', 'keyboard');
        }
      }, true);

      document.body.addEventListener('blur', function () {
        document.body.removeAttribute('modality');
      }, true);
    });
  }, function (module, exports, __webpack_require__) {

    module.exports = { "default": __webpack_require__(134), __esModule: true };
  }, function (module, exports, __webpack_require__) {

    module.exports = { "default": __webpack_require__(135), __esModule: true };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    exports.__esModule = true;

    exports.default = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    exports.__esModule = true;

    var _defineProperty = __webpack_require__(50);

    var _defineProperty2 = _interopRequireDefault(_defineProperty);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          (0, _defineProperty2.default)(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
  }, function (module, exports, __webpack_require__) {

    "use strict";

    exports.__esModule = true;

    var _defineProperty = __webpack_require__(50);

    var _defineProperty2 = _interopRequireDefault(_defineProperty);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = function (obj, key, value) {
      if (key in obj) {
        (0, _defineProperty2.default)(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    };
  }, function (module, exports, __webpack_require__) {

    var core = __webpack_require__(13),
        $JSON = core.JSON || (core.JSON = { stringify: _stringify4.default });
    module.exports = function stringify(it) {
      return $JSON.stringify.apply($JSON, arguments);
    };
  }, function (module, exports, __webpack_require__) {

    __webpack_require__(157);
    var $Object = __webpack_require__(13).Object;
    module.exports = function defineProperty(it, key, desc) {
      return $Object.defineProperty(it, key, desc);
    };
  }, function (module, exports, __webpack_require__) {

    __webpack_require__(160);
    __webpack_require__(158);
    __webpack_require__(161);
    __webpack_require__(162);
    module.exports = __webpack_require__(13).Symbol;
  }, function (module, exports, __webpack_require__) {

    __webpack_require__(159);
    __webpack_require__(163);
    module.exports = __webpack_require__(41).f('iterator');
  }, function (module, exports) {

    module.exports = function (it) {
      if (typeof it != 'function') throw TypeError(it + ' is not a function!');
      return it;
    };
  }, function (module, exports) {

    module.exports = function () {};
  }, function (module, exports, __webpack_require__) {
    var toIObject = __webpack_require__(8),
        toLength = __webpack_require__(154),
        toIndex = __webpack_require__(153);
    module.exports = function (IS_INCLUDES) {
      return function ($this, el, fromIndex) {
        var O = toIObject($this),
            length = toLength(O.length),
            index = toIndex(fromIndex, length),
            value;

        if (IS_INCLUDES && el != el) while (length > index) {
          value = O[index++];
          if (value != value) return true;
        } else for (; length > index; index++) {
          if (IS_INCLUDES || index in O) {
            if (O[index] === el) return IS_INCLUDES || index || 0;
          }
        }return !IS_INCLUDES && -1;
      };
    };
  }, function (module, exports, __webpack_require__) {
    var aFunction = __webpack_require__(136);
    module.exports = function (fn, that, length) {
      aFunction(fn);
      if (that === undefined) return fn;
      switch (length) {
        case 1:
          return function (a) {
            return fn.call(that, a);
          };
        case 2:
          return function (a, b) {
            return fn.call(that, a, b);
          };
        case 3:
          return function (a, b, c) {
            return fn.call(that, a, b, c);
          };
      }
      return function () {
        return fn.apply(that, arguments);
      };
    };
  }, function (module, exports, __webpack_require__) {
    var getKeys = __webpack_require__(22),
        gOPS = __webpack_require__(58),
        pIE = __webpack_require__(34);
    module.exports = function (it) {
      var result = getKeys(it),
          getSymbols = gOPS.f;
      if (getSymbols) {
        var symbols = getSymbols(it),
            isEnum = pIE.f,
            i = 0,
            key;
        while (symbols.length > i) {
          if (isEnum.call(it, key = symbols[i++])) result.push(key);
        }
      }return result;
    };
  }, function (module, exports, __webpack_require__) {

    module.exports = __webpack_require__(4).document && document.documentElement;
  }, function (module, exports, __webpack_require__) {
    var cof = __webpack_require__(52);
    module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
      return cof(it) == 'String' ? it.split('') : Object(it);
    };
  }, function (module, exports, __webpack_require__) {
    var cof = __webpack_require__(52);
    module.exports = Array.isArray || function isArray(arg) {
      return cof(arg) == 'Array';
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    var create = __webpack_require__(56),
        descriptor = __webpack_require__(23),
        setToStringTag = __webpack_require__(35),
        IteratorPrototype = {};

    __webpack_require__(9)(IteratorPrototype, __webpack_require__(10)('iterator'), function () {
      return this;
    });

    module.exports = function (Constructor, NAME, next) {
      Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
      setToStringTag(Constructor, NAME + ' Iterator');
    };
  }, function (module, exports) {

    module.exports = function (done, value) {
      return { value: value, done: !!done };
    };
  }, function (module, exports, __webpack_require__) {

    var getKeys = __webpack_require__(22),
        toIObject = __webpack_require__(8);
    module.exports = function (object, el) {
      var O = toIObject(object),
          keys = getKeys(O),
          length = keys.length,
          index = 0,
          key;
      while (length > index) {
        if (O[key = keys[index++]] === el) return key;
      }
    };
  }, function (module, exports, __webpack_require__) {

    var META = __webpack_require__(24)('meta'),
        isObject = __webpack_require__(21),
        has = __webpack_require__(6),
        setDesc = __webpack_require__(7).f,
        id = 0;
    var isExtensible = _isExtensible2.default || function () {
      return true;
    };
    var FREEZE = !__webpack_require__(20)(function () {
      return isExtensible((0, _preventExtensions2.default)({}));
    });
    var setMeta = function setMeta(it) {
      setDesc(it, META, { value: {
          i: 'O' + ++id,
          w: {} } });
    };
    var fastKey = function fastKey(it, create) {
      if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : (0, _typeof6.default)(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
      if (!has(it, META)) {
        if (!isExtensible(it)) return 'F';

        if (!create) return 'E';

        setMeta(it);
      }return it[META].i;
    };
    var getWeak = function getWeak(it, create) {
      if (!has(it, META)) {
        if (!isExtensible(it)) return true;

        if (!create) return false;

        setMeta(it);
      }return it[META].w;
    };

    var onFreeze = function onFreeze(it) {
      if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
      return it;
    };
    var meta = module.exports = {
      KEY: META,
      NEED: false,
      fastKey: fastKey,
      getWeak: getWeak,
      onFreeze: onFreeze
    };
  }, function (module, exports, __webpack_require__) {

    var dP = __webpack_require__(7),
        anObject = __webpack_require__(19),
        getKeys = __webpack_require__(22);

    module.exports = __webpack_require__(5) ? _defineProperties2.default : function defineProperties(O, Properties) {
      anObject(O);
      var keys = getKeys(Properties),
          length = keys.length,
          i = 0,
          P;
      while (length > i) {
        dP.f(O, P = keys[i++], Properties[P]);
      }return O;
    };
  }, function (module, exports, __webpack_require__) {

    var pIE = __webpack_require__(34),
        createDesc = __webpack_require__(23),
        toIObject = __webpack_require__(8),
        toPrimitive = __webpack_require__(39),
        has = __webpack_require__(6),
        IE8_DOM_DEFINE = __webpack_require__(54),
        gOPD = _getOwnPropertyDescriptor2.default;

    exports.f = __webpack_require__(5) ? gOPD : function getOwnPropertyDescriptor(O, P) {
      O = toIObject(O);
      P = toPrimitive(P, true);
      if (IE8_DOM_DEFINE) try {
        return gOPD(O, P);
      } catch (e) {}
      if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
    };
  }, function (module, exports, __webpack_require__) {
    var toIObject = __webpack_require__(8),
        gOPN = __webpack_require__(57).f,
        toString = {}.toString;

    var windowNames = (typeof window === 'undefined' ? 'undefined' : (0, _typeof6.default)(window)) == 'object' && window && _getOwnPropertyNames2.default ? (0, _getOwnPropertyNames2.default)(window) : [];

    var getWindowNames = function getWindowNames(it) {
      try {
        return gOPN(it);
      } catch (e) {
        return windowNames.slice();
      }
    };

    module.exports.f = function getOwnPropertyNames(it) {
      return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
    };
  }, function (module, exports, __webpack_require__) {
    var has = __webpack_require__(6),
        toObject = __webpack_require__(155),
        IE_PROTO = __webpack_require__(36)('IE_PROTO'),
        ObjectProto = Object.prototype;

    module.exports = _getPrototypeOf2.default || function (O) {
      O = toObject(O);
      if (has(O, IE_PROTO)) return O[IE_PROTO];
      if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
      }return O instanceof Object ? ObjectProto : null;
    };
  }, function (module, exports, __webpack_require__) {

    var toInteger = __webpack_require__(38),
        defined = __webpack_require__(29);

    module.exports = function (TO_STRING) {
      return function (that, pos) {
        var s = String(defined(that)),
            i = toInteger(pos),
            l = s.length,
            a,
            b;
        if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
        a = s.charCodeAt(i);
        return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
      };
    };
  }, function (module, exports, __webpack_require__) {

    var toInteger = __webpack_require__(38),
        max = Math.max,
        min = Math.min;
    module.exports = function (index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    };
  }, function (module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(38),
        min = Math.min;
    module.exports = function (it) {
      return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
    };
  }, function (module, exports, __webpack_require__) {
    var defined = __webpack_require__(29);
    module.exports = function (it) {
      return Object(defined(it));
    };
  }, function (module, exports, __webpack_require__) {

    "use strict";

    var addToUnscopables = __webpack_require__(137),
        step = __webpack_require__(145),
        Iterators = __webpack_require__(32),
        toIObject = __webpack_require__(8);

    module.exports = __webpack_require__(55)(Array, 'Array', function (iterated, kind) {
      this._t = toIObject(iterated);
      this._i = 0;
      this._k = kind;
    }, function () {
      var O = this._t,
          kind = this._k,
          index = this._i++;
      if (!O || index >= O.length) {
        this._t = undefined;
        return step(1);
      }
      if (kind == 'keys') return step(0, index);
      if (kind == 'values') return step(0, O[index]);
      return step(0, [index, O[index]]);
    }, 'values');

    Iterators.Arguments = Iterators.Array;

    addToUnscopables('keys');
    addToUnscopables('values');
    addToUnscopables('entries');
  }, function (module, exports, __webpack_require__) {

    var $export = __webpack_require__(31);

    $export($export.S + $export.F * !__webpack_require__(5), 'Object', { defineProperty: __webpack_require__(7).f });
  }, function (module, exports) {}, function (module, exports, __webpack_require__) {

    "use strict";

    var $at = __webpack_require__(152)(true);

    __webpack_require__(55)(String, 'String', function (iterated) {
      this._t = String(iterated);
      this._i = 0;
    }, function () {
      var O = this._t,
          index = this._i,
          point;
      if (index >= O.length) return { value: undefined, done: true };
      point = $at(O, index);
      this._i += point.length;
      return { value: point, done: false };
    });
  }, function (module, exports, __webpack_require__) {

    "use strict";

    var global = __webpack_require__(4),
        has = __webpack_require__(6),
        DESCRIPTORS = __webpack_require__(5),
        $export = __webpack_require__(31),
        redefine = __webpack_require__(60),
        META = __webpack_require__(147).KEY,
        $fails = __webpack_require__(20),
        shared = __webpack_require__(37),
        setToStringTag = __webpack_require__(35),
        uid = __webpack_require__(24),
        wks = __webpack_require__(10),
        wksExt = __webpack_require__(41),
        wksDefine = __webpack_require__(40),
        keyOf = __webpack_require__(146),
        enumKeys = __webpack_require__(140),
        isArray = __webpack_require__(143),
        anObject = __webpack_require__(19),
        toIObject = __webpack_require__(8),
        toPrimitive = __webpack_require__(39),
        createDesc = __webpack_require__(23),
        _create = __webpack_require__(56),
        gOPNExt = __webpack_require__(150),
        $GOPD = __webpack_require__(149),
        $DP = __webpack_require__(7),
        $keys = __webpack_require__(22),
        gOPD = $GOPD.f,
        dP = $DP.f,
        gOPN = gOPNExt.f,
        $Symbol = global.Symbol,
        $JSON = global.JSON,
        _stringify = $JSON && $JSON.stringify,
        PROTOTYPE = 'prototype',
        HIDDEN = wks('_hidden'),
        TO_PRIMITIVE = wks('toPrimitive'),
        isEnum = {}.propertyIsEnumerable,
        SymbolRegistry = shared('symbol-registry'),
        AllSymbols = shared('symbols'),
        OPSymbols = shared('op-symbols'),
        ObjectProto = Object[PROTOTYPE],
        USE_NATIVE = typeof $Symbol == 'function',
        QObject = global.QObject;

    var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

    var setSymbolDesc = DESCRIPTORS && $fails(function () {
      return _create(dP({}, 'a', {
        get: function get() {
          return dP(this, 'a', { value: 7 }).a;
        }
      })).a != 7;
    }) ? function (it, key, D) {
      var protoDesc = gOPD(ObjectProto, key);
      if (protoDesc) delete ObjectProto[key];
      dP(it, key, D);
      if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
    } : dP;

    var wrap = function wrap(tag) {
      var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
      sym._k = tag;
      return sym;
    };

    var isSymbol = USE_NATIVE && (0, _typeof6.default)($Symbol.iterator) == 'symbol' ? function (it) {
      return (typeof it === 'undefined' ? 'undefined' : (0, _typeof6.default)(it)) == 'symbol';
    } : function (it) {
      return it instanceof $Symbol;
    };

    var $defineProperty = function defineProperty(it, key, D) {
      if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
      anObject(it);
      key = toPrimitive(key, true);
      anObject(D);
      if (has(AllSymbols, key)) {
        if (!D.enumerable) {
          if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
          it[HIDDEN][key] = true;
        } else {
          if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
          D = _create(D, { enumerable: createDesc(0, false) });
        }return setSymbolDesc(it, key, D);
      }return dP(it, key, D);
    };
    var $defineProperties = function defineProperties(it, P) {
      anObject(it);
      var keys = enumKeys(P = toIObject(P)),
          i = 0,
          l = keys.length,
          key;
      while (l > i) {
        $defineProperty(it, key = keys[i++], P[key]);
      }return it;
    };
    var $create = function create(it, P) {
      return P === undefined ? _create(it) : $defineProperties(_create(it), P);
    };
    var $propertyIsEnumerable = function propertyIsEnumerable(key) {
      var E = isEnum.call(this, key = toPrimitive(key, true));
      if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
      return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
    };
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
      it = toIObject(it);
      key = toPrimitive(key, true);
      if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
      var D = gOPD(it, key);
      if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
      return D;
    };
    var $getOwnPropertyNames = function getOwnPropertyNames(it) {
      var names = gOPN(toIObject(it)),
          result = [],
          i = 0,
          key;
      while (names.length > i) {
        if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
      }return result;
    };
    var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
      var IS_OP = it === ObjectProto,
          names = gOPN(IS_OP ? OPSymbols : toIObject(it)),
          result = [],
          i = 0,
          key;
      while (names.length > i) {
        if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
      }return result;
    };

    if (!USE_NATIVE) {
      $Symbol = function _Symbol2() {
        if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
        var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
        var $set = function $set(value) {
          if (this === ObjectProto) $set.call(OPSymbols, value);
          if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
          setSymbolDesc(this, tag, createDesc(1, value));
        };
        if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
        return wrap(tag);
      };
      redefine($Symbol[PROTOTYPE], 'toString', function toString() {
        return this._k;
      });

      $GOPD.f = $getOwnPropertyDescriptor;
      $DP.f = $defineProperty;
      __webpack_require__(57).f = gOPNExt.f = $getOwnPropertyNames;
      __webpack_require__(34).f = $propertyIsEnumerable;
      __webpack_require__(58).f = $getOwnPropertySymbols;

      if (DESCRIPTORS && !__webpack_require__(33)) {
        redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
      }

      wksExt.f = function (name) {
        return wrap(wks(name));
      };
    }

    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

    for (var symbols = 'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), i = 0; symbols.length > i;) {
      wks(symbols[i++]);
    }for (var symbols = $keys(wks.store), i = 0; symbols.length > i;) {
      wksDefine(symbols[i++]);
    }$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
      'for': function _for(key) {
        return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
      },

      keyFor: function keyFor(key) {
        if (isSymbol(key)) return keyOf(SymbolRegistry, key);
        throw TypeError(key + ' is not a symbol!');
      },
      useSetter: function useSetter() {
        setter = true;
      },
      useSimple: function useSimple() {
        setter = false;
      }
    });

    $export($export.S + $export.F * !USE_NATIVE, 'Object', {
      create: $create,

      defineProperty: $defineProperty,

      defineProperties: $defineProperties,

      getOwnPropertyDescriptor: $getOwnPropertyDescriptor,

      getOwnPropertyNames: $getOwnPropertyNames,

      getOwnPropertySymbols: $getOwnPropertySymbols
    });

    $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
      var S = $Symbol();

      return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
    })), 'JSON', {
      stringify: function stringify(it) {
        if (it === undefined || isSymbol(it)) return;
        var args = [it],
            i = 1,
            replacer,
            $replacer;
        while (arguments.length > i) {
          args.push(arguments[i++]);
        }replacer = args[1];
        if (typeof replacer == 'function') $replacer = replacer;
        if ($replacer || !isArray(replacer)) replacer = function replacer(key, value) {
          if ($replacer) value = $replacer.call(this, key, value);
          if (!isSymbol(value)) return value;
        };
        args[1] = replacer;
        return _stringify.apply($JSON, args);
      }
    });

    $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(9)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);

    setToStringTag($Symbol, 'Symbol');

    setToStringTag(Math, 'Math', true);

    setToStringTag(global.JSON, 'JSON', true);
  }, function (module, exports, __webpack_require__) {

    __webpack_require__(40)('asyncIterator');
  }, function (module, exports, __webpack_require__) {

    __webpack_require__(40)('observable');
  }, function (module, exports, __webpack_require__) {

    __webpack_require__(156);
    var global = __webpack_require__(4),
        hide = __webpack_require__(9),
        Iterators = __webpack_require__(32),
        TO_STRING_TAG = __webpack_require__(10)('toStringTag');

    for (var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++) {
      var NAME = collections[i],
          Collection = global[NAME],
          proto = Collection && Collection.prototype;
      if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
      Iterators[NAME] = Iterators.Array;
    }
  }, function (module, exports, __webpack_require__) {

    "use strict";

    var isObj = __webpack_require__(205);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
      if (val === null || val === undefined) {
        throw new TypeError('Sources cannot be null or undefined');
      }

      return Object(val);
    }

    function assignKey(to, from, key) {
      var val = from[key];

      if (val === undefined || val === null) {
        return;
      }

      if (hasOwnProperty.call(to, key)) {
        if (to[key] === undefined || to[key] === null) {
          throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
        }
      }

      if (!hasOwnProperty.call(to, key) || !isObj(val)) {
        to[key] = val;
      } else {
        to[key] = assign(Object(to[key]), from[key]);
      }
    }

    function assign(to, from) {
      if (to === from) {
        return to;
      }

      from = Object(from);

      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          assignKey(to, from, key);
        }
      }

      if (_getOwnPropertySymbols2.default) {
        var symbols = (0, _getOwnPropertySymbols2.default)(from);

        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            assignKey(to, from, symbols[i]);
          }
        }
      }

      return to;
    }

    module.exports = function deepAssign(target) {
      target = toObject(target);

      for (var s = 1; s < arguments.length; s++) {
        assign(target, arguments[s]);
      }

      return target;
    };
  }, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {}, function (module, exports, __webpack_require__) {

    "use strict";

    module.exports = function (x) {
      var type = typeof x === 'undefined' ? 'undefined' : (0, _typeof6.default)(x);
      return x !== null && (type === 'object' || type === 'function');
    };
  }, function (module, exports, __webpack_require__) {
    (function (global) {
      var FUNC_ERROR_TEXT = 'Expected a function';

      var NAN = 0 / 0;

      var symbolTag = '[object Symbol]';

      var reTrim = /^\s+|\s+$/g;

      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      var reIsBinary = /^0b[01]+$/i;

      var reIsOctal = /^0o[0-7]+$/i;

      var freeParseInt = parseInt;

      var freeGlobal = (typeof global === 'undefined' ? 'undefined' : (0, _typeof6.default)(global)) == 'object' && global && global.Object === Object && global;

      var freeSelf = (typeof self === 'undefined' ? 'undefined' : (0, _typeof6.default)(self)) == 'object' && self && self.Object === Object && self;

      var root = freeGlobal || freeSelf || Function('return this')();

      var objectProto = Object.prototype;

      var objectToString = objectProto.toString;

      var nativeMax = Math.max,
          nativeMin = Math.min;

      var now = function now() {
        return root.Date.now();
      };

      function debounce(func, wait, options) {
        var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
          var args = lastArgs,
              thisArg = lastThis;

          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }

        function leadingEdge(time) {
          lastInvokeTime = time;

          timerId = setTimeout(timerExpired, wait);

          return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              result = wait - timeSinceLastCall;

          return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

          return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }

        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }

          timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
          timerId = undefined;

          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }

        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }

        function debounced() {
          var time = now(),
              isInvoking = shouldInvoke(time);

          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      function isObject(value) {
        var type = typeof value === 'undefined' ? 'undefined' : (0, _typeof6.default)(value);
        return !!value && (type == 'object' || type == 'function');
      }

      function isObjectLike(value) {
        return !!value && (typeof value === 'undefined' ? 'undefined' : (0, _typeof6.default)(value)) == 'object';
      }

      function isSymbol(value) {
        return (typeof value === 'undefined' ? 'undefined' : (0, _typeof6.default)(value)) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }

      function toNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
          value = isObject(other) ? other + '' : other;
        }
        if (typeof value != 'string') {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, '');
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }

      module.exports = debounce;
    }).call(exports, __webpack_require__(255));
  }, function (module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

    (function (root, factory) {
      if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(62), __webpack_require__(63)], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else if ((typeof exports === 'undefined' ? 'undefined' : (0, _typeof6.default)(exports)) === 'object') {
        module.exports = factory(require('tether-drop'), require('tether'));
      } else {
        root.Tooltip = factory(root.Drop, root.Tether);
      }
    })(this, function (Drop, Tether) {

      'use strict';

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;(0, _defineProperty5.default)(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function');
        }
      }

      var extend = Tether.Utils.extend;

      var _Drop = Drop.createContext({
        classPrefix: 'tooltip'
      });

      var defaults = {
        position: 'top center',
        openOn: 'hover',
        classes: 'tooltip-theme-arrows',
        constrainToWindow: true,
        constrainToScrollParent: false
      };

      var tooltipCount = 0;

      var Tooltip = function () {
        function Tooltip(options) {
          _classCallCheck(this, Tooltip);

          this.options = options;

          if (!this.options.target) {
            throw new Error('Tooltip Error: You must provide a target for Tooltip to attach to');
          }

          var position = this.options.target.getAttribute('data-tooltip-position');
          if (position) {
            if (typeof this.options.position === 'undefined') {
              this.options.position = position;
            }
          }

          var content = this.options.target.getAttribute('data-tooltip');

          if (content) {
            if (typeof this.options.content === 'undefined') {
              var contentEl = document.createElement('div');
              contentEl.innerHTML = content;

              contentEl.setAttribute('role', 'tooltip');
              contentEl.id = 'drop-tooltip-' + tooltipCount;
              this.options.target.setAttribute('aria-describedby', contentEl.id);
              tooltipCount += 1;

              this.options.content = contentEl;
            }
          }

          if (!this.options.content) {
            throw new Error('Tooltip Error: You must provide content for Tooltip to display');
          }

          this.options = extend({}, defaults, this.options);

          this.drop = new _Drop(this.options);
        }

        _createClass(Tooltip, [{
          key: 'close',
          value: function close() {
            this.drop.close();
          }
        }, {
          key: 'open',
          value: function open() {
            this.drop.open();
          }
        }, {
          key: 'toggle',
          value: function toggle() {
            this.drop.toggle();
          }
        }, {
          key: 'remove',
          value: function remove() {
            this.drop.remove();
          }
        }, {
          key: 'destroy',
          value: function destroy() {
            this.drop.destroy();
          }
        }, {
          key: 'position',
          value: function position() {
            this.drop.position();
          }
        }]);

        return Tooltip;
      }();

      var initialized = [];

      Tooltip.init = function () {
        var tooltipElements = document.querySelectorAll('[data-tooltip]');
        var len = tooltipElements.length;
        for (var i = 0; i < len; ++i) {
          var el = tooltipElements[i];
          if (initialized.indexOf(el) === -1) {
            new Tooltip({
              target: el
            });
            initialized.push(el);
          }
        }
      };

      document.addEventListener('DOMContentLoaded', function () {
        if (Tooltip.autoinit !== false) {
          Tooltip.init();
        }
      });
      return Tooltip;
    });
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(184);

    var Component = __webpack_require__(0)(__webpack_require__(88), __webpack_require__(234), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiAutocompleteSuggestion.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiAutocompleteSuggestion.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-5073a83d", Component.options);
        } else {
          hotAPI.reload("data-v-5073a83d", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(168);

    var Component = __webpack_require__(0)(__webpack_require__(91), __webpack_require__(218), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiCalendarControls.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiCalendarControls.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-13f9ff05", Component.options);
        } else {
          hotAPI.reload("data-v-13f9ff05", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(175);

    var Component = __webpack_require__(0)(__webpack_require__(92), __webpack_require__(225), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiCalendarMonth.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiCalendarMonth.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-2932507e", Component.options);
        } else {
          hotAPI.reload("data-v-2932507e", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(188);

    var Component = __webpack_require__(0)(__webpack_require__(93), __webpack_require__(238), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiCalendarWeek.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiCalendarWeek.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-60cc7cc3", Component.options);
        } else {
          hotAPI.reload("data-v-60cc7cc3", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(191);

    var Component = __webpack_require__(0)(__webpack_require__(105), __webpack_require__(241), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiMenuOption.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiMenuOption.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-6515e465", Component.options);
        } else {
          hotAPI.reload("data-v-6515e465", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(177);

    var Component = __webpack_require__(0)(__webpack_require__(115), __webpack_require__(227), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiSelectOption.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiSelectOption.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-2ea40182", Component.options);
        } else {
          hotAPI.reload("data-v-2ea40182", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {
    __webpack_require__(178);

    var Component = __webpack_require__(0)(__webpack_require__(121), __webpack_require__(228), null, null);
    Component.options.__file = 'C:\\code\\packages\\keen-ui\\src\\UiTabHeaderItem.vue';
    if (Component.esModule && (0, _keys2.default)(Component.esModule).some(function (key) {
      return key !== "default" && key !== "__esModule";
    })) {
      console.error("named exports are not supported in *.vue files.");
    }
    if (Component.options.functional) {
      console.error("[vue-loader] UiTabHeaderItem.vue: functional components are not supported with templates, they should use render functions.");
    }

    if (false) {
      (function () {
        var hotAPI = require("vue-hot-reload-api");
        hotAPI.install(require("vue"), false);
        if (!hotAPI.compatible) return;
        module.hot.accept();
        if (!module.hot.data) {
          hotAPI.createRecord("data-v-31ca5114", Component.options);
        } else {
          hotAPI.reload("data-v-31ca5114", Component.options);
        }
      })();
    }

    module.exports = Component.exports;
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('transition', {
          attrs: {
            "name": "ui-alert--transition-toggle"
          }
        }, [_vm._c('div', {
          staticClass: "ui-alert",
          class: _vm.classes,
          attrs: {
            "role": "alert"
          }
        }, [_vm._c('div', {
          staticClass: "ui-alert__body"
        }, [!_vm.removeIcon ? _vm._c('div', {
          staticClass: "ui-alert__icon"
        }, [_vm._t("icon", [_vm.type === 'info' ? _vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M12.984 9V6.984h-1.97V9h1.97zm0 8.016v-6h-1.97v6h1.97zm-.984-15c5.53 0 9.984 4.453 9.984 9.984S17.53 21.984 12 21.984 2.016 17.53 2.016 12 6.47 2.016 12 2.016z"
          }
        })])]) : _vm._e(), _vm._v(" "), _vm.type === 'success' ? _vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M9.984 17.016l9-9-1.406-1.453-7.594 7.594-3.563-3.563L5.016 12zm2.016-15c5.53 0 9.984 4.453 9.984 9.984S17.53 21.984 12 21.984 2.016 17.53 2.016 12 6.47 2.016 12 2.016z"
          }
        })])]) : _vm._e(), _vm._v(" "), _vm.type === 'warning' ? _vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M12.984 14.016v-4.03h-1.97v4.03h1.97zm0 3.984v-2.016h-1.97V18h1.97zm-12 3L12 2.016 23.016 21H.986z"
          }
        })])]) : _vm._e(), _vm._v(" "), _vm.type === 'error' ? _vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M12.984 12.984v-6h-1.97v6h1.97zm0 4.032V15h-1.97v2.016h1.97zm-.984-15c5.53 0 9.984 4.453 9.984 9.984S17.53 21.984 12 21.984 2.016 17.53 2.016 12 6.47 2.016 12 2.016z"
          }
        })])]) : _vm._e()])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-alert__content"
        }, [_vm._t("default")], 2), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-alert__dismiss-button"
        }, [_vm.dismissible ? _vm._c('ui-close-button', {
          attrs: {
            "size": "small"
          },
          on: {
            "click": _vm.dismissAlert
          }
        }) : _vm._e()], 1)])])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-019a858a", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-autocomplete",
          class: _vm.classes
        }, [_vm.icon || _vm.$slots.icon ? _vm._c('div', {
          staticClass: "ui-autocomplete__icon-wrapper"
        }, [_vm._t("icon", [_vm._c('ui-icon', {
          attrs: {
            "icon": _vm.icon
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-autocomplete__content"
        }, [_vm._c('label', {
          staticClass: "ui-autocomplete__label"
        }, [_vm.label || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-autocomplete__label-text",
          class: _vm.labelClasses
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), _vm._c('ui-icon', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: !_vm.disabled && _vm.value.length,
            expression: "!disabled && value.length"
          }],
          staticClass: "ui-autocomplete__clear-button",
          attrs: {
            "title": "Clear"
          },
          nativeOn: {
            "click": function click($event) {
              _vm.updateValue('');
            }
          }
        }, [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M18.984 6.422L13.406 12l5.578 5.578-1.406 1.406L12 13.406l-5.578 5.578-1.406-1.406L10.594 12 5.016 6.422l1.406-1.406L12 10.594l5.578-5.578z"
          }
        })])]), _vm._v(" "), _vm._c('input', {
          directives: [{
            name: "autofocus",
            rawName: "v-autofocus",
            value: _vm.autofocus,
            expression: "autofocus"
          }],
          ref: "input",
          staticClass: "ui-autocomplete__input",
          attrs: {
            "autocomplete": "off",
            "disabled": _vm.disabled,
            "name": _vm.name,
            "placeholder": _vm.hasFloatingLabel ? null : _vm.placeholder,
            "readonly": _vm.readonly ? _vm.readonly : null
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "blur": _vm.onBlur,
            "change": _vm.onChange,
            "focus": _vm.onFocus,
            "input": function input($event) {
              _vm.updateValue($event.target.value);
            },
            "keydown": [function ($event) {
              if (_vm._k($event.keyCode, "down", 40)) {
                return;
              }
              $event.preventDefault();
              _vm.highlightSuggestion(_vm.highlightedIndex + 1);
            }, function ($event) {
              if (_vm._k($event.keyCode, "enter", 13)) {
                return;
              }
              _vm.selectHighlighted(_vm.highlightedIndex, $event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "esc", 27)) {
                return;
              }
              _vm.closeDropdown($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "tab", 9)) {
                return;
              }
              _vm.closeDropdown($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "up", 38)) {
                return;
              }
              $event.preventDefault();
              _vm.highlightSuggestion(_vm.highlightedIndex - 1);
            }]
          }
        }), _vm._v(" "), _vm._c('ul', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.showDropdown,
            expression: "showDropdown"
          }],
          staticClass: "ui-autocomplete__suggestions"
        }, _vm._l(_vm.matchingSuggestions, function (suggestion, index) {
          return _vm._c('ui-autocomplete-suggestion', {
            ref: "suggestions",
            refInFor: true,
            attrs: {
              "highlighted": _vm.highlightedIndex === index,
              "keys": _vm.keys,
              "suggestion": suggestion,
              "type": _vm.type
            },
            nativeOn: {
              "click": function click($event) {
                _vm.selectSuggestion(suggestion);
              }
            }
          }, [_vm._t("suggestion", null, {
            highlighted: _vm.highlightedIndex === index,
            index: index,
            suggestion: suggestion
          })], 2);
        }))], 1), _vm._v(" "), _vm.hasFeedback ? _vm._c('div', {
          staticClass: "ui-autocomplete__feedback"
        }, [_vm.showError ? _vm._c('div', {
          staticClass: "ui-autocomplete__feedback-text"
        }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _vm._c('div', {
          staticClass: "ui-autocomplete__feedback-text"
        }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e()]) : _vm._e()])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-049f1d4e", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-radio-group",
          class: _vm.classes
        }, [_vm.label || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-radio-group__label-text"
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-radio-group__radios"
        }, _vm._l(_vm.options, function (option) {
          return _vm._c('ui-radio', {
            directives: [{
              name: "model",
              rawName: "v-model",
              value: _vm.selectedOptionValue,
              expression: "selectedOptionValue"
            }],
            key: option[_vm.keys.id],
            staticClass: "ui-radio-group__radio",
            class: option[_vm.keys.class],
            attrs: {
              "button-position": _vm.buttonPosition,
              "checked": _vm.isOptionCheckedByDefault(option),
              "color": _vm.color,
              "disabled": _vm.disabled || option[_vm.keys.disabled],
              "id": option[_vm.keys.id],
              "name": _vm.name,
              "true-value": option[_vm.keys.value] || option
            },
            domProps: {
              "value": _vm.selectedOptionValue
            },
            on: {
              "blur": _vm.onBlur,
              "focus": _vm.onFocus,
              "input": function input($event) {
                _vm.selectedOptionValue = $event;
              }
            }
          }, [_vm._v(_vm._s(option[_vm.keys.label] || option))]);
        })), _vm._v(" "), _vm.hasFeedback ? _vm._c('div', {
          staticClass: "ui-radio-group__feedback"
        }, [_vm.showError ? _vm._c('div', {
          staticClass: "ui-radio-group__feedback-text"
        }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _vm._c('div', {
          staticClass: "ui-radio-group__feedback-text"
        }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e()]) : _vm._e()]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-0eea8cf5", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-calendar-controls"
        }, [_vm._c('ui-icon-button', {
          staticClass: "ui-calendar-controls__nav-button",
          attrs: {
            "icon": "keyboard_arrow_left",
            "type": "secondary",
            "disabled": _vm.previousMonthDisabled
          },
          on: {
            "click": _vm.goToPreviousMonth
          }
        }, [_vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M15.422 16.078l-1.406 1.406-6-6 6-6 1.406 1.406-4.594 4.594z"
          }
        })])])], 1), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-calendar-controls__month-and-year"
        }, [_vm._v(_vm._s(_vm.monthAndYear))]), _vm._v(" "), _vm._c('ui-icon-button', {
          staticClass: "ui-calendar-controls__nav-button",
          attrs: {
            "icon": "keyboard_arrow_right",
            "type": "secondary",
            "disabled": _vm.nextMonthDisabled
          },
          on: {
            "click": _vm.goToNextMonth
          }
        }, [_vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M8.578 16.36l4.594-4.595L8.578 7.17l1.406-1.405 6 6-6 6z"
          }
        })])])], 1)], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-13f9ff05", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-select",
          class: _vm.classes
        }, [_vm.name ? _vm._c('input', {
          staticClass: "ui-select__hidden-input",
          attrs: {
            "type": "hidden",
            "name": _vm.name
          },
          domProps: {
            "value": _vm.submittedValue
          }
        }) : _vm._e(), _vm._v(" "), _vm.icon || _vm.$slots.icon ? _vm._c('div', {
          staticClass: "ui-select__icon-wrapper"
        }, [_vm._t("icon", [_vm._c('ui-icon', {
          attrs: {
            "icon": _vm.icon
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-select__content"
        }, [_vm._c('div', {
          ref: "label",
          staticClass: "ui-select__label",
          attrs: {
            "tabindex": _vm.disabled ? null : '0'
          },
          on: {
            "click": _vm.toggleDropdown,
            "focus": _vm.onFocus,
            "keydown": [function ($event) {
              if (_vm._k($event.keyCode, "enter", 13)) {
                return;
              }
              $event.preventDefault();
              _vm.openDropdown($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "space", 32)) {
                return;
              }
              $event.preventDefault();
              _vm.openDropdown($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "tab", 9)) {
                return;
              }
              _vm.onBlur($event);
            }]
          }
        }, [_vm.label || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-select__label-text",
          class: _vm.labelClasses
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-select__display"
        }, [_vm._c('div', {
          staticClass: "ui-select__display-value",
          class: {
            'is-placeholder': !_vm.hasDisplayText
          }
        }, [_vm._v("\n                    " + _vm._s(_vm.hasDisplayText ? _vm.displayText : _vm.hasFloatingLabel && _vm.isLabelInline ? null : _vm.placeholder) + "\n                ")]), _vm._v(" "), _vm._c('ui-icon', {
          staticClass: "ui-select__dropdown-button"
        }, [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M6.984 9.984h10.03L12 15z"
          }
        })])])], 1), _vm._v(" "), _vm._c('transition', {
          attrs: {
            "name": "ui-select--transition-fade"
          }
        }, [_vm._c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.showDropdown,
            expression: "showDropdown"
          }],
          ref: "dropdown",
          staticClass: "ui-select__dropdown",
          attrs: {
            "tabindex": "-1"
          },
          on: {
            "keydown": [function ($event) {
              if (_vm._k($event.keyCode, "down", 40)) {
                return;
              }
              $event.preventDefault();
              _vm.highlightOption(_vm.highlightedIndex + 1);
            }, function ($event) {
              if (_vm._k($event.keyCode, "enter", 13)) {
                return;
              }
              $event.preventDefault();
              $event.stopPropagation();
              _vm.selectHighlighted(_vm.highlightedIndex, $event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "esc", 27)) {
                return;
              }
              $event.preventDefault();
              _vm.closeDropdown();
            }, function ($event) {
              if (_vm._k($event.keyCode, "tab", 9)) {
                return;
              }
              _vm.onBlur($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "up", 38)) {
                return;
              }
              $event.preventDefault();
              _vm.highlightOption(_vm.highlightedIndex - 1);
            }]
          }
        }, [_vm.hasSearch ? _vm._c('div', {
          staticClass: "ui-select__search",
          on: {
            "click": function click($event) {
              $event.stopPropagation();
            },
            "keydown": function keydown($event) {
              if (_vm._k($event.keyCode, "space", 32)) {
                return;
              }
              $event.stopPropagation();
            }
          }
        }, [_vm._c('input', {
          directives: [{
            name: "model",
            rawName: "v-model",
            value: _vm.query,
            expression: "query"
          }],
          ref: "searchInput",
          staticClass: "ui-select__search-input",
          attrs: {
            "autocomplete": "off",
            "type": "text",
            "placeholder": _vm.searchPlaceholder
          },
          domProps: {
            "value": _vm._s(_vm.query)
          },
          on: {
            "input": function input($event) {
              if ($event.target.composing) {
                return;
              }
              _vm.query = $event.target.value;
            }
          }
        }), _vm._v(" "), _vm._c('ui-icon', {
          staticClass: "ui-select__search-icon"
        }, [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M9.516 14.016c2.484 0 4.5-2.016 4.5-4.5s-2.016-4.5-4.5-4.5-4.5 2.016-4.5 4.5 2.016 4.5 4.5 4.5zm6 0l4.97 4.97-1.5 1.5-4.97-4.97v-.797l-.28-.282c-1.126.984-2.626 1.547-4.22 1.547-3.61 0-6.516-2.86-6.516-6.47S5.906 3 9.516 3s6.47 2.906 6.47 6.516c0 1.594-.564 3.094-1.548 4.22l.28.28h.798z"
          }
        })])]), _vm._v(" "), _vm._c('ui-progress-circular', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.loading,
            expression: "loading"
          }],
          staticClass: "ui-select__search-progress",
          attrs: {
            "size": 20,
            "stroke": 4
          }
        })], 1) : _vm._e(), _vm._v(" "), _vm._c('ul', {
          ref: "optionsList",
          staticClass: "ui-select__options"
        }, [_vm._l(_vm.filteredOptions, function (option, index) {
          return _vm._c('ui-select-option', {
            ref: "options",
            refInFor: true,
            attrs: {
              "highlighted": _vm.highlightedIndex === index,
              "keys": _vm.keys,
              "multiple": _vm.multiple,
              "option": option,
              "selected": _vm.isOptionSelected(option),
              "type": _vm.type
            },
            nativeOn: {
              "click": function click($event) {
                $event.stopPropagation();
                _vm.selectOption(option, index);
              },
              "mouseover": function mouseover($event) {
                $event.stopPropagation();
                _vm.highlightOption(index, {
                  autoScroll: false
                });
              }
            }
          }, [_vm._t("option", null, {
            highlighted: _vm.highlightedIndex === index,
            index: index,
            option: option,
            selected: _vm.isOptionSelected(option)
          })], 2);
        }), _vm._v(" "), _vm._c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.hasNoResults,
            expression: "hasNoResults"
          }],
          staticClass: "ui-select__no-results"
        }, [_vm._t("no-results", [_vm._v("No results found")])], 2)], 2)])])], 1), _vm._v(" "), _vm.hasFeedback ? _vm._c('div', {
          staticClass: "ui-select__feedback"
        }, [_vm.showError ? _vm._c('div', {
          staticClass: "ui-select__feedback-text"
        }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _vm._c('div', {
          staticClass: "ui-select__feedback-text"
        }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e()]) : _vm._e()])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-149e632d", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-ripple-ink"
        });
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-14e906f5", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-calendar",
          class: _vm.classes
        }, [_vm._c('div', {
          staticClass: "ui-calendar__header"
        }, [_vm._c('div', {
          staticClass: "ui-calendar__header-year",
          class: {
            'is-active': _vm.showYearPicker
          },
          attrs: {
            "tabindex": "0"
          },
          on: {
            "click": function click($event) {
              _vm.showYearPicker = true;
            },
            "keydown": function keydown($event) {
              if (_vm._k($event.keyCode, "enter", 13)) {
                return;
              }
              _vm.showYearPicker = true;
            }
          }
        }, [_vm._v(_vm._s(_vm.headerYear))]), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-calendar__header-details",
          class: {
            'is-active': !_vm.showYearPicker
          },
          attrs: {
            "tabindex": "0"
          },
          on: {
            "click": function click($event) {
              _vm.showYearPicker = false;
            },
            "keydown": function keydown($event) {
              if (_vm._k($event.keyCode, "enter", 13)) {
                return;
              }
              _vm.showYearPicker = false;
            }
          }
        }, [_vm._c('span', {
          staticClass: "ui-calendar__header-day"
        }, [_vm._v(_vm._s(_vm.headerDay) + ", ")]), _vm._v(" "), _vm._c('span', {
          staticClass: "ui-calendar__header-date"
        }, [_vm._v(_vm._s(_vm.headerDate))])])]), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-calendar__body"
        }, [_vm._c('ul', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.showYearPicker,
            expression: "showYearPicker"
          }],
          ref: "years",
          staticClass: "ui-calendar__years"
        }, _vm._l(_vm.yearRange, function (year) {
          return !_vm.isYearOutOfRange(year) ? _vm._c('li', {
            staticClass: "ui-calendar__year",
            class: _vm.getYearClasses(year),
            attrs: {
              "tabindex": "0"
            },
            on: {
              "click": function click($event) {
                _vm.selectYear(year);
              },
              "keydown": function keydown($event) {
                if (_vm._k($event.keyCode, "enter", 13)) {
                  return;
                }
                _vm.selectYear(year);
              }
            }
          }, [_vm._v(_vm._s(year))]) : _vm._e();
        })), _vm._v(" "), _vm._c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: !_vm.showYearPicker,
            expression: "!showYearPicker"
          }]
        }, [_vm._c('ui-calendar-controls', {
          ref: "controls",
          attrs: {
            "date-in-view": _vm.dateInView,
            "lang": _vm.lang,
            "max-date": _vm.maxDate,
            "min-date": _vm.minDate
          },
          on: {
            "go-to-date": _vm.onGoToDate
          }
        }), _vm._v(" "), _vm._c('ui-calendar-month', {
          ref: "month",
          attrs: {
            "date-filter": _vm.dateFilter,
            "date-in-view": _vm.dateInView,
            "lang": _vm.lang,
            "max-date": _vm.maxDate,
            "min-date": _vm.minDate,
            "selected": _vm.value
          },
          on: {
            "change": _vm.onMonthChange,
            "date-select": _vm.onDateSelect
          }
        })], 1), _vm._v(" "), _vm.$slots.footer ? _vm._c('div', {
          staticClass: "ui-calendar__footer"
        }, [_vm._t("footer")], 2) : _vm._e()])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-16dd362f", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('label', {
          staticClass: "ui-radio",
          class: _vm.classes,
          on: {
            "click": _vm.toggleCheck
          }
        }, [_vm._c('div', {
          staticClass: "ui-radio__input-wrapper"
        }, [_vm._c('input', {
          staticClass: "ui-radio__input",
          attrs: {
            "type": "radio",
            "disabled": _vm.disabled,
            "name": _vm.name
          },
          domProps: {
            "value": _vm.trueValue
          },
          on: {
            "blur": _vm.onBlur,
            "change": _vm.onChange,
            "focus": _vm.onFocus
          }
        }), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-radio__focus-ring"
        }), _vm._v(" "), _vm._c('span', {
          staticClass: "ui-radio__outer-circle"
        }), _vm._v(" "), _vm._c('span', {
          staticClass: "ui-radio__inner-circle"
        })]), _vm._v(" "), _vm.label || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-radio__label-text"
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-1c88e05a", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-snackbar-container",
          class: _vm.classes
        }, _vm._l(_vm.queue, function (snackbar, index) {
          return _vm._c('ui-snackbar', {
            directives: [{
              name: "show",
              rawName: "v-show",
              value: snackbar.show,
              expression: "snackbar.show"
            }],
            attrs: {
              "action-color": snackbar.actionColor,
              "action": snackbar.action,
              "message": snackbar.message,
              "transition": _vm.transition
            },
            on: {
              "action-click": function actionClick($event) {
                _vm.onActionClick(snackbar);
              },
              "click": function click($event) {
                _vm.onClick(snackbar);
              },
              "hide": function hide($event) {
                _vm.onHide(snackbar, index);
              },
              "show": function show($event) {
                _vm.onShow(snackbar);
              }
            }
          }, [_vm.allowHtml ? _vm._c('div', {
            domProps: {
              "innerHTML": _vm._s(snackbar.message)
            }
          }) : _vm._e()]);
        }));
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-1daceb4a", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('transition', {
          attrs: {
            "name": _vm.disableTransition ? null : 'ui-progress-circular--transition-fade'
          }
        }, [_vm._c('div', {
          staticClass: "ui-progress-circular",
          class: _vm.classes,
          style: {
            'width': _vm.size + 'px',
            'height': _vm.size + 'px'
          }
        }, [_vm.type === 'determinate' ? _vm._c('svg', {
          staticClass: "ui-progress-circular__determinate",
          attrs: {
            "role": "progressbar",
            "aria-valuemax": 100,
            "aria-valuemin": 0,
            "aria-valuenow": _vm.progress,
            "height": _vm.size,
            "width": _vm.size
          }
        }, [_vm._c('circle', {
          staticClass: "ui-progress-circular__determinate-path",
          style: {
            'stroke-dashoffset': _vm.strokeDashOffset,
            'stroke-width': _vm.calculatedStroke
          },
          attrs: {
            "fill": "transparent",
            "stroke-dashoffset": "0",
            "cx": _vm.size / 2,
            "cy": _vm.size / 2,
            "r": _vm.radius,
            "stroke-dasharray": _vm.strokeDashArray
          }
        })]) : _vm._c('svg', {
          staticClass: "ui-progress-circular__indeterminate",
          attrs: {
            "role": "progressbar",
            "viewBox": "25 25 50 50",
            "aria-valuemax": 100,
            "aria-valuemin": 0
          }
        }, [_vm._c('circle', {
          staticClass: "ui-progress-circular__indeterminate-path",
          attrs: {
            "cx": "50",
            "cy": "50",
            "fill": "none",
            "r": "20",
            "stroke-miterlimit": "10",
            "stroke-width": _vm.calculatedStroke
          }
        })])])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-20257add", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-calendar-month"
        }, [_vm._c('div', {
          staticClass: "ui-calendar-month__header"
        }, _vm._l(_vm.lang.days.initials, function (day) {
          return _vm._c('span', [_vm._v(_vm._s(day))]);
        })), _vm._v(" "), _vm._c('div', {
          ref: "current",
          staticClass: "ui-calendar-month__week is-current",
          class: _vm.weekClasses,
          on: {
            "transitionend": _vm.onTransitionEnd
          }
        }, _vm._l(_vm.currentWeekStartDates, function (date, index) {
          return _vm._c('ui-calendar-week', {
            key: index,
            attrs: {
              "date-filter": _vm.dateFilter,
              "max-date": _vm.maxDate,
              "min-date": _vm.minDate,
              "month": _vm.currentWeekStartDates[1].getMonth(),
              "selected": _vm.selected,
              "week-start": date
            },
            on: {
              "date-select": _vm.onDateSelect
            }
          });
        })), _vm._v(" "), _vm._c('div', {
          ref: "other",
          staticClass: "ui-calendar-month__week is-other",
          class: _vm.weekClasses
        }, _vm._l(_vm.otherWeekStartDates, function (date, index) {
          return _vm._c('ui-calendar-week', {
            key: index,
            attrs: {
              "max-date": _vm.maxDate,
              "min-date": _vm.minDate,
              "month": _vm.otherWeekStartDates[1].getMonth(),
              "selected": _vm.selected,
              "visible": false,
              "week-start": date
            },
            on: {
              "date-select": _vm.onDateSelect
            }
          });
        }))]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-2932507e", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-preloader",
          class: {
            'is-loading': _vm.show
          }
        }, [_vm._c('div', {
          staticClass: "ui-preloader__progressbar",
          attrs: {
            "role": "progressbar",
            "aria-busy": _vm.show ? 'true' : false
          }
        })]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-2e7f9056", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('li', {
          staticClass: "ui-select-option",
          class: _vm.classes
        }, [_vm._t("default", [_vm.type === 'basic' ? _vm._c('div', {
          staticClass: "ui-select-option__basic"
        }, [_vm._v("\n            " + _vm._s(_vm.option[_vm.keys.label] || _vm.option) + "\n        ")]) : _vm._e(), _vm._v(" "), _vm.type === 'image' ? _vm._c('div', {
          staticClass: "ui-select-option__image"
        }, [_vm._c('div', {
          staticClass: "ui-select-option__image-object",
          style: _vm.imageStyle
        }), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-select-option__image-text"
        }, [_vm._v(_vm._s(_vm.option[_vm.keys.label]))])]) : _vm._e(), _vm._v(" "), _vm.multiple ? _vm._c('div', {
          staticClass: "ui-select-option__checkbox"
        }, [_vm.selected ? _vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M9.984 17.016l9-9-1.406-1.453-7.594 7.594-3.563-3.563L5.016 12zm9-14.016C20.11 3 21 3.938 21 5.016v13.97C21 20.062 20.11 21 18.984 21H5.014C3.89 21 3 20.064 3 18.986V5.015C3 3.94 3.89 3 5.014 3h13.97z"
          }
        })])]) : _vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M18.984 3C20.062 3 21 3.938 21 5.016v13.97C21 20.062 20.062 21 18.984 21H5.014C3.938 21 3 20.064 3 18.986V5.015C3 3.94 3.936 3 5.014 3h13.97zm0 2.016H5.014v13.97h13.97V5.015z"
          }
        })])])], 1) : _vm._e()])], 2);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-2ea40182", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('li', {
          ref: "headerItem",
          staticClass: "ui-tab-header-item",
          class: _vm.classes,
          attrs: {
            "role": "tab",
            "aria-controls": _vm.id,
            "aria-selected": _vm.active ? 'true' : null,
            "disabled": _vm.disabled,
            "tabindex": _vm.active ? 0 : -1
          }
        }, [_vm.type === 'icon' || _vm.type === 'icon-and-text' ? _vm._c('div', {
          staticClass: "ui-tab-header-item__icon"
        }, [_vm._t("icon", [_vm._c('ui-icon', {
          attrs: {
            "icon-set": _vm.iconProps.iconSet,
            "icon": _vm.icon,
            "remove-text": _vm.iconProps.removeText,
            "use-svg": _vm.iconProps.useSvg
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm.type === 'text' || _vm.type === 'icon-and-text' ? _vm._c('div', {
          staticClass: "ui-tab-header-item__text"
        }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm._v(" "), !_vm.disableRipple && !_vm.disabled ? _vm._c('ui-ripple-ink', {
          attrs: {
            "trigger": "headerItem"
          }
        }) : _vm._e()], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-31ca5114", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('transition', {
          attrs: {
            "name": "ui-progress-linear--transition-fade"
          }
        }, [_vm._c('div', {
          staticClass: "ui-progress-linear",
          class: _vm.classes
        }, [_vm.type === 'determinate' ? _vm._c('div', {
          staticClass: "ui-progress-linear__progress-bar is-determinate",
          style: {
            'transform': "scaleX(" + _vm.moderatedProgress / 100 + ")"
          },
          attrs: {
            "role": "progressbar",
            "aria-valuemax": 100,
            "aria-valuemin": 0,
            "aria-valuenow": _vm.moderatedProgress
          }
        }) : _vm._c('div', {
          staticClass: "ui-progress-linear__progress-bar is-indeterminate",
          attrs: {
            "role": "progressbar",
            "aria-valuemax": 100,
            "aria-valuemin": 0
          }
        })])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-363761e3", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-textbox",
          class: _vm.classes
        }, [_vm.icon || _vm.$slots.icon ? _vm._c('div', {
          staticClass: "ui-textbox__icon-wrapper"
        }, [_vm._t("icon", [_vm._c('ui-icon', {
          attrs: {
            "icon": _vm.icon
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-textbox__content"
        }, [_vm._c('label', {
          staticClass: "ui-textbox__label"
        }, [_vm.label || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-textbox__label-text",
          class: _vm.labelClasses
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), !_vm.multiLine ? _vm._c('input', {
          directives: [{
            name: "autofocus",
            rawName: "v-autofocus",
            value: _vm.autofocus,
            expression: "autofocus"
          }],
          ref: "input",
          staticClass: "ui-textbox__input",
          attrs: {
            "autocomplete": _vm.autocomplete ? _vm.autocomplete : null,
            "disabled": _vm.disabled,
            "max": _vm.maxValue,
            "maxlength": _vm.enforceMaxlength ? _vm.maxlength : null,
            "min": _vm.minValue,
            "name": _vm.name,
            "number": _vm.type === 'number' ? true : null,
            "placeholder": _vm.hasFloatingLabel ? null : _vm.placeholder,
            "readonly": _vm.readonly,
            "required": _vm.required,
            "step": _vm.stepValue,
            "type": _vm.type
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "blur": _vm.onBlur,
            "change": _vm.onChange,
            "focus": _vm.onFocus,
            "input": function input($event) {
              _vm.updateValue($event.target.value);
            },
            "keydown": [function ($event) {
              if (_vm._k($event.keyCode, "enter", 13)) {
                return;
              }
              _vm.onKeydownEnter($event);
            }, _vm.onKeydown]
          }
        }) : _vm._c('textarea', {
          directives: [{
            name: "autofocus",
            rawName: "v-autofocus",
            value: _vm.autofocus,
            expression: "autofocus"
          }],
          ref: "textarea",
          staticClass: "ui-textbox__textarea",
          attrs: {
            "autocomplete": _vm.autocomplete ? _vm.autocomplete : null,
            "disabled": _vm.disabled,
            "maxlength": _vm.enforceMaxlength ? _vm.maxlength : null,
            "name": _vm.name,
            "placeholder": _vm.hasFloatingLabel ? null : _vm.placeholder,
            "readonly": _vm.readonly,
            "required": _vm.required,
            "rows": _vm.rows
          },
          domProps: {
            "value": _vm.value
          },
          on: {
            "blur": _vm.onBlur,
            "change": _vm.onChange,
            "focus": _vm.onFocus,
            "input": function input($event) {
              _vm.updateValue($event.target.value);
            },
            "keydown": [function ($event) {
              if (_vm._k($event.keyCode, "enter", 13)) {
                return;
              }
              _vm.onKeydownEnter($event);
            }, _vm.onKeydown]
          }
        }, [_vm._v(_vm._s(_vm.value))])]), _vm._v(" "), _vm.hasFeedback || _vm.maxlength ? _vm._c('div', {
          staticClass: "ui-textbox__feedback"
        }, [_vm.showError ? _vm._c('div', {
          staticClass: "ui-textbox__feedback-text"
        }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _vm._c('div', {
          staticClass: "ui-textbox__feedback-text"
        }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e(), _vm._v(" "), _vm.maxlength ? _vm._c('div', {
          staticClass: "ui-textbox__counter"
        }, [_vm._v("\n                " + _vm._s(_vm.value.length + '/' + _vm.maxlength) + "\n            ")]) : _vm._e()]) : _vm._e()])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-3805aac6", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.show && _vm.isActive,
            expression: "show && isActive"
          }],
          staticClass: "ui-tab",
          attrs: {
            "role": "tabpanel",
            "aria-hidden": !_vm.isActive ? 'true' : null,
            "id": _vm.id,
            "tabindex": _vm.isActive ? '0' : null
          }
        }, [_vm._c('div', {
          staticStyle: {
            "display": "none"
          }
        }, [_vm._t("icon")], 2), _vm._v(" "), _vm._t("default")], 2);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-3cdc54b4", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-toolbar",
          class: _vm.classes
        }, [_vm._c('div', {
          staticClass: "ui-toolbar__left"
        }, [!_vm.removeNavIcon ? _vm._c('div', {
          staticClass: "ui-toolbar__nav-icon"
        }, [_vm._t("icon", [_vm._c('ui-icon-button', {
          attrs: {
            "size": "large",
            "type": "secondary",
            "color": _vm.textColor,
            "icon": _vm.navIcon
          },
          on: {
            "click": _vm.navIconClick
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm.brand || _vm.$slots.brand ? _vm._c('div', {
          staticClass: "ui-toolbar__brand"
        }, [_vm._t("brand", [_vm._c('div', {
          staticClass: "ui-toolbar__brand-text"
        }, [_vm._v(_vm._s(_vm.brand))])])], 2) : _vm._e()]), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-toolbar__body",
          class: {
            'has-brand-divider': _vm.hasBrandDivider
          }
        }, [_vm._t("default", [_vm.title ? _vm._c('div', {
          staticClass: "ui-toolbar__title"
        }, [_vm._v(_vm._s(_vm.title))]) : _vm._e()])], 2), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-toolbar__right"
        }, [_vm._t("actions")], 2), _vm._v(" "), _vm._c('ui-progress-linear', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.loading,
            expression: "loading"
          }],
          staticClass: "ui-toolbar__progress",
          attrs: {
            "color": _vm.progressColor
          }
        })], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-3d9c3bcc", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('transition', {
          attrs: {
            "name": _vm.transitionName
          },
          on: {
            "after-enter": _vm.onEnter,
            "after-leave": _vm.onLeave
          }
        }, [_vm._c('div', {
          staticClass: "ui-snackbar",
          on: {
            "click": _vm.onClick
          }
        }, [_vm._c('div', {
          staticClass: "ui-snackbar__message"
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.message))])], 2), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-snackbar__action"
        }, [_vm.action ? _vm._c('ui-button', {
          staticClass: "ui-snackbar__action-button",
          attrs: {
            "type": "secondary",
            "color": _vm.actionColor
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();
              _vm.onActionClick($event);
            }
          }
        }, [_vm._v(_vm._s(_vm.action))]) : _vm._e()], 1)])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-4f182f14", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('li', {
          staticClass: "ui-autocomplete-suggestion",
          class: _vm.classes
        }, [_vm._t("default", [_vm.type === 'simple' ? _vm._c('div', {
          staticClass: "ui-autocomplete-suggestion__simple"
        }, [_vm._v("\n            " + _vm._s(_vm.suggestion[_vm.keys.label] || _vm.suggestion) + "\n        ")]) : _vm._e(), _vm._v(" "), _vm.type === 'image' ? _vm._c('div', {
          staticClass: "ui-autocomplete-suggestion__image"
        }, [_vm._c('div', {
          staticClass: "ui-autocomplete-suggestion__image-object",
          style: _vm.imageStyle
        }), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-autocomplete-suggestion__image-text"
        }, [_vm._v(_vm._s(_vm.suggestion[_vm.keys.label]))])]) : _vm._e()])], 2);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-5073a83d", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('transition', {
          attrs: {
            "name": _vm.toggleTransition
          },
          on: {
            "after-enter": _vm.onEnter,
            "after-leave": _vm.onLeave
          }
        }, [_vm._c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.isOpen,
            expression: "isOpen"
          }],
          staticClass: "ui-modal ui-modal__mask",
          class: _vm.classes,
          attrs: {
            "role": _vm.role
          }
        }, [_vm._c('div', {
          ref: "backdrop",
          staticClass: "ui-modal__wrapper",
          class: {
            'has-dummy-scrollbar': _vm.preventShift
          },
          on: {
            "click": function click($event) {
              _vm.dismissOnBackdrop && _vm.closeModal($event);
            }
          }
        }, [_vm._c('div', {
          ref: "container",
          staticClass: "ui-modal__container",
          attrs: {
            "tabindex": "-1"
          },
          on: {
            "keydown": function keydown($event) {
              if (_vm._k($event.keyCode, "esc", 27)) {
                return;
              }
              _vm.dismissOnEsc && _vm.closeModal($event);
            }
          }
        }, [!_vm.removeHeader ? _vm._c('div', {
          staticClass: "ui-modal__header"
        }, [_vm._t("header", [_vm._c('h1', {
          staticClass: "ui-modal__header-text"
        }, [_vm._v(_vm._s(_vm.title))])]), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-modal__close-button"
        }, [_vm.dismissOnCloseButton && !_vm.removeCloseButton && _vm.dismissible ? _vm._c('ui-close-button', {
          on: {
            "click": _vm.closeModal
          }
        }) : _vm._e()], 1)], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-modal__body"
        }, [_vm._t("default")], 2), _vm._v(" "), _vm.hasFooter ? _vm._c('div', {
          staticClass: "ui-modal__footer"
        }, [_vm._t("footer")], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-modal__focus-redirect",
          attrs: {
            "tabindex": "0"
          },
          on: {
            "focus": function focus($event) {
              $event.stopPropagation();
              _vm.redirectFocus($event);
            }
          }
        })])])])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-509bc3e8", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-checkbox-group",
          class: _vm.classes
        }, [_vm.label || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-checkbox-group__label-text"
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-checkbox-group__checkboxes"
        }, _vm._l(_vm.options, function (option, index) {
          return _vm._c('ui-checkbox', {
            directives: [{
              name: "model",
              rawName: "v-model",
              value: _vm.checkboxValues[index],
              expression: "checkboxValues[index]"
            }],
            key: option[_vm.keys.id],
            staticClass: "ui-checkbox-group__checkbox",
            class: option[_vm.keys.class],
            attrs: {
              "box-position": _vm.boxPosition,
              "checked": _vm.isOptionCheckedByDefault(option),
              "color": _vm.color,
              "disabled": _vm.disabled || option[_vm.keys.disabled],
              "id": option[_vm.keys.id],
              "name": _vm.name || option[_vm.keys.name]
            },
            domProps: {
              "value": _vm.checkboxValues[index]
            },
            on: {
              "blur": _vm.onBlur,
              "change": function change($event) {
                _vm.onChange(arguments, option);
              },
              "focus": _vm.onFocus,
              "input": function input($event) {
                var $$exp = _vm.checkboxValues,
                    $$idx = index;
                if (!Array.isArray($$exp)) {
                  _vm.checkboxValues[index] = $event;
                } else {
                  $$exp.splice($$idx, 1, $event);
                }
              }
            }
          }, [_vm._v(_vm._s(option[_vm.keys.label] || option))]);
        })), _vm._v(" "), _vm.hasFeedback ? _vm._c('div', {
          staticClass: "ui-checkbox-group__feedback"
        }, [_vm.showError ? _vm._c('div', {
          staticClass: "ui-checkbox-group__feedback-text"
        }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _vm._c('div', {
          staticClass: "ui-checkbox-group__feedback-text"
        }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e()]) : _vm._e()]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-53e98d4a", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('button', {
          ref: "button",
          staticClass: "ui-fab",
          class: _vm.classes,
          attrs: {
            "aria-label": _vm.ariaLabel || _vm.tooltip
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm.icon || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-fab__icon"
        }, [_vm._t("default", [_vm._c('ui-icon', {
          attrs: {
            "icon": _vm.icon
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm._c('span', {
          staticClass: "ui-fab__focus-ring"
        }), _vm._v(" "), !_vm.disableRipple ? _vm._c('ui-ripple-ink', {
          attrs: {
            "trigger": "button"
          }
        }) : _vm._e(), _vm._v(" "), _vm.tooltip ? _vm._c('ui-tooltip', {
          attrs: {
            "trigger": "button",
            "open-on": _vm.openTooltipOn,
            "position": _vm.tooltipPosition
          }
        }, [_vm._v(_vm._s(_vm.tooltip))]) : _vm._e()], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-58451726", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-calendar-week"
        }, _vm._l(_vm.dates, function (date, index) {
          return _vm._c('div', {
            key: index,
            staticClass: "ui-calendar-week__date",
            class: _vm.getDateClasses(date),
            attrs: {
              "tabindex": _vm.visible && !_vm.isDateDisabled(date) ? 0 : null
            },
            on: {
              "click": function click($event) {
                _vm.selectDate(date);
              },
              "keydown": function keydown($event) {
                if (_vm._k($event.keyCode, "enter", 13)) {
                  return;
                }
                _vm.selectDate(date);
              }
            }
          }, [_vm._v("\n        " + _vm._s(_vm.getDayOfMonth(date)) + "\n    ")]);
        }));
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-60cc7cc3", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-tabs",
          class: _vm.classes
        }, [_vm._c('div', {
          staticClass: "ui-tabs__header"
        }, [_vm._c('ul', {
          ref: "tabsContainer",
          staticClass: "ui-tabs__header-items",
          attrs: {
            "role": "tablist"
          }
        }, _vm._l(_vm.tabs, function (tab) {
          return _vm._c('ui-tab-header-item', {
            directives: [{
              name: "show",
              rawName: "v-show",
              value: tab.show,
              expression: "tab.show"
            }],
            ref: "tabElements",
            refInFor: true,
            attrs: {
              "active": _vm.activeTabId === tab.id,
              "disable-ripple": _vm.disableRipple,
              "disabled": tab.disabled,
              "icon-props": tab.iconProps,
              "icon": tab.icon,
              "id": tab.id,
              "show": tab.show,
              "title": tab.title,
              "type": _vm.type
            },
            nativeOn: {
              "click": function click($event) {
                _vm.selectTab($event, tab);
              },
              "keydown": [function ($event) {
                if (_vm._k($event.keyCode, "left", 37)) {
                  return;
                }
                _vm.selectPreviousTab($event);
              }, function ($event) {
                if (_vm._k($event.keyCode, "right", 39)) {
                  return;
                }
                _vm.selectNextTab($event);
              }]
            }
          }, [tab.$slots.icon ? _vm._c('render-vnodes', {
            attrs: {
              "nodes": tab.$slots.icon
            },
            slot: "icon"
          }) : _vm._e()], 1);
        })), _vm._v(" "), _vm.tabContainerWidth != 0 ? _vm._c('div', {
          staticClass: "ui-tabs__active-tab-indicator",
          style: {
            'left': _vm.indicatorLeft,
            'right': _vm.indicatorRight
          }
        }) : _vm._e()]), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-tabs__body"
        }, [_vm._t("default")], 2)]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-6259e2ef", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('label', {
          staticClass: "ui-switch",
          class: _vm.classes
        }, [_vm._c('div', {
          staticClass: "ui-switch__input-wrapper"
        }, [_vm._c('input', {
          staticClass: "ui-switch__input",
          attrs: {
            "type": "checkbox",
            "disabled": _vm.disabled,
            "name": _vm.name
          },
          domProps: {
            "checked": _vm.isChecked,
            "value": _vm.submittedValue
          },
          on: {
            "blur": _vm.onBlur,
            "change": _vm.onChange,
            "click": _vm.onClick,
            "focus": _vm.onFocus
          }
        }), _vm._v(" "), _vm._m(0), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-switch__track"
        })]), _vm._v(" "), _vm.label || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-switch__label-text"
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
      }, staticRenderFns: [function () {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-switch__thumb"
        }, [_vm._c('div', {
          staticClass: "ui-switch__focus-ring"
        })]);
      }] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-629f0965", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('li', {
          ref: "menuOption",
          staticClass: "ui-menu-option",
          class: _vm.classes,
          attrs: {
            "role": "menu-item",
            "tabindex": _vm.isDivider || _vm.disabled ? null : '0'
          }
        }, [!_vm.isDivider ? _vm._t("default", [_vm._c('div', {
          staticClass: "ui-menu-option__content"
        }, [_vm.icon ? _vm._c('ui-icon', {
          staticClass: "ui-menu-option__icon",
          attrs: {
            "icon-set": _vm.iconProps.iconSet,
            "icon": _vm.icon,
            "remove-text": _vm.iconProps.removeText,
            "use-svg": _vm.iconProps.useSvg
          }
        }) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-menu-option__text"
        }, [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _vm.secondaryText ? _vm._c('div', {
          staticClass: "ui-menu-option__secondary-text"
        }, [_vm._v("\n                " + _vm._s(_vm.secondaryText) + "\n            ")]) : _vm._e()], 1)]) : _vm._e(), _vm._v(" "), !_vm.disabled && !_vm.isDivider && !_vm.disableRipple ? _vm._c('ui-ripple-ink', {
          attrs: {
            "trigger": "menuOption"
          }
        }) : _vm._e()], 2);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-6515e465", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('span', {
          staticClass: "ui-icon",
          class: [_vm.iconSet, _vm.icon],
          attrs: {
            "aria-label": _vm.ariaLabel
          }
        }, [_vm.useSvg ? _vm._c('svg', {
          staticClass: "ui-icon__svg"
        }, [_vm._c('use', {
          attrs: {
            "xmlns:xlink": "http://www.w3.org/1999/xlink",
            "xlink:href": '#' + _vm.icon
          }
        })]) : _vm._t("default", [_vm._v(_vm._s(_vm.removeText ? null : _vm.icon))])], 2);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-6b61f66a", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('label', {
          staticClass: "ui-checkbox",
          class: _vm.classes
        }, [_vm._c('input', {
          staticClass: "ui-checkbox__input",
          attrs: {
            "type": "checkbox",
            "disabled": _vm.disabled,
            "name": _vm.name
          },
          domProps: {
            "checked": _vm.isChecked,
            "value": _vm.submittedValue
          },
          on: {
            "blur": _vm.onBlur,
            "change": _vm.onChange,
            "click": _vm.onClick,
            "focus": _vm.onFocus
          }
        }), _vm._v(" "), _vm._m(0), _vm._v(" "), _vm.label || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-checkbox__label-text"
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
      }, staticRenderFns: [function () {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-checkbox__checkmark"
        }, [_vm._c('div', {
          staticClass: "ui-checkbox__focus-ring"
        })]);
      }] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-6d48e798", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('ul', {
          staticClass: "ui-menu",
          class: _vm.classes,
          attrs: {
            "role": "menu"
          }
        }, [_vm._l(_vm.options, function (option) {
          return _vm._c('ui-menu-option', {
            attrs: {
              "disable-ripple": _vm.disableRipple,
              "disabled": option[_vm.keys.disabled],
              "icon-props": _vm.iconProps || option[_vm.keys.iconProps],
              "icon": _vm.hasIcons ? option[_vm.keys.icon] : null,
              "label": option[_vm.keys.type] === 'divider' ? null : option[_vm.keys.label] || option,
              "secondary-text": _vm.hasSecondaryText ? option[_vm.keys.secondaryText] : null,
              "type": option[_vm.keys.type]
            },
            nativeOn: {
              "click": function click($event) {
                _vm.selectOption(option);
              },
              "keydown": [function ($event) {
                if (_vm._k($event.keyCode, "enter", 13)) {
                  return;
                }
                $event.preventDefault();
                _vm.selectOption(option);
              }, function ($event) {
                if (_vm._k($event.keyCode, "esc", 27)) {
                  return;
                }
                _vm.closeMenu($event);
              }]
            }
          }, [_vm._t("option", null, {
            option: option
          })], 2);
        }), _vm._v(" "), _vm.containFocus ? _vm._c('div', {
          staticClass: "ui-menu__focus-redirector",
          attrs: {
            "tabindex": "0"
          },
          on: {
            "focus": _vm.redirectFocus
          }
        }) : _vm._e()], 2);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-7360ec50", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('button', {
          ref: "button",
          staticClass: "ui-close-button",
          class: _vm.classes,
          attrs: {
            "aria-label": "Close",
            "type": "button",
            "disabled": _vm.disabled
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm._c('div', {
          staticClass: "ui-close-button__icon"
        }, [_vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M18.984 6.422L13.406 12l5.578 5.578-1.406 1.406L12 13.406l-5.578 5.578-1.406-1.406L10.594 12 5.016 6.422l1.406-1.406L12 10.594l5.578-5.578z"
          }
        })])])], 1), _vm._v(" "), _vm._c('span', {
          staticClass: "ui-close-button__focus-ring"
        }), _vm._v(" "), !_vm.disableRipple && !_vm.disabled ? _vm._c('ui-ripple-ink', {
          attrs: {
            "trigger": "button"
          }
        }) : _vm._e()], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-73775a2e", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-datepicker",
          class: _vm.classes
        }, [_vm._c('input', {
          staticClass: "ui-datepicker__hidden-input",
          attrs: {
            "type": "hidden",
            "name": _vm.name
          },
          domProps: {
            "value": _vm.submittedValue
          }
        }), _vm._v(" "), _vm.icon || _vm.$slots.icon ? _vm._c('div', {
          staticClass: "ui-datepicker__icon-wrapper"
        }, [_vm._t("icon", [_vm._c('ui-icon', {
          attrs: {
            "icon": _vm.icon
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-datepicker__content"
        }, [_vm._c('div', {
          ref: "label",
          staticClass: "ui-datepicker__label",
          attrs: {
            "tabindex": _vm.disabled ? null : '0'
          },
          on: {
            "click": _vm.onClick,
            "focus": _vm.onFocus,
            "keydown": [function ($event) {
              if (_vm._k($event.keyCode, "enter", 13)) {
                return;
              }
              $event.preventDefault();
              _vm.openPicker($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "space", 32)) {
                return;
              }
              $event.preventDefault();
              _vm.openPicker($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "tab", 9)) {
                return;
              }
              _vm.onBlur($event);
            }]
          }
        }, [_vm.label || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-datepicker__label-text",
          class: _vm.labelClasses
        }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-datepicker__display"
        }, [_vm._c('div', {
          staticClass: "ui-datepicker__display-value",
          class: {
            'is-placeholder': !_vm.hasDisplayText
          }
        }, [_vm._v("\n                    " + _vm._s(_vm.hasDisplayText ? _vm.displayText : _vm.hasFloatingLabel && _vm.isLabelInline ? null : _vm.placeholder) + "\n                ")]), _vm._v(" "), _vm.usesPopover && !_vm.disabled ? _vm._c('ui-icon', {
          staticClass: "ui-datepicker__dropdown-button"
        }, [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M6.984 9.984h10.03L12 15z"
          }
        })])]) : _vm._e()], 1)]), _vm._v(" "), _vm.hasFeedback ? _vm._c('div', {
          staticClass: "ui-datepicker__feedback"
        }, [_vm.showError ? _vm._c('div', {
          staticClass: "ui-datepicker__feedback-text"
        }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _vm._c('div', {
          staticClass: "ui-datepicker__feedback-text"
        }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e()]) : _vm._e()]), _vm._v(" "), _vm.usesModal && !_vm.disabled ? _vm._c('ui-modal', {
          ref: "modal",
          attrs: {
            "remove-header": ""
          },
          on: {
            "close": _vm.onPickerClose,
            "open": _vm.onPickerOpen
          }
        }, [_vm._c('ui-calendar', {
          attrs: {
            "color": _vm.color,
            "date-filter": _vm.dateFilter,
            "lang": _vm.lang,
            "max-date": _vm.maxDate,
            "min-date": _vm.minDate,
            "orientation": _vm.orientation,
            "value": _vm.value
          },
          on: {
            "date-select": _vm.onDateSelect
          }
        }, [_vm._c('div', {
          staticClass: "ui-datepicker__modal-buttons",
          slot: "footer"
        }, [_vm._c('ui-button', {
          attrs: {
            "type": "secondary",
            "color": _vm.color
          },
          on: {
            "click": function click($event) {
              _vm.$refs.modal.close();
            }
          }
        }, [_vm._v(_vm._s(_vm.okButtonText))]), _vm._v(" "), _vm._c('ui-button', {
          attrs: {
            "type": "secondary",
            "color": _vm.color
          },
          on: {
            "click": _vm.onPickerCancel
          }
        }, [_vm._v(_vm._s(_vm.cancelButtonText))])], 1)])], 1) : _vm._e(), _vm._v(" "), _vm.usesPopover && !_vm.disabled ? _vm._c('ui-popover', {
          ref: "popover",
          attrs: {
            "contain-focus": "",
            "trigger": "label"
          },
          on: {
            "close": _vm.onPickerClose,
            "open": _vm.onPickerOpen
          }
        }, [_vm._c('ui-calendar', {
          attrs: {
            "color": _vm.color,
            "date-filter": _vm.dateFilter,
            "lang": _vm.lang,
            "max-date": _vm.maxDate,
            "min-date": _vm.minDate,
            "orientation": _vm.orientation,
            "value": _vm.value
          },
          on: {
            "date-select": _vm.onDateSelect
          }
        })], 1) : _vm._e()], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-7cb5576d", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('label', {
          ref: "label",
          staticClass: "ui-fileupload",
          class: _vm.classes
        }, [_vm._c('input', {
          ref: "input",
          staticClass: "ui-fileupload__input",
          attrs: {
            "type": "file",
            "accept": _vm.accept,
            "disabled": _vm.disabled,
            "multiple": _vm.multiple,
            "name": _vm.name,
            "required": _vm.required
          },
          on: {
            "blur": _vm.onBlur,
            "change": _vm.onChange,
            "focus": _vm.onFocus
          }
        }), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-fileupload__content"
        }, [_vm._c('div', {
          staticClass: "ui-fileupload__icon"
        }, [_vm._t("icon", [_vm._c('ui-icon', [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M5.016 18h13.969v2.016H5.016V18zM9 15.984v-6H5.016L12 3l6.984 6.984H15v6H9z"
          }
        })])])])], 2), _vm._v(" "), _vm.hasSelection ? _vm._c('span', {
          staticClass: "ui-fileupload__display-text"
        }, [_vm._v(_vm._s(_vm.displayText))]) : _vm._t("default", [_vm._v(_vm._s(_vm.placeholder))])], 2), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-fileupload__focus-ring",
          style: _vm.focusRingStyle
        }), _vm._v(" "), !_vm.disableRipple && !_vm.disabled ? _vm._c('ui-ripple-ink', {
          attrs: {
            "trigger": "label"
          }
        }) : _vm._e()], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-8595f0a4", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('button', {
          ref: "button",
          staticClass: "ui-icon-button",
          class: _vm.classes,
          attrs: {
            "aria-label": _vm.ariaLabel || _vm.tooltip,
            "disabled": _vm.disabled || _vm.loading,
            "type": _vm.buttonType
          },
          on: {
            "click": _vm.onClick
          }
        }, [_vm.icon || _vm.$slots.default ? _vm._c('div', {
          staticClass: "ui-icon-button__icon"
        }, [_vm._t("default", [_vm._c('ui-icon', {
          attrs: {
            "icon": _vm.icon
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-icon-button__focus-ring"
        }), _vm._v(" "), _vm._c('ui-progress-circular', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.loading,
            expression: "loading"
          }],
          staticClass: "ui-icon-button__progress",
          attrs: {
            "color": _vm.progressColor,
            "size": _vm.size === 'large' ? 24 : 18,
            "stroke": 4.5
          }
        }), _vm._v(" "), !_vm.disableRipple && !_vm.disabled ? _vm._c('ui-ripple-ink', {
          attrs: {
            "trigger": "button"
          }
        }) : _vm._e(), _vm._v(" "), _vm.hasDropdown ? _vm._c('ui-popover', {
          ref: "dropdown",
          attrs: {
            "trigger": "button",
            "dropdown-position": _vm.dropdownPosition,
            "open-on": _vm.openDropdownOn
          },
          on: {
            "close": _vm.onDropdownClose,
            "open": _vm.onDropdownOpen
          }
        }, [_vm._t("dropdown")], 2) : _vm._e(), _vm._v(" "), _vm.tooltip ? _vm._c('ui-tooltip', {
          attrs: {
            "trigger": "button",
            "open-on": _vm.openTooltipOn,
            "position": _vm.tooltipPosition
          }
        }, [_vm._v(_vm._s(_vm.tooltip))]) : _vm._e()], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-8ced2988", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-slider",
          class: _vm.classes,
          attrs: {
            "role": "slider",
            "aria-valuemax": 100,
            "aria-valuemin": 0,
            "aria-valuenow": _vm.localValue,
            "tabindex": _vm.disabled ? null : 0
          },
          on: {
            "blur": _vm.onBlur,
            "focus": _vm.onFocus,
            "keydown": [function ($event) {
              if (_vm._k($event.keyCode, "down", 40)) {
                return;
              }
              $event.preventDefault();
              _vm.decrementValue($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "left", 37)) {
                return;
              }
              $event.preventDefault();
              _vm.decrementValue($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "right", 39)) {
                return;
              }
              $event.preventDefault();
              _vm.incrementValue($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "up", 38)) {
                return;
              }
              $event.preventDefault();
              _vm.incrementValue($event);
            }]
          }
        }, [_vm.name ? _vm._c('input', {
          staticClass: "ui-slider__hidden-input",
          attrs: {
            "type": "hidden",
            "name": _vm.name
          },
          domProps: {
            "value": _vm.value
          }
        }) : _vm._e(), _vm._v(" "), _vm.hasIcon ? _vm._c('div', {
          staticClass: "ui-slider__icon"
        }, [_vm._t("icon", [_vm._c('ui-icon', {
          attrs: {
            "icon": _vm.icon
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm._c('div', {
          ref: "track",
          staticClass: "ui-slider__track",
          on: {
            "mousedown": _vm.onDragStart,
            "touchstart": _vm.onDragStart
          }
        }, [_vm._c('div', {
          staticClass: "ui-slider__track-background"
        }, _vm._l(_vm.snapPoints, function (point) {
          return _vm.snapToSteps ? _vm._c('span', {
            staticClass: "ui-slider__snap-point",
            style: {
              left: point + '%'
            }
          }) : _vm._e();
        })), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-slider__track-fill",
          style: _vm.fillStyle
        }), _vm._v(" "), _vm._c('div', {
          ref: "thumb",
          staticClass: "ui-slider__thumb",
          style: _vm.thumbStyle
        }, [_vm.showMarker ? _vm._c('div', {
          staticClass: "ui-slider__marker"
        }, [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "viewBox": "0 0 24 24",
            "width": "36",
            "height": "36"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M11 .5c-1.7.2-3.4.9-4.7 2-1.1.9-2 2-2.5 3.2-1.2 2.4-1.2 5.1-.1 7.7 1.1 2.6 2.8 5 5.3 7.5 1.2 1.2 2.8 2.7 3 2.7 0 0 .3-.2.6-.5 3.2-2.7 5.6-5.6 7.1-8.5.8-1.5 1.1-2.6 1.3-3.8.2-1.4 0-2.9-.5-4.3-1.2-3.2-4.1-5.4-7.5-5.8-.5-.2-1.5-.2-2-.2z"
          }
        })]), _vm._v(" "), _vm._c('span', {
          staticClass: "ui-slider__marker-text"
        }, [_vm._v(_vm._s(_vm.markerText))])]) : _vm._e()])])]);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-8d7da6dc", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          ref: "tooltip",
          staticClass: "ui-tooltip"
        }, [_vm._t("default")], 2);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-b226babc", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-collapsible",
          class: _vm.classes
        }, [_vm._c('div', {
          ref: "header",
          staticClass: "ui-collapsible__header",
          attrs: {
            "aria-controls": _vm.id,
            "aria-expanded": _vm.isOpen ? 'true' : 'false',
            "tabindex": _vm.disabled ? null : 0
          },
          on: {
            "click": _vm.toggleCollapsible,
            "keydown": [function ($event) {
              if (_vm._k($event.keyCode, "enter", 13)) {
                return;
              }
              $event.preventDefault();
              _vm.toggleCollapsible($event);
            }, function ($event) {
              if (_vm._k($event.keyCode, "space", 32)) {
                return;
              }
              $event.preventDefault();
              _vm.toggleCollapsible($event);
            }]
          }
        }, [_vm._c('div', {
          staticClass: "ui-collapsible__header-content"
        }, [_vm._t("header", [_vm._v(_vm._s(_vm.title))])], 2), _vm._v(" "), !_vm.removeIcon ? _vm._c('ui-icon', {
          staticClass: "ui-collapsible__header-icon"
        }, [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M7.406 7.828L12 12.422l4.594-4.594L18 9.234l-6 6-6-6z"
          }
        })])]) : _vm._e(), _vm._v(" "), !_vm.disableRipple && !_vm.disabled && _vm.isReady ? _vm._c('ui-ripple-ink', {
          attrs: {
            "trigger": "header"
          }
        }) : _vm._e()], 1), _vm._v(" "), _vm._c('transition', {
          attrs: {
            "name": "ui-collapsible--transition-toggle"
          },
          on: {
            "after-enter": _vm.onEnter,
            "after-leave": _vm.onLeave
          }
        }, [_vm._c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.isOpen,
            expression: "isOpen"
          }],
          ref: "body",
          staticClass: "ui-collapsible__body-wrapper",
          style: {
            'height': _vm.calculatedHeight
          }
        }, [_vm._c('div', {
          staticClass: "ui-collapsible__body",
          attrs: {
            "aria-hidden": _vm.isOpen ? null : 'true',
            "id": _vm.id
          }
        }, [_vm._t("default")], 2)])])], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-c1d568ae", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('button', {
          ref: "button",
          staticClass: "ui-button",
          class: _vm.classes,
          attrs: {
            "disabled": _vm.disabled || _vm.loading,
            "type": _vm.buttonType
          },
          on: {
            "click": _vm.onClick,
            "~focus": function focus($event) {
              _vm.onFocus($event);
            }
          }
        }, [_vm._c('div', {
          staticClass: "ui-button__content"
        }, [_vm.icon || _vm.$slots.icon ? _vm._c('div', {
          staticClass: "ui-button__icon"
        }, [_vm._t("icon", [_vm._c('ui-icon', {
          attrs: {
            "icon": _vm.icon
          }
        })])], 2) : _vm._e(), _vm._v(" "), _vm._t("default"), _vm._v(" "), _vm.hasDropdown && _vm.iconPosition !== 'right' ? _vm._c('ui-icon', {
          staticClass: "ui-button__dropdown-icon"
        }, [_vm._c('svg', {
          attrs: {
            "xmlns": "http://www.w3.org/2000/svg",
            "width": "24",
            "height": "24",
            "viewBox": "0 0 24 24"
          }
        }, [_vm._c('path', {
          attrs: {
            "d": "M6.984 9.984h10.03L12 15z"
          }
        })])]) : _vm._e()], 2), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-button__focus-ring",
          style: _vm.focusRingStyle
        }), _vm._v(" "), _vm._c('ui-progress-circular', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.loading,
            expression: "loading"
          }],
          staticClass: "ui-button__progress",
          attrs: {
            "disable-transition": "",
            "color": _vm.progressColor,
            "size": 18,
            "stroke": 4.5
          }
        }), _vm._v(" "), !_vm.disableRipple && !_vm.disabled ? _vm._c('ui-ripple-ink', {
          attrs: {
            "trigger": "button"
          }
        }) : _vm._e(), _vm._v(" "), _vm.hasDropdown ? _vm._c('ui-popover', {
          ref: "dropdown",
          attrs: {
            "trigger": "button",
            "dropdown-position": _vm.dropdownPosition,
            "open-on": _vm.openDropdownOn
          },
          on: {
            "close": _vm.onDropdownClose,
            "open": _vm.onDropdownOpen
          }
        }, [_vm._t("dropdown")], 2) : _vm._e()], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-e69d6b3a", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-confirm"
        }, [_vm._c('ui-modal', {
          ref: "modal",
          attrs: {
            "role": "alertdialog",
            "dismiss-on": _vm.dismissOn,
            "dismissible": !_vm.loading,
            "title": _vm.title,
            "transition": _vm.transition
          },
          on: {
            "close": _vm.onModalClose,
            "open": _vm.onModalOpen
          }
        }, [_vm._c('div', {
          staticClass: "ui-confirm__message"
        }, [_vm._t("default")], 2), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-confirm__footer",
          slot: "footer"
        }, [_vm._c('ui-button', {
          ref: "confirmButton",
          attrs: {
            "color": _vm.confirmButtonColor,
            "icon": _vm.confirmButtonIcon,
            "loading": _vm.loading
          },
          on: {
            "click": _vm.confirm
          }
        }, [_vm._v(_vm._s(_vm.confirmButtonText))]), _vm._v(" "), _vm._c('ui-button', {
          ref: "denyButton",
          attrs: {
            "disabled": _vm.loading,
            "icon": _vm.denyButtonIcon
          },
          on: {
            "click": _vm.deny
          }
        }, [_vm._v(_vm._s(_vm.denyButtonText))])], 1)])], 1);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-ed03da42", module.exports);
      }
    }
  }, function (module, exports, __webpack_require__) {

    module.exports = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;
        return _vm._c('div', {
          staticClass: "ui-popover",
          class: {
            'is-raised': _vm.raised
          },
          attrs: {
            "role": "dialog",
            "tabindex": "-1"
          },
          on: {
            "keydown": function keydown($event) {
              if (_vm._k($event.keyCode, "esc", 27)) {
                return;
              }
              _vm.closeDropdown($event);
            }
          }
        }, [_vm._t("default"), _vm._v(" "), _vm._c('div', {
          staticClass: "ui-popover__focus-redirector",
          attrs: {
            "tabindex": "0"
          },
          on: {
            "focus": _vm.restrictFocus
          }
        })], 2);
      }, staticRenderFns: [] };
    module.exports.render._withStripped = true;
    if (false) {
      module.hot.accept();
      if (module.hot.data) {
        require("vue-hot-reload-api").rerender("data-v-fb51df78", module.exports);
      }
    }
  }, function (module, exports) {

    var g;

    g = function () {
      return this;
    }();

    try {
      g = g || Function("return this")() || (1, eval)("this");
    } catch (e) {
      if ((typeof window === 'undefined' ? 'undefined' : (0, _typeof6.default)(window)) === "object") g = window;
    }

    module.exports = g;
  }, function (module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UiTooltip = exports.UiToolbar = exports.UiTextbox = exports.UiTabs = exports.UiTab = exports.UiSwitch = exports.UiSnackbarContainer = exports.UiSnackbar = exports.UiSlider = exports.UiSelect = exports.UiRippleInk = exports.UiRadioGroup = exports.UiRadio = exports.UiProgressLinear = exports.UiProgressCircular = exports.UiPreloader = exports.UiPopover = exports.UiModal = exports.UiMenu = exports.UiIconButton = exports.UiIcon = exports.UiFileupload = exports.UiFab = exports.UiDatepicker = exports.UiConfirm = exports.UiCollapsible = exports.UiCheckboxGroup = exports.UiCheckbox = exports.UiCalendar = exports.UiButton = exports.UiAutocomplete = exports.UiAlert = undefined;

    __webpack_require__(65);

    var _UiAlert = __webpack_require__(66);

    var _UiAlert2 = _interopRequireDefault(_UiAlert);

    var _UiAutocomplete = __webpack_require__(67);

    var _UiAutocomplete2 = _interopRequireDefault(_UiAutocomplete);

    var _UiButton = __webpack_require__(14);

    var _UiButton2 = _interopRequireDefault(_UiButton);

    var _UiCalendar = __webpack_require__(42);

    var _UiCalendar2 = _interopRequireDefault(_UiCalendar);

    var _UiCheckbox = __webpack_require__(43);

    var _UiCheckbox2 = _interopRequireDefault(_UiCheckbox);

    var _UiCheckboxGroup = __webpack_require__(68);

    var _UiCheckboxGroup2 = _interopRequireDefault(_UiCheckboxGroup);

    var _UiCollapsible = __webpack_require__(69);

    var _UiCollapsible2 = _interopRequireDefault(_UiCollapsible);

    var _UiConfirm = __webpack_require__(70);

    var _UiConfirm2 = _interopRequireDefault(_UiConfirm);

    var _UiDatepicker = __webpack_require__(71);

    var _UiDatepicker2 = _interopRequireDefault(_UiDatepicker);

    var _UiFab = __webpack_require__(72);

    var _UiFab2 = _interopRequireDefault(_UiFab);

    var _UiFileupload = __webpack_require__(73);

    var _UiFileupload2 = _interopRequireDefault(_UiFileupload);

    var _UiIcon = __webpack_require__(1);

    var _UiIcon2 = _interopRequireDefault(_UiIcon);

    var _UiIconButton = __webpack_require__(25);

    var _UiIconButton2 = _interopRequireDefault(_UiIconButton);

    var _UiMenu = __webpack_require__(74);

    var _UiMenu2 = _interopRequireDefault(_UiMenu);

    var _UiModal = __webpack_require__(26);

    var _UiModal2 = _interopRequireDefault(_UiModal);

    var _UiPopover = __webpack_require__(15);

    var _UiPopover2 = _interopRequireDefault(_UiPopover);

    var _UiPreloader = __webpack_require__(75);

    var _UiPreloader2 = _interopRequireDefault(_UiPreloader);

    var _UiProgressCircular = __webpack_require__(16);

    var _UiProgressCircular2 = _interopRequireDefault(_UiProgressCircular);

    var _UiProgressLinear = __webpack_require__(44);

    var _UiProgressLinear2 = _interopRequireDefault(_UiProgressLinear);

    var _UiRadio = __webpack_require__(45);

    var _UiRadio2 = _interopRequireDefault(_UiRadio);

    var _UiRadioGroup = __webpack_require__(76);

    var _UiRadioGroup2 = _interopRequireDefault(_UiRadioGroup);

    var _UiRippleInk = __webpack_require__(3);

    var _UiRippleInk2 = _interopRequireDefault(_UiRippleInk);

    var _UiSelect = __webpack_require__(77);

    var _UiSelect2 = _interopRequireDefault(_UiSelect);

    var _UiSlider = __webpack_require__(78);

    var _UiSlider2 = _interopRequireDefault(_UiSlider);

    var _UiSnackbar = __webpack_require__(46);

    var _UiSnackbar2 = _interopRequireDefault(_UiSnackbar);

    var _UiSnackbarContainer = __webpack_require__(79);

    var _UiSnackbarContainer2 = _interopRequireDefault(_UiSnackbarContainer);

    var _UiSwitch = __webpack_require__(80);

    var _UiSwitch2 = _interopRequireDefault(_UiSwitch);

    var _UiTab = __webpack_require__(81);

    var _UiTab2 = _interopRequireDefault(_UiTab);

    var _UiTabs = __webpack_require__(82);

    var _UiTabs2 = _interopRequireDefault(_UiTabs);

    var _UiTextbox = __webpack_require__(83);

    var _UiTextbox2 = _interopRequireDefault(_UiTextbox);

    var _UiToolbar = __webpack_require__(84);

    var _UiToolbar2 = _interopRequireDefault(_UiToolbar);

    var _UiTooltip = __webpack_require__(27);

    var _UiTooltip2 = _interopRequireDefault(_UiTooltip);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    var Keen = {
      UiAlert: _UiAlert2.default,
      UiAutocomplete: _UiAutocomplete2.default,
      UiButton: _UiButton2.default,
      UiCalendar: _UiCalendar2.default,
      UiCheckbox: _UiCheckbox2.default,
      UiCheckboxGroup: _UiCheckboxGroup2.default,
      UiCollapsible: _UiCollapsible2.default,
      UiConfirm: _UiConfirm2.default,
      UiDatepicker: _UiDatepicker2.default,
      UiFab: _UiFab2.default,
      UiFileupload: _UiFileupload2.default,
      UiIcon: _UiIcon2.default,
      UiIconButton: _UiIconButton2.default,
      UiMenu: _UiMenu2.default,
      UiModal: _UiModal2.default,
      UiPopover: _UiPopover2.default,
      UiPreloader: _UiPreloader2.default,
      UiProgressCircular: _UiProgressCircular2.default,
      UiProgressLinear: _UiProgressLinear2.default,
      UiRadio: _UiRadio2.default,
      UiRadioGroup: _UiRadioGroup2.default,
      UiRippleInk: _UiRippleInk2.default,
      UiSelect: _UiSelect2.default,
      UiSlider: _UiSlider2.default,
      UiSnackbar: _UiSnackbar2.default,
      UiSnackbarContainer: _UiSnackbarContainer2.default,
      UiSwitch: _UiSwitch2.default,
      UiTab: _UiTab2.default,
      UiTabs: _UiTabs2.default,
      UiTextbox: _UiTextbox2.default,
      UiToolbar: _UiToolbar2.default,
      UiTooltip: _UiTooltip2.default,

      install: function install(Vue) {
        Vue.component('ui-alert', _UiAlert2.default);
        Vue.component('ui-autocomplete', _UiAutocomplete2.default);
        Vue.component('ui-button', _UiButton2.default);
        Vue.component('ui-calendar', _UiCalendar2.default);
        Vue.component('ui-checkbox', _UiCheckbox2.default);
        Vue.component('ui-checkbox-group', _UiCheckboxGroup2.default);
        Vue.component('ui-collapsible', _UiCollapsible2.default);
        Vue.component('ui-confirm', _UiConfirm2.default);
        Vue.component('ui-datepicker', _UiDatepicker2.default);
        Vue.component('ui-fab', _UiFab2.default);
        Vue.component('ui-fileupload', _UiFileupload2.default);
        Vue.component('ui-icon', _UiIcon2.default);
        Vue.component('ui-icon-button', _UiIconButton2.default);
        Vue.component('ui-menu', _UiMenu2.default);
        Vue.component('ui-modal', _UiModal2.default);
        Vue.component('ui-popover', _UiPopover2.default);
        Vue.component('ui-preloader', _UiPreloader2.default);
        Vue.component('ui-progress-circular', _UiProgressCircular2.default);
        Vue.component('ui-progress-linear', _UiProgressLinear2.default);
        Vue.component('ui-radio', _UiRadio2.default);
        Vue.component('ui-radio-group', _UiRadioGroup2.default);
        Vue.component('ui-ripple-ink', _UiRippleInk2.default);
        Vue.component('ui-select', _UiSelect2.default);
        Vue.component('ui-slider', _UiSlider2.default);
        Vue.component('ui-snackbar', _UiSnackbar2.default);
        Vue.component('ui-snackbar-container', _UiSnackbarContainer2.default);
        Vue.component('ui-switch', _UiSwitch2.default);
        Vue.component('ui-tab', _UiTab2.default);
        Vue.component('ui-tabs', _UiTabs2.default);
        Vue.component('ui-textbox', _UiTextbox2.default);
        Vue.component('ui-toolbar', _UiToolbar2.default);
        Vue.component('ui-tooltip', _UiTooltip2.default);
      }
    };

    if (typeof window !== 'undefined' && window.Vue) {
      window.Vue.use(Keen);
    }

    exports.default = Keen;
    exports.UiAlert = _UiAlert2.default;
    exports.UiAutocomplete = _UiAutocomplete2.default;
    exports.UiButton = _UiButton2.default;
    exports.UiCalendar = _UiCalendar2.default;
    exports.UiCheckbox = _UiCheckbox2.default;
    exports.UiCheckboxGroup = _UiCheckboxGroup2.default;
    exports.UiCollapsible = _UiCollapsible2.default;
    exports.UiConfirm = _UiConfirm2.default;
    exports.UiDatepicker = _UiDatepicker2.default;
    exports.UiFab = _UiFab2.default;
    exports.UiFileupload = _UiFileupload2.default;
    exports.UiIcon = _UiIcon2.default;
    exports.UiIconButton = _UiIconButton2.default;
    exports.UiMenu = _UiMenu2.default;
    exports.UiModal = _UiModal2.default;
    exports.UiPopover = _UiPopover2.default;
    exports.UiPreloader = _UiPreloader2.default;
    exports.UiProgressCircular = _UiProgressCircular2.default;
    exports.UiProgressLinear = _UiProgressLinear2.default;
    exports.UiRadio = _UiRadio2.default;
    exports.UiRadioGroup = _UiRadioGroup2.default;
    exports.UiRippleInk = _UiRippleInk2.default;
    exports.UiSelect = _UiSelect2.default;
    exports.UiSlider = _UiSlider2.default;
    exports.UiSnackbar = _UiSnackbar2.default;
    exports.UiSnackbarContainer = _UiSnackbarContainer2.default;
    exports.UiSwitch = _UiSwitch2.default;
    exports.UiTab = _UiTab2.default;
    exports.UiTabs = _UiTabs2.default;
    exports.UiTextbox = _UiTextbox2.default;
    exports.UiToolbar = _UiToolbar2.default;
    exports.UiTooltip = _UiTooltip2.default;
  }]);
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)(module)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(6)
  , createDesc = __webpack_require__(31);
module.exports = __webpack_require__(3) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(56)
  , defined = __webpack_require__(26);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module, process) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * DoveMaxSDK v1.0.0
 * (c) 2017 Romanysoft LAB.
 * @license MIT
 */
(function (global, factory) {
  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.DoveMaxSDK = factory();
})(undefined, function () {
  'use strict';

  /*eslint-disable*/
  //     Underscore.js 1.8.3
  //     http://underscorejs.org
  //     (c) 2009-2017 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.


  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.

  var root = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self && self || (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global && global || {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype;
  var ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push;
  var slice = ArrayProto.slice;
  var toString = ObjProto.toString;
  var hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray;
  var nativeKeys = Object.keys;
  var nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function Ctor() {};

  // Create a safe reference to the Underscore object for use below.
  var _$1 = function _$1(obj) {
    if (obj instanceof _$1) {
      return obj;
    }
    if (!(this instanceof _$1)) {
      return new _$1(obj);
    }
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _$1;
    }
    exports._ = _$1;
  } else {
    root._ = _$1;
  }

  // Current version.
  _$1.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function optimizeCb(func, context, argCount) {
    if (context === void 0) {
      return func;
    }
    switch (argCount) {
      case 1:
        return function (value) {
          return func.call(context, value);
        };
      // The 2-parameter case has been omitted only because no current consumers
      // made use of it.
      case null:
      case 3:
        return function (value, index, collection) {
          return func.call(context, value, index, collection);
        };
      case 4:
        return function (accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
    }
    return function () {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result  either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function cb(value, context, argCount) {
    if (_$1.iteratee !== builtinIteratee) {
      return _$1.iteratee(value, context);
    }
    if (value == null) {
      return _$1.identity;
    }
    if (_$1.isFunction(value)) {
      return optimizeCb(value, context, argCount);
    }
    if (_$1.isObject(value) && !_$1.isArray(value)) {
      return _$1.matcher(value);
    }
    return _$1.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _$1.iteratee = builtinIteratee = function builtinIteratee(value, context) {
    return cb(value, context, Infinity);
  };

  // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
  // This accumulates the arguments passed into an array, after a given index.
  var restArgs = function restArgs(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function () {
      var arguments$1 = arguments;

      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments$1[index + startIndex];
      }
      switch (startIndex) {
        case 0:
          return func.call(this, rest);
        case 1:
          return func.call(this, arguments[0], rest);
        case 2:
          return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments$1[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function baseCreate(prototype) {
    if (!_$1.isObject(prototype)) {
      return {};
    }
    if (nativeCreate) {
      return nativeCreate(prototype);
    }
    Ctor.prototype = prototype;
    var result = new Ctor();
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function shallowProperty(key) {
    return function (obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var deepGet = function deepGet(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) {
        return void 0;
      }
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function isArrayLike(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _$1.each = _$1.forEach = function (obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _$1.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _$1.map = _$1.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _$1.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function createReduce(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function reducer(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _$1.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function (obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _$1.reduce = _$1.foldl = _$1.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _$1.reduceRight = _$1.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _$1.find = _$1.detect = function (obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _$1.findIndex : _$1.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) {
      return obj[key];
    }
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _$1.filter = _$1.select = function (obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _$1.each(obj, function (value, index, list) {
      if (predicate(value, index, list)) {
        results.push(value);
      }
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _$1.reject = function (obj, predicate, context) {
    return _$1.filter(obj, _$1.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _$1.every = _$1.all = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _$1.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) {
        return false;
      }
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _$1.some = _$1.any = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _$1.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) {
        return true;
      }
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _$1.contains = _$1.includes = _$1.include = function (obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) {
      obj = _$1.values(obj);
    }
    if (typeof fromIndex != 'number' || guard) {
      fromIndex = 0;
    }
    return _$1.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _$1.invoke = restArgs(function (obj, path, args) {
    var contextPath, func;
    if (_$1.isFunction(path)) {
      func = path;
    } else if (_$1.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _$1.map(obj, function (context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) {
          return void 0;
        }
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _$1.pluck = function (obj, key) {
    return _$1.map(obj, _$1.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _$1.where = function (obj, attrs) {
    return _$1.filter(obj, _$1.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _$1.findWhere = function (obj, attrs) {
    return _$1.find(obj, _$1.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _$1.max = function (obj, iteratee, context) {
    var result = -Infinity,
        lastComputed = -Infinity,
        value,
        computed;
    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _$1.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _$1.each(obj, function (v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _$1.min = function (obj, iteratee, context) {
    var result = Infinity,
        lastComputed = Infinity,
        value,
        computed;
    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _$1.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _$1.each(obj, function (v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _$1.shuffle = function (obj) {
    return _$1.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _$1.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) {
        obj = _$1.values(obj);
      }
      return obj[_$1.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _$1.clone(obj) : _$1.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _$1.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _$1.sortBy = function (obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _$1.pluck(_$1.map(obj, function (value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) {
          return 1;
        }
        if (a < b || b === void 0) {
          return -1;
        }
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function group(behavior, partition) {
    return function (obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _$1.each(obj, function (value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _$1.groupBy = group(function (result, value, key) {
    if (_$1.has(result, key)) {
      result[key].push(value);
    } else {
      result[key] = [value];
    }
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _$1.indexBy = group(function (result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _$1.countBy = group(function (result, value, key) {
    if (_$1.has(result, key)) {
      result[key]++;
    } else {
      result[key] = 1;
    }
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _$1.toArray = function (obj) {
    if (!obj) {
      return [];
    }
    if (_$1.isArray(obj)) {
      return slice.call(obj);
    }
    if (_$1.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) {
      return _$1.map(obj, _$1.identity);
    }
    return _$1.values(obj);
  };

  // Return the number of elements in an object.
  _$1.size = function (obj) {
    if (obj == null) {
      return 0;
    }
    return isArrayLike(obj) ? obj.length : _$1.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _$1.partition = group(function (result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _$1.first = _$1.head = _$1.take = function (array, n, guard) {
    if (array == null || array.length < 1) {
      return void 0;
    }
    if (n == null || guard) {
      return array[0];
    }
    return _$1.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _$1.initial = function (array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _$1.last = function (array, n, guard) {
    if (array == null || array.length < 1) {
      return void 0;
    }
    if (n == null || guard) {
      return array[array.length - 1];
    }
    return _$1.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _$1.rest = _$1.tail = _$1.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _$1.compact = function (array) {
    return _$1.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function flatten(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_$1.isArray(value) || _$1.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0,
              len = value.length;
          while (j < len) {
            output[idx++] = value[j++];
          }
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _$1.flatten = function (array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _$1.without = restArgs(function (array, otherArrays) {
    return _$1.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _$1.uniq = _$1.unique = function (array, isSorted, iteratee, context) {
    if (!_$1.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) {
      iteratee = cb(iteratee, context);
    }
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) {
          result.push(value);
        }
        seen = computed;
      } else if (iteratee) {
        if (!_$1.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_$1.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _$1.union = restArgs(function (arrays) {
    return _$1.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _$1.intersection = function (array) {
    var arguments$1 = arguments;

    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_$1.contains(result, item)) {
        continue;
      }
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_$1.contains(arguments$1[j], item)) {
          break;
        }
      }
      if (j === argsLength) {
        result.push(item);
      }
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _$1.difference = restArgs(function (array, rest) {
    rest = flatten(rest, true, true);
    return _$1.filter(array, function (value) {
      return !_$1.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _$1.unzip = function (array) {
    var length = array && _$1.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _$1.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _$1.zip = restArgs(_$1.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _$1.object = function (list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function createPredicateIndexFinder(dir) {
    return function (array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _$1.findIndex = createPredicateIndexFinder(1);
  _$1.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _$1.sortedIndex = function (array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0,
        high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function (array, item, idx) {
      var i = 0,
          length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _$1.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) {
          return idx;
        }
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _$1.indexOf = createIndexFinder(1, _$1.findIndex, _$1.sortedIndex);
  _$1.lastIndexOf = createIndexFinder(-1, _$1.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _$1.range = function (start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Split an **array** into several arrays containing **count** or less elements
  // of initial array.
  _$1.chunk = function (array, count) {
    if (count == null || count < 1) {
      return [];
    }

    var result = [];
    var i = 0,
        length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) {
      return sourceFunc.apply(context, args);
    }
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_$1.isObject(result)) {
      return result;
    }
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _$1.bind = restArgs(function (func, context, args) {
    if (!_$1.isFunction(func)) {
      throw new TypeError('Bind must be called on a function');
    }
    var bound = restArgs(function (callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _$1.partial = restArgs(function (func, boundArgs) {
    var placeholder = _$1.partial.placeholder;
    var bound = function bound() {
      var arguments$1 = arguments;

      var position = 0,
          length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments$1[position++] : boundArgs[i];
      }
      while (position < arguments.length) {
        args.push(arguments$1[position++]);
      }
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _$1.partial.placeholder = _$1;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _$1.bindAll = restArgs(function (obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) {
      throw new Error('bindAll must be passed function names');
    }
    while (index--) {
      var key = keys[index];
      obj[key] = _$1.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _$1.memoize = function (func, hasher) {
    var memoize = function memoize(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_$1.has(cache, address)) {
        cache[address] = func.apply(this, arguments);
      }
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _$1.delay = restArgs(function (func, wait, args) {
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _$1.defer = _$1.partial(_$1.delay, _$1, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _$1.throttle = function (func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) {
      options = {};
    }

    var later = function later() {
      previous = options.leading === false ? 0 : _$1.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) {
        context = args = null;
      }
    };

    var throttled = function throttled() {
      var now = _$1.now();
      if (!previous && options.leading === false) {
        previous = now;
      }
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) {
          context = args = null;
        }
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function () {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _$1.debounce = function (func, wait, immediate) {
    var timeout, result;

    var later = function later(context, args) {
      timeout = null;
      if (args) {
        result = func.apply(context, args);
      }
    };

    var debounced = restArgs(function (args) {
      if (timeout) {
        clearTimeout(timeout);
      }
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(this, args);
        }
      } else {
        timeout = _$1.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function () {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _$1.wrap = function (func, wrapper) {
    return _$1.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _$1.negate = function (predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _$1.compose = function () {
    var args = arguments;
    var start = args.length - 1;
    return function () {
      var this$1 = this;

      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) {
        result = args[i].call(this$1, result);
      }
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _$1.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _$1.before = function (times, func) {
    var memo;
    return function () {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) {
        func = null;
      }
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _$1.once = _$1.partial(_$1.before, 2);

  _$1.restArgs = restArgs;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _$1.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_$1.has(obj, prop) && !_$1.contains(keys, prop)) {
      keys.push(prop);
    }

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_$1.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _$1.keys = function (obj) {
    if (!_$1.isObject(obj)) {
      return [];
    }
    if (nativeKeys) {
      return nativeKeys(obj);
    }
    var keys = [];
    for (var key in obj) {
      if (_$1.has(obj, key)) {
        keys.push(key);
      }
    }
    // Ahem, IE < 9.
    if (hasEnumBug) {
      collectNonEnumProps(obj, keys);
    }
    return keys;
  };

  // Retrieve all the property names of an object.
  _$1.allKeys = function (obj) {
    if (!_$1.isObject(obj)) {
      return [];
    }
    var keys = [];
    for (var key in obj) {
      keys.push(key);
    }
    // Ahem, IE < 9.
    if (hasEnumBug) {
      collectNonEnumProps(obj, keys);
    }
    return keys;
  };

  // Retrieve the values of an object's properties.
  _$1.values = function (obj) {
    var keys = _$1.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _$1.mapObject = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _$1.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _$1.pairs = function (obj) {
    var keys = _$1.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _$1.invert = function (obj) {
    var result = {};
    var keys = _$1.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _$1.functions = _$1.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_$1.isFunction(obj[key])) {
        names.push(key);
      }
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function createAssigner(keysFunc, defaults) {
    return function (obj) {
      var arguments$1 = arguments;

      var length = arguments.length;
      if (defaults) {
        obj = Object(obj);
      }
      if (length < 2 || obj == null) {
        return obj;
      }
      for (var index = 1; index < length; index++) {
        var source = arguments$1[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) {
            obj[key] = source[key];
          }
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _$1.extend = createAssigner(_$1.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _$1.extendOwn = _$1.assign = createAssigner(_$1.keys);

  // Returns the first key on an object that passes a predicate test.
  _$1.findKey = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _$1.keys(obj),
        key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) {
        return key;
      }
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function keyInObj(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _$1.pick = restArgs(function (obj, keys) {
    var result = {},
        iteratee = keys[0];
    if (obj == null) {
      return result;
    }
    if (_$1.isFunction(iteratee)) {
      if (keys.length > 1) {
        iteratee = optimizeCb(iteratee, keys[1]);
      }
      keys = _$1.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) {
        result[key] = value;
      }
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _$1.omit = restArgs(function (obj, keys) {
    var iteratee = keys[0],
        context;
    if (_$1.isFunction(iteratee)) {
      iteratee = _$1.negate(iteratee);
      if (keys.length > 1) {
        context = keys[1];
      }
    } else {
      keys = _$1.map(flatten(keys, false, false), String);
      iteratee = function iteratee(value, key) {
        return !_$1.contains(keys, key);
      };
    }
    return _$1.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _$1.defaults = createAssigner(_$1.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _$1.create = function (prototype, props) {
    var result = baseCreate(prototype);
    if (props) {
      _$1.extendOwn(result, props);
    }
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _$1.clone = function (obj) {
    if (!_$1.isObject(obj)) {
      return obj;
    }
    return _$1.isArray(obj) ? obj.slice() : _$1.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _$1.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _$1.isMatch = function (object, attrs) {
    var keys = _$1.keys(attrs),
        length = keys.length;
    if (object == null) {
      return !length;
    }
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) {
        return false;
      }
    }
    return true;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq;
  var deepEq;
  eq = function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) {
      return a !== 0 || 1 / a === 1 / b;
    }
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) {
      return false;
    }
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) {
      return b !== b;
    }
    // Exhaust primitive checks
    var type = typeof a === 'undefined' ? 'undefined' : _typeof(a);
    if (type !== 'function' && type !== 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') {
      return false;
    }
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _$1) {
      a = a._wrapped;
    }
    if (b instanceof _$1) {
      b = b._wrapped;
    }
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) {
      return false;
    }
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) {
          return +b !== +b;
        }
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) != 'object' || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') {
        return false;
      }

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor,
          bCtor = b.constructor;
      if (aCtor !== bCtor && !(_$1.isFunction(aCtor) && aCtor instanceof aCtor && _$1.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) {
        return bStack[length] === b;
      }
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) {
          return false;
        }
      }
    } else {
      // Deep compare objects.
      var keys = _$1.keys(a),
          key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_$1.keys(b).length !== length) {
        return false;
      }
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_$1.has(b, key) && eq(a[key], b[key], aStack, bStack))) {
          return false;
        }
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _$1.isEqual = function (a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _$1.isEmpty = function (obj) {
    if (obj == null) {
      return true;
    }
    if (isArrayLike(obj) && (_$1.isArray(obj) || _$1.isString(obj) || _$1.isArguments(obj))) {
      return obj.length === 0;
    }
    return _$1.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _$1.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _$1.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _$1.isObject = function (obj) {
    var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _$1.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function (name) {
    _$1['is' + name] = function (obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_$1.isArguments(arguments)) {
    _$1.isArguments = function (obj) {
      return _$1.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && (typeof Int8Array === 'undefined' ? 'undefined' : _typeof(Int8Array)) != 'object' && typeof nodelist != 'function') {
    _$1.isFunction = function (obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _$1.isFinite = function (obj) {
    return !_$1.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _$1.isNaN = function (obj) {
    return _$1.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _$1.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _$1.isNull = function (obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _$1.isUndefined = function (obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _$1.has = function (obj, path) {
    if (!_$1.isArray(path)) {
      return obj != null && hasOwnProperty.call(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _$1.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _$1.identity = function (value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _$1.constant = function (value) {
    return function () {
      return value;
    };
  };

  _$1.noop = function () {};

  _$1.property = function (path) {
    if (!_$1.isArray(path)) {
      return shallowProperty(path);
    }
    return function (obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _$1.propertyOf = function (obj) {
    if (obj == null) {
      return function () {};
    }
    return function (path) {
      return !_$1.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _$1.matcher = _$1.matches = function (attrs) {
    attrs = _$1.extendOwn({}, attrs);
    return function (obj) {
      return _$1.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _$1.times = function (n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) {
      accum[i] = iteratee(i);
    }
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _$1.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _$1.now = Date.now || function () {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _$1.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function createEscaper(map) {
    var escaper = function escaper(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _$1.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function (string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _$1.escape = createEscaper(escapeMap);
  _$1.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _$1.result = function (obj, path, fallback) {
    if (!_$1.isArray(path)) {
      path = [path];
    }
    var length = path.length;
    if (!length) {
      return _$1.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _$1.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _$1.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _$1.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function escapeChar(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _$1.template = function (text, settings, oldSettings) {
    if (!settings && oldSettings) {
      settings = oldSettings;
    }
    settings = _$1.defaults({}, settings, _$1.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) {
      source = 'with(obj||{}){\n' + source + '}\n';
    }

    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function template(data) {
      return render.call(this, data, _$1);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _$1.chain = function (obj) {
    var instance = _$1(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function chainResult(instance, obj) {
    return instance._chain ? _$1(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _$1.mixin = function (obj) {
    _$1.each(_$1.functions(obj), function (name) {
      var func = _$1[name] = obj[name];
      _$1.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_$1, args));
      };
    });
    return _$1;
  };

  // Add all of the Underscore functions to the wrapper object.
  _$1.mixin(_$1);

  // Add all mutator Array functions to the wrapper.
  _$1.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
    var method = ArrayProto[name];
    _$1.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) {
        delete obj[0];
      }
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _$1.each(['concat', 'join', 'slice'], function (name) {
    var method = ArrayProto[name];
    _$1.prototype[name] = function () {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _$1.prototype.value = function () {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;

  _$1.prototype.toString = function () {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return _$1;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  var underscore = {
    _: _$1
  };

  var _ = underscore._;

  // -----------------------------------------------------------------
  // extend from kendo.core.js

  function deepExtend(destination) {
    var arguments$1 = arguments;

    var i = 1,
        length = arguments.length;

    for (i = 1; i < length; i++) {
      deepExtendOne(destination, arguments$1[i]);
    }
    return destination;
  }

  function deepExtendOne(destination, source) {
    var property, propValue, propType, propInit, destProp;

    for (property in source) {
      propValue = source[property];
      propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);

      if (propType === 'object' && propValue !== null) {
        propInit = propValue.constructor;
      } else {
        propInit = null;
      }

      if (propInit && propInit !== Array && propInit !== RegExp) {
        if (propValue instanceof Date) {
          destination[property] = new Date(propValue.getTime());
        } else if (_.isFunction(propValue.clone)) {
          destination[property] = _.clone(propValue);
        } else {
          destProp = destination[property];
          if ((typeof destProp === 'undefined' ? 'undefined' : _typeof(destProp)) === 'object') {
            destination[property] = destProp || {};
          } else {
            destination[property] = {};
          }
          deepExtendOne(destination[property], propValue);
        }
      } else if (propType !== 'undefined') {
        destination[property] = propValue;
      }
    }

    return destination;
  }

  var preventDefault = function preventDefault() {
    this._defaultPrevented = true;
  };

  var isDefaultPrevented = function isDefaultPrevented() {
    return this._defaultPrevented === true;
  };

  function SelfClass() {}
  SelfClass.extend = function (proto) {
    var base = function base() {},
        member,
        that = this,
        subclass = proto && proto.init ? proto.init : function () {
      that.apply(this, arguments);
    },
        fn;

    base.prototype = that.prototype;
    fn = subclass.fn = subclass.prototype = new base();

    for (member in proto) {
      if (proto[member] != null && proto[member].constructor === Object) {
        // Merge object members
        // fn[member] = extend(true, {}, base.prototype[member], proto[member])
        // fn[member] = _.extend({}, base.prototype[member], proto[member])
        fn[member] = deepExtend({}, base.prototype[member], proto[member]);
      } else {
        fn[member] = proto[member];

        if (_.isFunction(proto[member])) {
          fn[member].bind(subclass);
        }
      }
    }

    fn.constructor = subclass;
    subclass.extend = that.extend;

    return subclass;
  };

  SelfClass.prototype._initOptions = function (options) {
    this.options = deepExtend({}, this.options, options);
  };

  var Observable = SelfClass.extend({
    init: function init() {
      this._events = {};
      this._name = _.uniqueId('SDK-Observable-');
    },

    getInternalName: function getInternalName() {
      return this._name;
    },

    getMetaDataEvents: function getMetaDataEvents() {
      return this._events;
    },

    bind: function bind(eventName, handlers, one) {
      var that = this,
          idx,
          eventNames = typeof eventName === 'string' ? [eventName] : eventName,
          length,
          original,
          _handler,
          handlersIsFunction = typeof handlers === 'function',
          events;

      if (handlers === undefined) {
        for (idx in eventName) {
          that.bind(idx, eventName[idx]);
        }
        return that;
      }

      for (idx = 0, length = eventNames.length; idx < length; idx++) {
        eventName = eventNames[idx];

        _handler = handlersIsFunction ? handlers : handlers[eventName];

        if (_handler) {
          if (one) {
            original = _handler;
            _handler = function handler() {
              that.unbind(eventName, _handler);
              original.apply(that, arguments);
            };
            _handler.original = original;
          }
          events = that._events[eventName] = that._events[eventName] || [];
          events.push(_handler);
        }
      }

      return that;
    },

    one: function one(eventNames, handlers) {
      return this.bind(eventNames, handlers, true);
    },

    first: function first(eventName, handlers) {
      var that = this,
          idx,
          eventNames = typeof eventName === 'string' ? [eventName] : eventName,
          length,
          handler,
          handlersIsFunction = typeof handlers === 'function',
          events;

      for (idx = 0, length = eventNames.length; idx < length; idx++) {
        eventName = eventNames[idx];

        handler = handlersIsFunction ? handlers : handlers[eventName];

        if (handler) {
          events = that._events[eventName] = that._events[eventName] || [];
          events.unshift(handler);
        }
      }

      return that;
    },

    trigger: function trigger(eventName, e) {
      var that = this,
          events = that._events[eventName],
          idx,
          length;

      if (events) {
        if (_.isString(e)) {
          console.error('e must be {}, not string ');
        }

        e = e || {};

        e.sender = that;

        e._defaultPrevented = false;

        e.preventDefault = preventDefault;

        e.isDefaultPrevented = isDefaultPrevented;

        events = events.slice();

        for (idx = 0, length = events.length; idx < length; idx++) {
          events[idx].call(that, e);
        }

        return e._defaultPrevented === true;
      }

      return false;
    },

    unbind: function unbind(eventName, handler) {
      var that = this,
          events = that._events[eventName],
          idx;

      if (eventName === undefined) {
        that._events = {};
      } else if (events) {
        if (handler) {
          for (idx = events.length - 1; idx >= 0; idx--) {
            if (events[idx] === handler || events[idx].original === handler) {
              events.splice(idx, 1);
            }
          }
        } else {
          that._events[eventName] = [];
        }
      }

      return that;
    }
  });

  var _$3 = underscore._;

  // Object functions
  // -------------------------------------------------------------------------
  var $bc_$1 = {};

  $bc_$1.pN = $bc_$1.pNative = null; // 
  $bc_$1.pIsUseElectron = false; // Electron,
  $bc_$1.pIsUseMacCocoEngine = false; // MacOSX

  // 

  $bc_$1._get_callback = function (func, noDelete) {
    if (noDelete === void 0) noDelete = true;

    var _nativeCallback = {};
    try {
      window._nativeCallback = window._nativeCallback || {};
      _nativeCallback = window._nativeCallback;
    } catch (error) {
      console.error(error);
    }

    var r = _$3.uniqueId('ncb' + _$3.now()) + _$3.uniqueId('n' + _$3.random(0, 99999));
    var rFnc = r + '_fnc';

    _nativeCallback[rFnc] = func;
    _nativeCallback[r] = function () {
      try {
        if (!noDelete) {
          delete _nativeCallback[r];
          delete _nativeCallback[rFnc];
        }
      } catch (e) {
        console.error(e);
      }

      if (_$3.isFunction(func)) {
        func.apply(null, arguments);
      }
    };
    return '_nativeCallback.' + r;
  };

  $bc_$1.cb_execTaskUpdateInfo = null; // 
  $bc_$1.pCorePlugin = { // ,
    useThread: true,
    passBack: 'BS.b$.cb_execTaskUpdateInfo',
    packageMode: 'bundle',
    taskToolPath: '/Plugins/extendLoader.bundle',
    bundleClassName: 'LibCommonInterface'
  };

  $bc_$1.pIAPPlugin = {
    path: '/plugin.iap.bundle'
  };

  // 
  var __auto = function __auto(ref) {
    try {
      if (typeof window.maccocojs !== 'undefined' && _typeof(window.maccocojs) === 'object' && window.maccocojs.hasOwnProperty('app')) {
        ref.pN = ref.pNative = window.maccocojs; // MacOSX
        ref.pIsUseMacCocoEngine = true;
        ref.pIsUseElectron = false;
      } else if ((typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && "function" === 'function' && process.hasOwnProperty('pid')) {
        try {
          console.log('============= must first load =================');
          try {
            window['eletron_require'] = window.require;
            window['eletron_module'] = window.module;

            // Electron1.1.30.34
            try {
              ref.pN = ref.pNative = window.eval('require("remote").require("./romanysoft/maccocojs")');
            } catch (error) {
              ref.pN = ref.pNative = window.eval('require("electron").remote.require("./romanysoft/maccocojs")');
            }

            // require,module
            window.require = undefined;
            window.module.exports = undefined;
            window.module = undefined;
          } catch (error) {
            console.error(error);
          }
          ref.pIsUseElectron = true;
          ref.pIsUseMacCocoEngine = false;
          console.log('============= must first load [end]=================');
        } catch (error) {
          console.error(error);
        }
      }
    } catch (error) {
      console.error(error);
    }

    return ref;
  };

  // Auto install base native Engine
  $bc_$1 = __auto($bc_$1);

  // Define some common function for old app
  // /
  $bc_$1.cb_revealInFinder = null; // 
  $bc_$1.revealInFinder = function (path, cb) {
    path = path || '';
    path = path.trim();
    if ($bc_$1.pN && path !== '') {
      try {
        $bc_$1.pN.window.revealInFinder(JSON.stringify({
          callback: $bc_$1._get_callback(function (obj) {
            cb && cb(obj);
          }, false),
          filePath: path
        }));
      } catch (e) {
        console.error(e);
      }
    } else if (!$bc_$1.pN) {
      alert('');
    }
  };

  // 
  $bc_$1.previewFile = function (paramOptions, cb) {
    if ($bc_$1.pN) {
      try {
        var params = paramOptions || {};
        // 
        params['callback'] = paramOptions['callback'] || $bc_$1._get_callback(function (obj) {
          cb && cb(obj);
        }, true);
        params['filePath'] = paramOptions['filePath'] || '';

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        $bc_$1.pN.window.previewFile(JSON.stringify(params));
      } catch (e) {
        console.error(e);
      }
    } else {
      alert('');
    }
  };

  // 
  $bc_$1.check_supportHtml5Storage = function () {
    try {
      return 'localStorage' in window && window['localStorage'] != null;
    } catch (e) {
      return false;
    }
  };

  // Manifest, callback 
  $bc_$1.defaultManifest_key = 'js_defaultManifest_key';
  $bc_$1.defaultManifest = {};

  // Manifest
  $bc_$1.saveDefaultManifest = function (newManifest) {
    if (!$bc_$1.check_supportHtml5Storage()) {
      return false;
    }
    var obj = {
      manifest: newManifest || $bc_$1.defaultManifest
    };
    var encoded = JSON.stringify(obj);
    try {
      window.localStorage.setItem($bc_$1.defaultManifest_key, encoded);
    } catch (error) {
      console.error(error);
    }

    return true;
  };

  // Manifest
  $bc_$1.revertDefaultManifest = function () {
    try {
      if (!$bc_$1.check_supportHtml5Storage()) {
        return false;
      }
      var encoded = window.localStorage.getItem($bc_$1.defaultManifest_key);
      if (encoded != null) {
        var obj = JSON.parse(encoded);
        $bc_$1.defaultManifest = obj.manifest;
      }
    } catch (error) {
      console.error(error);
    }

    return true;
  };

  $bc_$1.getJQuery$ = function () {
    try {
      var $ = window.jQuery || window.$ || undefined;
      console.assert(_$3.isObject($), 'Must be loaded jQuery library first \n');
      return $;
    } catch (error) {
      console.error(error);
    }
  };

  //
  // -----------------------------------------------
  var common = $bc_$1;

  var _$4 = underscore._;

  var $bc_$2 = common;
  // IAP 
  $bc_$2.IAP_SE_KEY = 'RSSDK_SE_SANBOX_IAP';
  $bc_$2.IAP_SE_OBJ = {};
  $bc_$2.IAP_SE_Wrapper = {
    _caller: 0,
    productIdentifiers: [], // ID 
    caller: function caller() {
      // 
      if (this._caller === 0) {
        var $ = common.getJQuery$();
        this._caller = _$4.isUndefined($) ? new Observable() : $.Callbacks();
      }
      return this._caller;
    }
  };

  // IAP 
  $bc_$2.cb_handleIAPCallback = null; // IAP
  $bc_$2.IAP = {
    _pNoticeCenter: 0,
    NoticeCenter: function NoticeCenter() {
      if (this._pNoticeCenter === 0) {
        var $ = common.getJQuery$();
        this._pNoticeCenter = _$4.isUndefined($) ? new Observable() : $.Callbacks();
      }
      return this._pNoticeCenter;
    }, // Jquery.Callbacks
    MessageType: function () {
      // 
      var msg = [
      // /{}
      'ProductsLoaded', 'ProductBuyFailed', 'ProductPurchased', 'ProductPurchaseFailed', 'ProductPurchaseFailedDetail', 'ProductRequested', 'ProductCompletePurchased',

      // /{}
      'ProductsPaymentQueueRestoreCompleted', 'ProductsPaymentRestoreCompletedTransactionsFailed', 'ProductsPaymentRemovedTransactions', 'ProductsPaymentUpdatedDownloads'];

      var obj = {};
      var i = 0;
      for (i = 0; i < msg.length; ++i) {
        var msgType = msg[i];
        obj[msgType] = msgType;
      }

      return obj;
    }(),

    data: {
      // / IAP
      productIsRequested: false,

      // / Map
      productInfoMap: {},
      // / List
      productInfoList: [],

      // /Methods
      reInit: function reInit() {
        // / 
        var t$ = this;
        t$.productIsRequested = false;
        t$.productInfoMap = {};
        t$.productInfoList = [];
      },
      getProductObj: function getProductObj(productIdentifier) {
        // / 
        var t$ = this;
        var obj = null;
        if (t$.productInfoMap[productIdentifier]) {
          obj = t$.productInfoMap[productIdentifier];
        }
        return obj;
      },
      getPrice: function getPrice(productIdentifier) {
        var t$ = this;
        var obj = t$.getProductObj(productIdentifier);
        if (obj) {
          return obj.price;
        }

        return null;
      },
      getDescription: function getDescription(productIdentifier) {
        var t$ = this;
        var obj = t$.getProductObj(productIdentifier);
        if (obj) {
          return obj.description;
        }

        return null;
      }

    },

    // ///////////////////////////////////////////////////////////////////////////////////////////////////
    // ///////////////////////////////////////////////////////////////////////////////////////////////////
    // / IAPproject.json
    getEnable: function getEnable() {
      if ($bc_$2.pN) {
        try {
          return $bc_$2.pN.app.getIAPEnable();
        } catch (e) {
          console.error(e);
        }
      } else {
        console.log('Romanysoft SDK simulation environment....');
        try {
          var obj = window.localStorage.getItem($bc_$2.IAP_SE_KEY);
          if (!obj) {
            window.localStorage.setItem($bc_$2.IAP_SE_KEY, JSON.stringify($bc_$2.IAP_SE_OBJ));
          } else {
            $bc_$2.IAP_SE_OBJ = JSON.parse(obj);
          }

          return true; // True
        } catch (error) {
          console.error(error);
        }
      }
      return false;
    },

    enableIAP: function enableIAP(paramOptions, cb) {
      var t$ = this;

      try {
        var params = {};
        params['cb_IAP_js'] = paramOptions['cb_IAP_js'] || $bc_$2._get_callback(function (obj) {
          // //////////////////////////////////////////////////////////
          try {
            if (_$4.isObject(obj)) {
              var info = obj.info;
              var notifyType = obj.notifyType;

              if (notifyType === t$.MessageType['ProductRequested']) {
                if (typeof info === 'string') {
                  info = JSON.parse(info);
                }

                t$.data.productIsRequested = true;
                t$.data.productInfoList = info;

                _$4.each(t$.data.productInfoList, function (product, index, list) {
                  t$.data.productInfoMap[product.productIdentifier] = {
                    productIdentifier: product.productIdentifier, // ID
                    description: product.description || '', // 
                    buyUrl: product.buyUrl || '', // 
                    price: product.price || '' // 
                  };
                });
              }
            }
          } catch (e) {
            console.error(e);
          }

          try {
            $bc_$2.IAP.NoticeCenter().fire(obj);
          } catch (e) {}

          // //////////////////////////////////////////////////////////
          if (_$4.isFunction($bc_$2.cb_handleIAPCallback)) {
            $bc_$2.cb_handleIAPCallback && $bc_$2.cb_handleIAPCallback(obj);
          } else {
            cb && cb(obj);
          }

          // ////////////////////////////////////////////////////////////////
        }, true);

        // / 
        console.assert(_$4.isString(params['cb_IAP_js']) === true, 'must be function string');

        // /Ian()
        if (_$4.isArray(paramOptions['productIds'])) {
          params['productIds'] = paramOptions['productIds'] || [];
        }

        // /Ian 2016.12.06 . 
        params['products'] = [];
        if (_$4.isArray(paramOptions['products'])) {
          // [{productIdentifier, description, buyUrl, price}]
          try {
            var productIds = [];
            _$4.each(paramOptions['products'], function (product, index, list) {
              productIds.push(product.productIdentifier);
            });

            if (_$4.isUndefined(params['productIds'] || _$4.isNull(params['productIds']))) {
              params['productIds'] = productIds;
            }

            params['products'] = paramOptions['products'];
          } catch (e) {
            console.error(e);
            alert(e);
          }
        }

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        if ($bc_$2.pN) {
          // IAP
          $bc_$2.pN.iap.regeditIAPCallbackJs(params.cb_IAP_js);

          // IAPBundle
          $bc_$2.pN.iap.regeditIAPCore(JSON.stringify({
            path: $bc_$2.getAppPluginDir() + $bc_$2.pIAPPlugin.path
          }));

          // 
          if ($bc_$2.pN.iap.canMakePayments()) {
            // 
            $bc_$2.pN.iap.startIAPService();

            // 
            $bc_$2.pN.iap.requestProducts(JSON.stringify({
              productIdentifiers: params.productIds || [],
              products: params['products'] || []
            }));
          }

          // / Demo 

          // /IAP
          $bc_$2.IAP_SE_Wrapper.caller().add(function (obj) {
            console.assert(_$4.isString(params.cb_IAP_js) === true, 'must be function string');

            var fnc = window.eval(params.cb_IAP_js);
            if (_$4.isFunction(fnc)) {
              fnc && fnc(obj);
            }
          });

          // /ID
          $bc_$2.IAP_SE_Wrapper.productIdentifiers = params.productIds || [];

          var productsInfo = [];
          _$4.each(params.productIds, function (id, index, list) {
            var productObj = {
              productIdentifier: id,
              description: 'Plugin Description and price demo for ' + id,
              buyUrl: '',
              price: '$0.99'
            };

            productsInfo.push(productObj);
          });

          // /
          $bc_$2.IAP_SE_Wrapper.caller().fire({
            notifyType: t$.MessageType.ProductRequested,
            info: productsInfo
          });
        }
      } catch (e) {
        console.error(e);
      }
    },

    _rebuildInfo: function _rebuildInfo() {
      // 
      var t$ = this;

      try {
        if ($bc_$2.pN) {
          $bc_$2.pN.iap.resetAll();
        } else {
          window.localStorage.removeItem($bc_$2.IAP_SE_KEY);
        }

        t$.data.reInit();
      } catch (e) {}
    },
    _check: function _check(productIdentifier) {
      // 
      var t$ = this;

      var checkFalse = _$4.isUndefined(productIdentifier) || _$4.isNull(productIdentifier);
      // 
      console.assert(checkFalse === false, 'productIdentifier ');
      // 
      var isExists = t$.data.productInfoMap.hasOwnProperty(productIdentifier);
      console.assert(isExists === true, 'productIdentifier EnableIAP');

      if (!isExists) {
        var msg = 'Product [' + productIdentifier + "] is not registered... please see 'EnableIAP' function";
        alert(msg);
      }

      return isExists;
    },

    /**
     * 
     * @param successCallback , [{}]
     * @param failCallback 
     */
    restore: function restore(successCallback, failCallback) {
      var t$ = this;

      // ////////////////////////////////////////////////////////////////////////////
      var _cb = function _cb(obj) {
        try {
          $bc_$2.IAP.NoticeCenter().remove(_cb);
          if (_$4.isObject(obj)) {
            var info = obj.info;
            var notifyType = obj.notifyType;

            if (notifyType === t$.MessageType['ProductsPaymentQueueRestoreCompleted']) {
              successCallback && successCallback(info);
            } else if (t$.MessageType['ProductsPaymentRestoreCompletedTransactionsFailed']) {
              failCallback && failCallback(info, obj);
            }
          }
        } catch (e) {
          console.error(e);
        }
      };

      // 
      $bc_$2.IAP.NoticeCenter().add(_cb);

      if ($bc_$2.pN) {
        // 
        $bc_$2.pN.iap.restoreIAP();
      } else {
        console.log('Romanysoft SDK simulation environment....');
        var obj = window.localStorage.getItem($bc_$2.IAP_SE_KEY);
        if (obj) {
          $bc_$2.IAP_SE_OBJ = JSON.parse(obj);
        }

        var purchasedItemList = []; // 

        // /ID
        _$4.each($bc_$2.IAP_SE_Wrapper.productIdentifiers, function (productID, index, list) {
          if ($bc_$2.IAP_SE_OBJ.hasOwnProperty(productID)) {
            var quantity = $bc_$2.IAP_SE_OBJ[productID];
            if (quantity > 0) {
              var purchasedItem = {
                productIdentifier: productID,
                quantity: quantity
              };

              purchasedItemList.push(purchasedItem);
            }
          }
        });

        // /
        $bc_$2.IAP_SE_Wrapper.caller().fire({
          notifyType: t$.MessageType['ProductsPaymentQueueRestoreCompleted'],
          info: purchasedItemList
        });
      }
    },

    /**
     * 
     * @param params {} productIdentifier  quantity 
     * @param successCallback , 
     * @param failCallback 
     */
    buyProduct: function buyProduct(params, successCallback, failCallback) {
      var t$ = this;
      if (!t$._check(params.productIdentifier)) {
        return;
      }

      // ////////////////////////////////////////////////////////////////////////////
      var _cb = function _cb(obj) {
        try {
          $bc_$2.IAP.NoticeCenter().remove(_cb);
          if (_$4.isObject(obj)) {
            var info = obj.info;
            var notifyType = obj.notifyType;

            if (info.productIdentifier === params.productIdentifier) {
              if (notifyType === t$.MessageType['ProductPurchased']) {
                successCallback && successCallback(info.productIdentifier, obj);
              } else if (t$.MessageType['ProductPurchaseFailed']) {
                failCallback && failCallback(info.productIdentifier, obj);
              }
            }
          }
        } catch (e) {
          console.error(e);
        }
      };

      // 
      $bc_$2.IAP.NoticeCenter().add(_cb);

      if ($bc_$2.pN) {
        // 
        $bc_$2.pN.iap.buyProduct(JSON.stringify({
          identifier: params.productIdentifier,
          quantity: params.quantity || 1
        }));
      } else {
        console.log('Romanysoft SDK simulation environment....');
        var obj = window.localStorage.getItem($bc_$2.IAP_SE_KEY) || JSON.stringify({});

        $bc_$2.IAP_SE_OBJ = JSON.parse(obj);
        var orgQuantity = 0;
        var saveQuantity = 0;
        if ($bc_$2.IAP_SE_OBJ[params.productIdentifier]) {
          orgQuantity = $bc_$2.IAP_SE_OBJ[params.productIdentifier];
          saveQuantity = orgQuantity + params.quantity || 1;
        } else {
          saveQuantity = params.quantity || 1;
        }

        $bc_$2.IAP_SE_OBJ[params.productIdentifier] = saveQuantity;
        window.localStorage.setItem($bc_$2.IAP_SE_KEY, JSON.stringify($bc_$2.IAP_SE_OBJ));

        // 
        $bc_$2.IAP_SE_Wrapper.caller().fire({
          notifyType: t$.MessageType['ProductPurchased'],
          info: {
            productIdentifier: params.productIdentifier,
            quantity: saveQuantity
          }
        });

        // 
        $bc_$2.IAP_SE_Wrapper.caller().fire({
          notifyType: t$.MessageType['ProductCompletePurchased'],
          info: {
            productIdentifier: params.productIdentifier,
            transactionId: 'transactionId' + Math.round(999),
            receipt: 'receipt' + Math.round(999)
          }
        });
      }
    },

    getPrice: function getPrice(productIdentifier) {
      var t$ = this;
      if (!t$._check(productIdentifier)) {
        return;
      }

      if ($bc_$2.pN) {
        if ($bc_$2.App.getSandboxEnable()) {
          return $bc_$2.pN.iap.getPrice(productIdentifier);
        } else {
          return t$.data.getPrice(productIdentifier);
        }
      } else {
        console.log('Romanysoft SDK simulation environment....');
        return t$.data.getPrice(productIdentifier);
      }
    },

    getUseableProductCount: function getUseableProductCount(productIdentifier) {
      var t$ = this;
      if (!t$._check(productIdentifier)) {
        return;
      }

      if ($bc_$2.pN) {
        return $bc_$2.pN.iap.getUseableProductCount(productIdentifier) || 0;
      } else {
        console.log('Romanysoft SDK simulation environment....');
        var quantity = 0;

        var obj = window.localStorage.getItem($bc_$2.IAP_SE_KEY) || JSON.stringify({});
        if (obj) {
          $bc_$2.IAP_SE_OBJ = JSON.parse(obj);
          quantity = $bc_$2.IAP_SE_OBJ[productIdentifier] || 0;
        }

        return quantity;
      }
    },

    setUseableProductCount: function setUseableProductCount(jsonObj) {
      var t$ = this;
      if (!t$._check(jsonObj.productIdentifier)) {
        return;
      }

      if ($bc_$2.pN) {
        var params = {
          identifier: jsonObj.productIdentifier || '',
          quantity: jsonObj.quantity || 1
        };
        return $bc_$2.pN.iap.setUseableProductCount(JSON.stringify(params)) || 0;
      } else {
        console.log('Romanysoft SDK simulation environment....');
        var obj = window.localStorage.getItem($bc_$2.IAP_SE_KEY) || JSON.stringify({});
        if (obj) {
          $bc_$2.IAP_SE_OBJ = JSON.parse(obj);

          var saveQuantity = jsonObj.quantity || 1;
          $bc_$2.IAP_SE_OBJ[jsonObj.productIdentifier] = saveQuantity;
          window.localStorage.setItem($bc_$2.IAP_SE_KEY, JSON.stringify($bc_$2.IAP_SE_OBJ));
          return saveQuantity || 0;
        }
      }

      return 0;
    },

    add1Useable: function add1Useable(productIdentifier) {
      var t$ = this;
      if (!t$._check(productIdentifier)) {
        return;
      }

      if ($bc_$2.pN) {
        return $bc_$2.pN.iap.add1Useable(productIdentifier) || 0;
      } else {
        console.log('Romanysoft SDK simulation environment....');
        var obj = window.localStorage.getItem($bc_$2.IAP_SE_KEY) || JSON.stringify({});
        if (obj) {
          $bc_$2.IAP_SE_OBJ = JSON.parse(obj);

          var orgQuantity = 0;
          var saveQuantity = 0;
          if ($bc_$2.IAP_SE_OBJ[productIdentifier]) {
            orgQuantity = $bc_$2.IAP_SE_OBJ[productIdentifier] || 0;
            saveQuantity = orgQuantity + 1;
          }

          $bc_$2.IAP_SE_OBJ[productIdentifier] = saveQuantity;
          window.localStorage.setItem($bc_$2.IAP_SE_KEY, JSON.stringify($bc_$2.IAP_SE_OBJ));

          return saveQuantity;
        }
      }

      return 0;
    },

    sub1Useable: function sub1Useable(productIdentifier) {
      var t$ = this;
      if (!t$._check(productIdentifier)) {
        return;
      }

      if ($bc_$2.pN) {
        return $bc_$2.pN.iap.sub1Useable(productIdentifier) || 0;
      } else {
        console.log('Romanysoft SDK simulation environment....');
        var obj = window.localStorage.getItem($bc_$2.IAP_SE_KEY) || JSON.stringify({});
        if (obj) {
          $bc_$2.IAP_SE_OBJ = JSON.parse(obj);

          var orgQuantity = 0;
          var saveQuantity = 0;
          if ($bc_$2.IAP_SE_OBJ[productIdentifier]) {
            orgQuantity = $bc_$2.IAP_SE_OBJ[productIdentifier];
            saveQuantity = orgQuantity - 1;
          }

          saveQuantity = saveQuantity > 0 ? saveQuantity : 0;
          $bc_$2.IAP_SE_OBJ[productIdentifier] = saveQuantity;
          window.localStorage.setItem($bc_$2.IAP_SE_KEY, JSON.stringify($bc_$2.IAP_SE_OBJ));

          return saveQuantity;
        }
      }

      return 0;
    }
  };

  //
  // -----------------------------------------------
  var iap = $bc_$2;

  var $bc_$3 = common;

  /**
   * Notice 
   */
  $bc_$3.Notice = {
    alert: function (_alert) {
      function alert(_x) {
        return _alert.apply(this, arguments);
      }

      alert.toString = function () {
        return _alert.toString();
      };

      return alert;
    }(function (jsonObj) {
      if ($bc_$3.pN) {
        var params = {
          message: jsonObj.message || 'Tip',
          title: jsonObj.title || 'Information',
          buttons: jsonObj.buttons || ['Ok'],
          alertType: jsonObj.alertType || 'Alert'
        };

        // / 
        for (var key in jsonObj) {
          if (jsonObj.hasOwnProperty(key)) {
            params[key] = jsonObj[key];
          }
        }

        var returnValue = $bc_$3.pN.notice.alert(JSON.stringify(params));

        // /Fixed: Electron
        if ($bc_$3.pIsUseElectron) {
          return returnValue;
        } else if ($bc_$3.pIsUseMacCocoEngine) {
          /**
              enum {
                  NSAlertDefaultReturn = 1,
                  NSAlertAlternateReturn = 0,
                  NSAlertOtherReturn = -1,
                  NSAlertErrorReturn = -2
              };
            */

          if (returnValue === 1) {
            return 0;
          }
          if (returnValue === 0) {
            return 1;
          }
          if (returnValue === -1) {
            return 2;
          }
          if (returnValue === -2) {
            return 3;
          }
        }
      } else {
        alert(jsonObj.message);
      }
    }),

    notify: function notify(jsonObj, cb) {
      if ($bc_$3.pN) {
        var params = {
          content: jsonObj.message || 'Tip',
          title: jsonObj.title || 'title',
          callback: jsonObj['callback'] || $bc_$3._get_callback(function (obj) {
            cb && cb(obj);
          }, true)
        };

        // / 
        for (var key in jsonObj) {
          if (jsonObj.hasOwnProperty(key)) {
            params[key] = jsonObj[key];
          }
        }

        return $bc_$3.pN.notice.notify(JSON.stringify(params));
      } else {
        alert(jsonObj.message);
      }
    },

    dockMessage: function dockMessage(jsonObj, cb) {
      if ($bc_$3.pN) {
        var params = {
          content: jsonObj.message || 'Tip',
          title: jsonObj.title || 'title',
          callback: jsonObj['callback'] || $bc_$3._get_callback(function (obj) {
            cb && cb(obj);
          }, true)
        };

        // / 
        for (var key in jsonObj) {
          if (jsonObj.hasOwnProperty(key)) {
            params[key] = jsonObj[key];
          }
        }

        if ($bc_$3.pIsUseElectron) {
          if (window.Notification) {
            // HTML5 Notification API
            // http://electron.atom.io/docs/v0.37.8/tutorial/desktop-environment-integration/
            var _notification = new window.Notification(params.title, {
              body: params.content
            });
            _notification.onclick = function () {
              params.callback && params.callback();
            };
          }
        } else {
          return $bc_$3.pN.growl.notify(JSON.stringify(params));
        }
      } else {
        alert(jsonObj.message);
      }
    }
  };

  // -----------------------------------------------
  var notice = $bc_$3;

  var $bc_$4 = common;
  /**
   * App 
   */
  $bc_$4.App = {
    // App
    appName: null,
    getAppName: function getAppName() {
      if ($bc_$4.pN) {
        var t = this;
        if (t.appName) {
          return t.appName;
        }
        t.appName = $bc_$4.pN.app.getAppName();
        return t.appName;
      }
      return 'AppName';
    },

    // 
    appVersion: null,
    getAppVersion: function getAppVersion() {
      if ($bc_$4.pN) {
        var t = this;
        if (t.appVersion) {
          return t.appVersion;
        }
        t.appVersion = $bc_$4.pN.app.getAppVersion();
        return t.appVersion;
      }
      return '4.5.6';
    },

    // 
    appBuildVersion: null,
    getAppBuildVersion: function getAppBuildVersion() {
      if ($bc_$4.pN) {
        var t = this;
        if (t.appBuildVersion) {
          return t.appBuildVersion;
        }
        t.appBuildVersion = $bc_$4.pN.app.getAppBuildVersion();
        return t.appBuildVersion;
      }
      return '201506271454';
    },

    // ID
    appId: null,
    getAppId: function getAppId() {
      if ($bc_$4.pN) {
        var t = this;
        if (t.appId) {
          return t.appId;
        }
        t.appId = $bc_$4.pN.app.getAppIdentifier();
        return t.appId;
      }
      return 'AppID';
    },

    // 
    getAppArgv: function getAppArgv() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getAppArgv();
      }

      return [];
    },

    // 
    sysOS: null,
    getAppRunOnOS: function getAppRunOnOS() {
      if ($bc_$4.pN && !$bc_$4.pIsUseMacCocoEngine) {
        var t = this;
        if (t.sysOS) {
          return t.sysOS;
        }
        t.sysOS = $bc_$4.pN.app.getAppRunOnOS();
        return t.sysOS;
      }
      return 'MacOSX'; // MacOSXElectron
    },

    // App
    getSandboxEnable: function getSandboxEnable() {
      if ($bc_$4.pN) {
        var sandboxEnable = $bc_$4.pN.app.getSandboxEnable();
        return sandboxEnable;
      }
      return false;
    },

    // App
    getIsRegistered: function getIsRegistered() {
      var t$ = this;
      if ($bc_$4.pN) {
        if (t$.getSandboxEnable()) {
          return true;
        }
        return $bc_$4.pN.app.getIsRegistered();
      }
      return false;
    },

    // App
    getRegInfoJSONString: function getRegInfoJSONString() {
      if ($bc_$4.pN) {
        var str = $bc_$4.pN.app.getRegInfoJSONString();
        return str;
      }
      return '';
    },

    // App
    getSerialNumber: function getSerialNumber() {
      try {
        if ($bc_$4.pN) {
          var str = $bc_$4.pN.app.getStringSerialNumber();
          return str;
        }
      } catch (e) {
        console.error(e);
      }

      return '';
    },

    // IP
    getLocalIP: function getLocalIP() {
      if ($bc_$4.pN) {
        var str = $bc_$4.pN.app.getLocalIP();
        return str;
      }
      return '';
    },

    // 
    terminate: function terminate() {
      if ($bc_$4.pN) {
        $bc_$4.pN.app.terminate();
      }
    },

    // 
    relaunch: function relaunch() {
      if ($bc_$4.pN) {
        $bc_$4.pN.app.relaunch();
      }
    },

    // 
    activate: function activate() {
      if ($bc_$4.pN) {
        $bc_$4.pN.app.activate();
      }
    },

    // 
    hide: function hide() {
      if ($bc_$4.pN) {
        $bc_$4.pN.app.hide();
      }
    },

    // 
    unhide: function unhide() {
      if ($bc_$4.pN) {
        $bc_$4.pN.app.unhide();
      }
    },

    // beep
    beep: function beep() {
      if ($bc_$4.pN) {
        $bc_$4.pN.app.beep();
      }
    },

    // Bounce
    bounce: function bounce() {
      if ($bc_$4.pN) {
        $bc_$4.pN.app.bounce();
      }
    },

    // 
    open: function open(data) {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.open(data || 'http://www.baidu.com');
      } else {
        try {
          window.open(data);
        } catch (e) {}
      }
    },

    // 
    openFileWithDefaultApp: function openFileWithDefaultApp(filePath) {
      if ($bc_$4.pN) {
        var _path = filePath || $bc_$4.pN.path.tempDir() + 'tmp.txt';
        $bc_$4.pN.app.openFile(_path);
      }
    },

    // 
    launchApplication: function launchApplication(applicationName) {
      if ($bc_$4.pN) {
        $bc_$4.pN.app.launch(applicationName || 'Safari'); // Safari.app
      }
    },

    // 
    sendEmail: function sendEmail(jsonObj) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['sendAddress'] = jsonObj['sendAddress'] || 'admin@gmail.com';
          params['toAddress'] = jsonObj['toAddress'] || 'admin@gmail.com';
          params['subject'] = jsonObj['subject'] || 'Hello';
          params['body'] = jsonObj['body'] || 'Hello!!';

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$4.pN.app.sendEmailWithMail(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      } else {
        alert('');
      }
    },

    // {}
    // {App }
    isStartAtLogin: function isStartAtLogin() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.isStartAtLogin();
      }

      return false;
    },

    // {App }
    setStartAtLogin: function setStartAtLogin(enable) {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.setStartAtLogin(enable); // 
      }
    },

    // {NSUserDefaults}
    // {key: value: },Map
    setInfoToUserDefaults: function setInfoToUserDefaults(jsonObj) {
      if ($bc_$4.pN) {
        var obj = jsonObj || {
          callback: 'console.log',
          key: '',
          value: ''
        };

        // 
        for (var key in jsonObj) {
          if (jsonObj.hasOwnProperty(key)) {
            obj[key] = jsonObj[key];
          }
        }

        $bc_$4.pN.window.setInfoToUserDefaults(JSON.stringify(obj));
      }
    },
    // {key: value: },Map
    getInfoFromUserDefaults: function getInfoFromUserDefaults(jsonObj) {
      if ($bc_$4.pN) {
        var obj = jsonObj || {
          callback: 'console.log',
          key: ''
        };

        // 
        for (var key in jsonObj) {
          if (jsonObj.hasOwnProperty(key)) {
            obj[key] = jsonObj[key];
          }
        }

        $bc_$4.pN.window.getInfoFromUserDefaults(JSON.stringify(obj));
      }
    },
    // {key: value: },Map
    removeItemFromUserDefaults: function removeItemFromUserDefaults(jsonObj) {
      if ($bc_$4.pN) {
        var obj = jsonObj || {
          callback: 'console.log',
          key: ''
        };
        // 
        for (var key in jsonObj) {
          if (jsonObj.hasOwnProperty(key)) {
            obj[key] = jsonObj[key];
          }
        }

        $bc_$4.pN.window.removeItemFromUserDefaults(JSON.stringify(obj));
      }
    },

    // {App}
    setOptions_RateAppClose: function setOptions_RateAppClose(enable) {
      $bc_$4.App.setInfoToUserDefaults({
        key: 'RateApp_CLOSE',
        value: enable
      });
    },

    // {}
    getServerPort: function getServerPort() {
      var default_port = 8888;
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getHttpServerPort() || default_port;
      }

      return default_port;
    },

    // App
    getAppPluginDir: $bc_$4.getAppPluginDir = function () {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.appPluginDirPath();
      }
      return '';
    },

    // ApplicationResource
    getAppResourceDir: $bc_$4.getAppResourceDir = function () {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.resource();
      }
      return '';
    },

    // Public
    getAppResourcePublicDir: $bc_$4.getAppResourcePublicDir = function () {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.resource() + '/public';
      }
      return '';
    },

    // App
    getAppBundlePath: function getAppBundlePath() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.application();
      }
      return '';
    },

    // AppDataHomeDir
    getAppDataHomeDir: function getAppDataHomeDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.appDataHomeDir();
      }
      return '';
    },

    // Home Directory
    getHomeDir: function getHomeDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.homeDir();
      }
      return '';
    },

    // DocumentsDir
    getDocumentsDir: function getDocumentsDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.documentsDir();
      }
      return '';
    },

    // Documents
    getLocalDocumentsDir: function getLocalDocumentsDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.localDocumentsDir();
      }
      return '';
    },

    // LibraryDir
    getLibraryDir: function getLibraryDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.libraryDir();
      }
      return '';
    },

    // 
    getTempDir: function getTempDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.tempDir();
      }
      return '';
    },

    // Cache
    getCacheDir: function getCacheDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.cacheDir();
      }
      return '';
    },

    // Application
    getApplicationDir: function getApplicationDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.applicationDir();
      }
      return '';
    },

    // DesktopDir
    getDesktopDir: function getDesktopDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.desktopDir();
      }
      return '';
    },

    // downloadDir
    getDownloadDir: function getDownloadDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.downloadDir();
      }
      return '';
    },

    // download
    getLocalDownloadDir: function getLocalDownloadDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.localDownloadDir();
      }
      return '';
    },

    // desktop
    getLocalDesktopDir: function getLocalDesktopDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.localDesktopDir();
      }
      return '';
    },

    // Library
    getLocalLibraryDir: function getLocalLibraryDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.localLibraryDir();
      }
      return '';
    },

    // Movies
    getMoviesDir: function getMoviesDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.moviesDir();
      }
      return '';
    },

    // Movies
    getLocalMoviesDir: function getLocalMoviesDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.localMoviesDir();
      }
      return '';
    },

    // Music
    getMusicDir: function getMusicDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.musicDir();
      }
      return '';
    },

    // Music
    getLocalMusicDir: function getLocalMusicDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.localMusicDir();
      }
      return '';
    },

    // Pictures
    getPicturesDir: function getPicturesDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.picturesDir();
      }
      return '';
    },

    // Pictures
    getLocalPicturesDir: function getLocalPicturesDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.localPicturesDir();
      }
      return '';
    },

    // UserName
    getUserName: function getUserName() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.userName();
      }
      return '';
    },

    // User(UserFullName)
    getUserFullName: function getUserFullName() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.userFullName();
      }
      return '';
    },

    // Documents
    getWritableDocumentsDir: function getWritableDocumentsDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.appWriteableDocumentDir();
      }
      return '';
    },
    // Download
    getWritableDownloadDir: function getWritableDownloadDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.appWriteableDownloadDir();
      }
      return '';
    },
    // Music
    getWritableMusicDir: function getWritableMusicDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.appWriteableMusicDir();
      }
      return '';
    },
    // Movies
    getWritableMoviesDir: function getWritableMoviesDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.appWriteableMoviesDir();
      }
      return '';
    },
    // Pictures
    getWritablePicturesDir: function getWritablePicturesDir() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.appWriteablePicturesDir();
      }
      return '';
    },

    // 
    checkPathIsExist: $bc_$4.pathIsExist = function (path) {
      if (path.trim() === '') {
        return false;
      }

      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir();
        return $bc_$4.pN.path.pathIsExist(_path);
      }

      return true;
    },

    // 0Byte
    checkFileIsZero: $bc_$4.checkFileIsZeroSize = function (file_path) {
      if (file_path.trim() === '') {
        return false;
      }

      if ($bc_$4.pN) {
        var _path = file_path || $bc_$4.pN.path.tempDir();
        return $bc_$4.pN.path.fileIsZeroSize(_path);
      }

      return false;
    },

    // 
    checkPathIsWritable: $bc_$4.checkPathIsWritable = function (path) {
      if (path.trim() === '') {
        return false;
      }

      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir();
        return $bc_$4.pN.path.checkPathIsWritable(_path);
      }

      return true;
    },

    // 
    createEmptyFile: $bc_$4.createEmptyFile = function (file_path, cb) {
      if ($bc_$4.pN) {
        var _path = file_path || $bc_$4.pN.path.tempDir() + 'tmp.txt';
        return $bc_$4.pN.window.createEmptyFile(JSON.stringify({
          path: _path,
          callback: $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true)
        }));
      }
    },

    // 
    createDir: $bc_$4.createDir = function (dir_path, atts, cb) {
      if ($bc_$4.pN) {
        try {
          var params = {};
          // 
          params['callback'] = params['callback'] || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true);
          params['path'] = dir_path || $bc_$4.pN.path.tempDir() + 'tmp_dir001';
          if (atts) {
            params['atts'] = atts || {};
          }

          $bc_$4.pN.window.createDir(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // 
    removeFile: $bc_$4.removeFile = function (file_path, cb) {
      if ($bc_$4.pN) {
        var _path = file_path || $bc_$4.pN.path.tempDir() + 'tmp.txt';
        return $bc_$4.pN.window.removeFile(JSON.stringify({
          path: _path,
          callback: $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true)
        }));
      }
    },

    // 
    removeDir: $bc_$4.removeDir = function (dir_path, cb) {
      if ($bc_$4.pN) {
        try {
          var params = {};
          // 
          params['callback'] = params['callback'] || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true);
          params['path'] = dir_path || $bc_$4.pN.path.tempDir() + '/tmp_dir001';

          $bc_$4.pN.window.removeDir(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // 
    copyFile: $bc_$4.copyFile = function (jsonObj, cb) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['callback'] = jsonObj['callback'] || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true);
          params['src'] = jsonObj['src'] || '';
          params['dest'] = jsonObj['dest'] || '';

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$4.pN.window.copyFile(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // 
    copyDir: $bc_$4.copyDir = function (jsonObj, cb) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['callback'] = jsonObj['callback'] || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true);
          params['src'] = jsonObj['src'] || '';
          params['dest'] = jsonObj['dest'] || '';

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$4.pN.window.copyDir(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // 
    moveFile: $bc_$4.moveFile = function (jsonObj, cb) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['callback'] = jsonObj['callback'] || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true);
          params['src'] = jsonObj['src'] || '';
          params['dest'] = jsonObj['dest'] || '';

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$4.pN.window.moveFile(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // 
    moveDir: $bc_$4.moveDir = function (jsonObj, cb) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['callback'] = jsonObj['callback'] || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true);
          params['src'] = jsonObj['src'] || '';
          params['dest'] = jsonObj['dest'] || '';

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$4.pN.window.moveDir(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // 
    findFile: $bc_$4.findFile = function (dir, fileName, cbName, cb) {
      if ($bc_$4.pN) {
        var _dir = dir || $bc_$4.pN.path.tempDir();
        var _fileName = fileName || 'tmp.txt';

        var params = {
          callback: cbName || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true),
          dir: _dir,
          fileName: _fileName
        };

        return $bc_$4.pN.window.findFile(JSON.stringify(params));
      }

      return null;
    },

    // 
    checkPathIsReadable: function checkPathIsReadable(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir();
        return $bc_$4.pN.path.checkPathIsReadable(_path);
      }

      return false;
    },

    // 
    checkPathIsExecutable: function checkPathIsExecutable(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir();
        return $bc_$4.pN.path.checkPathIsExecutable(_path);
      }

      return false;
    },

    // 
    checkPathIsDeletable: function checkPathIsDeletable(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir();
        return $bc_$4.pN.path.checkPathIsDeletable(_path);
      }

      return false;
    },

    // 
    checkPathIsFile: function checkPathIsFile(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir();
        return $bc_$4.pN.path.checkPathIsFile(_path);
      }

      return false;
    },

    // 
    checkPathIsDir: function checkPathIsDir(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir();
        return $bc_$4.pN.path.checkPathIsDir(_path);
      }

      return false;
    },

    getFileName: function getFileName(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir() + 'tmp.txt';
        return $bc_$4.pN.path.getFileName(_path);
      }

      return '';
    },

    // 
    getFileExt: function getFileExt(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir() + 'tmp.txt';
        return $bc_$4.pN.path.getFileExt(_path);
      }

      return '';
    },

    // 
    getPathParentPath: function getPathParentPath(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir();
        return $bc_$4.pN.path.getPathParentPath(_path);
      }

      return '';
    },

    // 
    getFilePropertyJSONString: function getFilePropertyJSONString(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir() + 'tmp.txt';
        return $bc_$4.pN.path.getFilePropertyJSONString(_path);
      }

      return '';
    },

    // png
    getFileOrDirIconPath: function getFileOrDirIconPath(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir() + 'tmp.txt';
        return $bc_$4.pN.path.getFileOrDirIconPath(_path);
      }

      return '';
    },

    // 
    getNewTempFilePath: function getNewTempFilePath(fileName) {
      if ($bc_$4.pN) {
        return $bc_$4.pN.path.getNewTempFilePath(fileName || 'rs.txt'); // fileName 
      }

      return '';
    },

    // App
    /**
     *
     * @param path 
     * @param cb   
     * 
     *
     */
    getOtherAppInfo: function getOtherAppInfo(path, cb) {
      if ($bc_$4.pN) {
        try {
          var params = {};
          // 
          params['callback'] = params['callback'] || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true);
          params['path'] = path || $bc_$4.pN.path.tempDir() + '/tmp_dir001';

          return $bc_$4.pN.window.getOtherAppInfo(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }

      return '';
    },

    /**
     * 
     * 
     * ${HOME}
     * ${BUNDLE}
     * ${BUNDEL_RESOURCE}
     * ${BUNDEL_PLUGIN}
     * ${DOCUMENTS}
     * ${LIBRARY}
     * ${TEMP}
     * ${CACHE}
     * ${APPLICATION}
     * ${DESKTOP}
     * ${DOWNLOAD}
     * ${MOVIES}
     * ${MUSIC}
     * ${PICTURES}
     * ${APPW_DOCUMENTS}
     * ${APPW_DOWNLOAD}
     * ${APPW_MOVIES}
     * ${APPW_MUSIC}
     * ${APPW_PICTURES}
     * ${LOCAL_DESKTOP}
     * ${LOCAL_DOWNLOAD}
     * ${LOCAL_MOVIES}
     * ${LOCAL_MUSIC}
     * ${LOCAL_PICTURES}
     * ${LOCAL_LIBRARY}
     * ${LOCAL_DOCUMENTS}
     * ${USER_NAME}
     * ${USER_FULL_NAME}
     * ${APPDATA_HOME}
     * ${APP_UI_DIR}
     * ${APP_NAME}
     * ${APP_VERSION}
     * ${APP_BUILD_VERSION}
     * ${APP_ID}
     * @param str
     * @returns {*}
     */
    getUpdateEnvString: function getUpdateEnvString(str) {
      if ($bc_$4.pN) {
        try {
          return $bc_$4.pN.path.getUpdateEnvString(str);
        } catch (e) {
          console.error(e);
        }
      }

      return '';
    },

    // /size( 1024)
    fileSizeAtPath: function fileSizeAtPath(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir() + 'tmp.txt';
        return $bc_$4.pN.app.fileSizeAtPath(_path);
      }

      return '';
    },

    // /( 1000)
    diskSizeAtPath: function diskSizeAtPath(path) {
      if ($bc_$4.pN) {
        var _path = path || $bc_$4.pN.path.tempDir() + 'tmp.txt';
        return $bc_$4.pN.app.diskSizeAtPath(_path);
      }

      return '';
    },

    // md5
    md5Digest: function md5Digest(str) {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.md5Digest(str || 'testMd5');
      }

      return '';
    },

    // {}
    getBuyURL: function getBuyURL() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getBuyURL();
      }
      return '';
    },

    getFAQURL: function getFAQURL() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getFAQURL();
      }
      return '';
    },

    getHomePageURL: function getHomePageURL() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getHomePageURL();
      }
      return '';
    },

    getDocumentPageURL: function getDocumentPageURL() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getDocumentPageURL();
      }
      return '';
    },

    getRoadmapPageURL: function getRoadmapPageURL() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getRoadmapPageURL();
      }
      return '';
    },

    getReportIssuePageURL: function getReportIssuePageURL() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getReportIssuePageURL();
      }
      return '';
    },

    getViewLicensePageURL: function getViewLicensePageURL() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getViewLicensePageURL();
      }
      return '';
    },

    getReleaseNotesPageURL: function getReleaseNotesPageURL() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getReleaseNotesPageURL();
      }
      return '';
    },

    getCheckForUpdatePageURL: function getCheckForUpdatePageURL() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.getCheckForUpdatePageURL();
      }
      return '';
    },

    // 
    getAppleLanguage: function getAppleLanguage() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.curAppleLanguage();
      }

      return 'en-US';
    },

    // Google
    getCompatibleGoogleLanguageInfo: function getCompatibleGoogleLanguageInfo() {
      var info = {
        'auto': {
          'af': 'Spoor taal',
          'sq': 'Zbulo gjuhn',
          'ar': '  ',
          'hy': ' ',
          'az': 'Dil akar',
          'eu': 'Hizkuntza atzeman',
          'be': ' ',
          'bn': '  ',
          'bs': 'Detect jeziku',
          'bg': '  ',
          'ca': 'Detectar idioma',
          'ceb': 'Makamatikod pinulongan',
          'ny': 'azindikire chinenero',
          'zh-CN': '',
          'zh-TW': '',
          'hr': 'Otkrij jezik',
          'cs': 'Rozpoznat jazyk',
          'da': 'Registrer sprog',
          'nl': 'Detect taal',
          'en': 'Detect language',
          'eo': 'Detekti lingvo',
          'et': 'Tuvasta keel',
          'tl': 'Alamin ang wika',
          'fi': 'Tunnista kieli',
          'fr': 'Dtecter la langue',
          'gl': 'Detectar idioma',
          'ka': ' ',
          'de': 'Sprache erkennen',
          'el': ' ',
          'gu': ' ',
          'ht': 'Detekte lang',
          'ha': 'Gano harshen',
          'iw': ' ',
          'hi': '   ',
          'hmn': 'Ntes lus',
          'hu': 'Nyelv felismerse',
          'is': 'Greina tunguml',
          'ig': 'chpta ass',
          'id': 'Deteksi bahasa',
          'ga': 'Braith teanga',
          'it': 'Rileva lingua',
          'ja': '',
          'jw': 'Ndeteksi basa',
          'kn': ' ',
          'kk': ' ',
          'km': '',
          'ko': ' ',
          'lo': '',
          'la': 'Deprehendere linguae',
          'lv': 'Noteikt valodu',
          'lt': 'Aptikti kalb',
          'mk': '  ',
          'ms': 'Kesan bahasa',
          'ml': ' ',
          'mt': 'Jindunaw lingwa',
          'mi': 'Kitea te reo',
          'mr': ' ',
          'mn': ' ',
          'my': ' detect',
          'ne': '  ',
          'no': 'Detect sprk',
          'fa': ' ',
          'pl': 'Wykryj jzyk',
          'pt': 'Detectar idioma',
          'pa': '   ',
          'ma': ' ',
          'ro': 'Detecta limb',
          'ru': ' ',
          'sr': ' ',
          'st': 'khona ho utloa puo',
          'si': ' ',
          'sk': 'Rozpozna jazyk',
          'sl': 'Zaznaj jezik',
          'so': 'Ogaado luqadda',
          'es': 'Detectar idioma',
          'sw': 'Kuchunguza lugha',
          'sv': 'Identifiera sprk',
          'tg': ' ',
          'ta': ' ',
          'te': ' ',
          'th': '',
          'tr': 'Dili algla',
          'uk': ' ',
          'ur': '   ',
          'uz': 'tilni aniqlash',
          'vi': 'Pht hin ngn ng',
          'cy': 'Canfod iaith',
          'yi': ' ',
          'yo': 'Ri ede',
          'zu': 'Thola ulimi'
        },
        'local': {
          'af': 'Afrikaans',
          'sq': 'Shqiptar',
          'ar': '',
          'hy': '',
          'az': 'Azrbaycan',
          'eu': 'Euskal',
          'be': '',
          'bn': '',
          'bs': 'Bosanski',
          'bg': '',
          'ca': 'Catal',
          'ceb': 'Cebuano',
          'ny': 'Chichewa',
          'zh-CN': '',
          'zh-TW': '',
          'hr': 'Hrvatski',
          'cs': 'etina',
          'da': 'Dansk',
          'nl': 'Nederlands',
          'en': 'English',
          'eo': 'Esperanto',
          'et': 'Eesti',
          'tl': 'Pilipino',
          'fi': 'Suomi',
          'fr': 'Franais',
          'gl': 'Galega',
          'ka': '',
          'de': 'Deutsch',
          'el': '',
          'gu': '',
          'ht': 'Kreyl ayisyen',
          'ha': 'Hausa',
          'iw': '',
          'hi': '',
          'hmn': 'Hmoob',
          'hu': 'Magyar',
          'is': 'Icelandic',
          'ig': 'Igbo',
          'id': 'Indonesia',
          'ga': 'Gaeilge',
          'it': 'Italiano',
          'ja': '',
          'jw': 'Jawa',
          'kn': '',
          'kk': '',
          'km': '',
          'ko': '',
          'lo': '',
          'la': 'Latine',
          'lv': 'Latvijas',
          'lt': 'Lietuvos',
          'mk': '',
          'ms': 'Melayu',
          'ml': '',
          'mt': 'Malti',
          'mi': 'Maori',
          'mr': '',
          'mn': '',
          'my': ' ()',
          'ne': '',
          'no': 'Norsk',
          'fa': '',
          'pl': 'Polski',
          'pt': 'Portugus',
          'pa': ' ',
          'ma': ' ',
          'ro': 'Romn',
          'ru': '',
          'sr': '',
          'st': 'Sesotho',
          'si': '',
          'sk': 'Slovensk',
          'sl': 'Slovenina',
          'so': 'Somali',
          'es': 'Espaol',
          'sw': 'Kiswahili',
          'sv': 'Svenska',
          'tg': '',
          'ta': '',
          'te': '',
          'th': '',
          'tr': 'Trk',
          'uk': '',
          'ur': '',
          'uz': "O'zbekiston",
          'vi': 'Ting Vit',
          'cy': 'Cymraeg',
          'yi': '',
          'yo': 'Yoruba',
          'zu': 'Zulu'
        }
      };

      return info;
    },

    // , Native
    getCompatibleWebkitLanguageList: function getCompatibleWebkitLanguageList(_getType) {
      var getType = _getType || 'Native2Webkit'; // WebKit

      var defaultLanguage = 'en';
      // 
      var NativeApple2WebKitLanguageMap = {
        'Unknown': [''],
        'en': ['en', 'en-US', 'en-us'], // 

        'fr': ['fr', 'fr-FR', 'fr-fr'], // French (fr) 

        'de': ['de', 'de-DE', 'de-de'], // German (de) 

        'zh-Hans': ['zh', 'zh-CN', 'zh-cn', 'zh-Hans'], // Chinese (Simplified) (zh-Hans) 

        'zh-Hant': ['zh-TW', 'zh-tw', 'zh-Hant'], // Chinese (Traditional) (zh-Hant) 

        'ja': ['ja', 'ja-JP', 'ja-jp'], // Japanese (ja) 

        'es': ['es', 'es-ES', 'es-es'], // Spanish (es) 

        'es-MX': ['es-MX', 'es-XL', 'es-xl'], // Spanish (Mexico) (es-MX) 

        'it': ['it', 'it-IT', 'it-it'], // Italian (it) 

        'nl': ['nl', 'nl-NL', 'nl-nl'], // Dutch (nl) 

        'ko': ['ko', 'ko-KR', 'ko-kr'], // Korean (ko) 

        'pt': ['pt', 'pt-BR', 'pt-br'], // Portuguese (pt) 

        'pt-PT': ['pt-PT', 'pt-pt'], // Portuguese (Portugal) (pt) 

        'da': ['da', 'da-DK', 'da-da'], // Danish (da) 

        'fi': ['fi', 'fi-FI', 'fi-fi'], // Finnish (fi) 

        'nb': ['nb', 'nb-NO', 'nb-no'], // Norwegian Bokmal (nb) 

        'sv': ['sv', 'sv-SE', 'sv-se'], // Swedish (sv) 

        'ru': ['ru', 'ru-RU', 'ru-ru'], // Russian (ru) 

        'pl': ['pl', 'pl-PL', 'pl-pl'], // Polish (pl) 

        'tr': ['tr', 'tr-TR', 'tr-tr'], // Turkish (tr) 

        'ar': ['ar', 'AR'], // Arabic (ar) 

        'th': ['th', 'th-TH', 'th-th'], // Thai (th) 

        'cs': ['cs', 'cs-CZ', 'cs-cz'], // Czech (cs) 

        'hu': ['hu', 'hu-HU', 'hu-hu'], // Hungarian (hu) 

        'ca': ['ca', 'ca-ES', 'ca-es'], // Catalan (ca) 

        'hr': ['hr', 'hr-HR', 'hr-hr'], // Croatian (hr) 

        'el': ['el', 'el-GR', 'el-gr'], // Greek (el) 

        'he': ['he', 'he-IL', 'he-il'], // Hebrew (he) 

        'ro': ['ro', 'ro-RO', 'ro-ro'], // Romanian (ro) 

        'sk': ['sk', 'sk-SK', 'sk-sk'], // Slovak (sk) 

        'uk': ['uk', 'uk-UA', 'uk-ua'], // Ukrainian (uk) 

        'id': ['id', 'ID', 'id-ID', 'id-id'], // Indonesian (id) 

        'ms': ['ms', 'MS', 'ms-MS', 'ms-ms'], // Malay (ms) 

        'vi': ['vi', 'vi-VN', 'vi-vn'] // Vietnamese (vi) 
      };

      if (getType === 'Native2Webkit') {
        // NativeMap
        var appleLanguage = 'en-US';
        if ($bc_$4.pN) {
          appleLanguage = $bc_$4.pN.app.curAppleLanguage();
        }

        if (NativeApple2WebKitLanguageMap.hasOwnProperty(appleLanguage)) {
          return NativeApple2WebKitLanguageMap[appleLanguage];
        }

        return NativeApple2WebKitLanguageMap[defaultLanguage];
      } else if (getType === 'webkitCompatible') {
        var mapValue = null;
        var webLanguage = navigator.language || 'en';

        var inArray = function inArray(value, array) {
          if (Array.prototype.indexOf) {
            return array.indexOf(value);
          } else {
            for (var i = 0; i < array.length; i++) {
              if (array[i] === value) {
                return i;
              }
            }
            return -1;
          }
        };

        for (var key in NativeApple2WebKitLanguageMap) {
          if (NativeApple2WebKitLanguageMap.hasOwnProperty(key)) {
            var languageArray = NativeApple2WebKitLanguageMap[key];
            if (inArray(webLanguage, languageArray) > -1) {
              mapValue = languageArray;
              break;
            }
          }
        }

        return mapValue;
      }

      return console.error(':Native2Webkit webkitCompatible');
    },

    // 
    setUserLanguage: function setUserLanguage(language) {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.setUserLanguage(language || 'en-US');
      }
    },

    // 
    getUserLanguage: function getUserLanguage() {
      if ($bc_$4.pN) {
        return $bc_$4.pN.app.curUserLanguage();
      }

      return 'en-US';
    },

    // []
    captureFull: function captureFull(jsonObj, cb) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['callback'] = params['callback'] || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true);
          params['filePath'] = params['filePath'] || $bc_$4.pN.path.tempDir() + 'cap_screen.png'; // 

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }
          $bc_$4.pN.window.capture(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // 
    addDirPathToChangeWatcher: function addDirPathToChangeWatcher(jsonObj, cb) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};

          params['callback'] = params['callback'] || $bc_$4._get_callback(function (obj) {
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileWritten"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileAttributesChanged"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileSizeIncreased"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"AccessWasRevoked"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"LinkCountChanged"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileRenamed"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileDeleted"} (app.js, line 270)
            cb && cb(obj);
          }, true);
          params['path'] = params['path'] || $bc_$4.pN.path.tempDir();

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$4.pN.window.createDirChangeWatcher(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // 
    addFilePathToChangeWatcher: function addFilePathToChangeWatcher(jsonObj, cb) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};

          params['callback'] = params['callback'] || $bc_$4._get_callback(function (obj) {
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileWritten"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileAttributesChanged"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileSizeIncreased"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"AccessWasRevoked"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"LinkCountChanged"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileRenamed"} (app.js, line 270)
            // [Log] {"path":"/Users/Ian/Documents/New_1433573622398.md","flag":"FileDeleted"} (app.js, line 270)
            cb && cb(obj);
          }, true);
          params['path'] = params['path'] || $bc_$4.pN.path.tempDir();

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$4.pN.window.createFileChangeWatcher(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // 
    removeFromChangeWatcher: function removeFromChangeWatcher(jsonObj) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};
          params['path'] = params['path'] || $bc_$4.pN.path.tempDir();

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          return $bc_$4.pN.window.removeFromChangeWatcher(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }

      return false;
    },

    //  ()
    print: function print(jsonObj) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};
          params['silent'] = params['silent'] || false;
          params['printBackground'] = params['printBackground'] || false;

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          return $bc_$4.pN.window.print(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    },

    // PDF  ()
    printToPDF: function printToPDF(jsonObj, cb) {
      if ($bc_$4.pN) {
        try {
          var params = jsonObj || {};
          params['callback'] = params['callback'] || $bc_$4._get_callback(function (obj) {
            cb && cb(obj);
          }, true);
          params['marginsType'] = params['marginsType'] || 0;
          params['pageSize'] = params['pageSize'] || 'A4';
          params['printBackground'] = params['printBackground'] || false;
          params['printSelectionOnly'] = params['printSelectionOnly'] || false;
          params['landscape'] = params['landscape'] || false;
          params['filePath'] = params['filePath'] || $bc_$4.pN.path.tempDir() + '/' + Date.now() + '.pdf';

          // 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          return $bc_$4.pN.window.printToPDF(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    }

  };

  //
  // -----------------------------------------------
  var app = $bc_$4;

  var $bc_$5 = common;

  /**
  * XPC 
  * @type {{install: Function, unInstall: Function, find: Function, resume: Function, suspend: Function, invalidate: Function, sendMessage: Function}}
  */
  $bc_$5.XPC = {
    /**
    * XPC
    * @param jsonObj
    * @returns {*}
    */
    install: function install(jsonObj) {
      if (jsonObj === void 0) jsonObj = {};

      if ($bc_$5.pN) {
        try {
          var params = {
            key: jsonObj.xpc_key || 'default',
            id: jsonObj.bundleID || 'com.romanysoft.app.mac.xpc.AgentHelper'
          };

          // / 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          return $bc_$5.pN.app.registerNewXPCService(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }

      return false;
    },

    /**
    * XPC
    * @param xpc_key
    * @returns {*}
    */
    unInstall: function unInstall(xpc_key) {
      if ($bc_$5.pN) {
        try {
          return $bc_$5.pN.app.unRegisterXPCService(xpc_key);
        } catch (e) {
          console.error(e);
        }
      }

      return false;
    },

    /**
    * XPC
    * @param xpc_key  xpcKey
    * @returns {true/false}
    */
    find: function find(xpc_key) {
      if ($bc_$5.pN) {
        try {
          return $bc_$5.pN.app.hasXPCService(xpc_key || 'default');
        } catch (e) {
          console.error(e);
        }
      }

      return false;
    },

    /**
    * XPC
    * @param xpc_key
    */
    resume: function resume(xpc_key) {
      if ($bc_$5.pN) {
        try {
          $bc_$5.pN.app.resumeXPCService(xpc_key);
        } catch (e) {
          console.error(e);
        }
      }
    },

    /**
    * XPC
    * @param xpc_key
    */
    suspend: function suspend(xpc_key) {
      if ($bc_$5.pN) {
        try {
          $bc_$5.pN.app.suspendXPCService(xpc_key);
        } catch (e) {
          console.error(e);
        }
      }
    },

    /**
    * XPC
    * @param xpc_key
    */
    invalidate: function invalidate(xpc_key) {
      if ($bc_$5.pN) {
        try {
          $bc_$5.pN.app.invalidateXPCService(xpc_key);
        } catch (e) {
          console.error(e);
        }
      }
    },

    /**
    * XPC
    * @param jsonObj 
    * @param cb 
    * @returns {*}
    */
    sendMessage: function sendMessage(jsonObj, cb) {
      if ($bc_$5.pN) {
        try {
          var _json = jsonObj || {};
          var params = {
            xpc_key: _json.xpc_key || 'default',
            callback: _json.callback || $bc_$5._get_callback(function (obj) {
              cb && cb(obj);
            }, true),
            messageDic: _json.messageDic
          };

          // / 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          return $bc_$5.pN.app.sendMessageToXPCService(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      }
    }
  };

  /** *
  * XPC Node Helper
  * @type {{exec: Function}}
  */
  $bc_$5.XPCNodeHelper = {
    /**
    * Node XPC Key
    * @returns {string}
    */
    getXPCKey: function getXPCKey() {
      return 'g_romanysoft_node_xpc';
    },

    /**
    * NodeHelper
    * @returns {string}
    */
    getHelperBundleID: function getHelperBundleID() {
      return 'com.romanysoft.app.mac.xpc.NodeHelper';
    },

    /**
    * Node
    * @param jsonObj
    * @param successCB 
    * @param failedCB  
    */
    exec: function exec(jsonObj, successCB, failedCB) {
      var $t = this;

      var xpc_key = $t.getXPCKey();
      var helperID = $t.getHelperBundleID();

      var canExec = false;

      // Sandbox
      alert(',Sandbox');

      // 
      if ($bc_$5.XPC.find(xpc_key) === false) {
        canExec = $bc_$5.XPC.install({
          xpc_key: xpc_key,
          bundleID: helperID
        });
      } else {
        canExec = true;
      }

      // 
      if (canExec) {
        var pluginDir = $bc_$5.App.getAppPluginDir();
        var node_path = pluginDir + '/node';

        var _json = jsonObj || {};

        // / 
        for (var key in jsonObj) {
          if (jsonObj.hasOwnProperty(key)) {
            _json[key] = jsonObj[key];
          }
        }

        // 
        var messageDic = {
          'ms_type': 'CALL_TASK',
          'ms_obj': {
            'taskAppPath': node_path,
            'command': _json.command || ['-v'],
            'currentDirectoryPath': _json.currentDirectoryPath || '',
            'environmentDic': _json.environmentDic || {},
            'mainThread': _json.mainThread || false
          }
        };

        // 
        $bc_$5.XPC.sendMessage({
          'xpc_key': xpc_key,
          'messageDic': messageDic
        }, function (obj) {
          successCB && successCB(obj);
        });
      } else {
        console.error('XPCNodeHelper install failed.');
        failedCB && failedCB();
      }
    }
  };

  $bc_$5.XPCPythonHelper = {
    /**
    * Node XPC Key
    * @returns {string}
    */
    getXPCKey: function getXPCKey() {
      return 'g_romanysoft_python_xpc';
    },

    /**
    * NodeHelper
    * @returns {string}
    */
    getHelperBundleID: function getHelperBundleID() {
      return 'com.romanysoft.app.mac.xpc.PythonHelper';
    },

    /**
    * Python
    * @param jsonObj
    * @param successCB
    * @param failedCB
    */
    common_exec: function common_exec(jsonObj, successCB, failedCB) {
      var $t = this;

      var xpc_key = $t.getXPCKey();
      var helperID = $t.getHelperBundleID();

      var canExec = false;

      // Sandbox
      alert(',Sandbox');

      // 
      if ($bc_$5.XPC.find(xpc_key) === false) {
        canExec = $bc_$5.XPC.install({
          xpc_key: xpc_key,
          bundleID: helperID
        });
      } else {
        canExec = true;
      }

      // 
      if (canExec) {
        var pluginDir = $bc_$5.App.getAppPluginDir();
        var pythonCLI_path = pluginDir + '/pythonCLI';

        var _json = jsonObj || {};

        // 
        var messageDic = {
          'ms_type': 'CALL_TASK',
          'ms_obj': {
            'taskAppPath': pythonCLI_path,
            'command': _json.command || ['-v'],
            'currentDirectoryPath': _json.currentDirectoryPath || '',
            'environmentDic': _json.environmentDic || {},
            'mainThread': _json.mainThread !== false
          }
        };

        // 
        $bc_$5.XPC.sendMessage({
          'xpc_key': xpc_key,
          'messageDic': messageDic
        }, function (obj) {
          successCB && successCB(obj);
        });
      } else {
        console.error('XPCNodeHelper install failed.');
        failedCB && failedCB();
      }
    },

    _formatCommand: function _formatCommand(pythonCommand) {
      if (typeof pythonCommand !== 'string') {
        console.error('command must be string');
        alert('command must be string');
        return null;
      }

      // 
      var workDir = $bc_$5.App.getAppResourceDir() + '/data/python';
      var resourceDir = $bc_$5.App.getAppDataHomeDir();
      var configFile = 'Resources/config.plist';

      // 
      var regCommand = '["-i","id.pythonCLI","-c","%config%","-r","%resourceDir%","-w","%workDir%","-m","%command%"]';
      var formatCommonStr = regCommand.replace(/%config%/g, configFile);
      formatCommonStr = formatCommonStr.replace(/%resourceDir%/g, resourceDir);
      formatCommonStr = formatCommonStr.replace(/%workDir%/g, workDir);
      formatCommonStr = formatCommonStr.replace(/%command%/g, pythonCommand);

      // Command 
      var command = window.eval(formatCommonStr); // command

      return command;
    },

    /**
    * 
    * @param jsonObj
    * @param successCB
    * @param failedCB
    */
    exec: function exec(jsonObj, successCB, failedCB) {
      var $t = this;
      var _json = jsonObj || {};

      var pythonCommand = _json.command || ''; // {string}
      var command = $t._formatCommand(pythonCommand);

      // 
      var newJson = {
        command: command || ['-v'],
        currentDirectoryPath: _json.currentDirectoryPath || '',
        'environmentDic': _json.environmentDic || {},
        'mainThread': _json.mainThread !== false
      };

      $t.common_exec(newJson, successCB, failedCB);
    },

    /**
    * PythonWebServer
    * @param jsonObj
    * @param successCB
    * @param failedCB
    */
    startWebServer: function startWebServer(jsonObj, successCB, failedCB) {
      var $t = this;

      var _json = jsonObj || {};

      // 
      var newJson = {
        'command': ' --port=' + $bc_$5.App.getServerPort(), // {string}
        'currentDirectoryPath': _json.currentDirectoryPath || '',
        'environmentDic': _json.environmentDic || {},
        'mainThread': _json.mainThread !== false
      };

      $t.exec(newJson, successCB, failedCB);
    }

  };

  // -----------------------------------------------
  var xpc = $bc_$5;

  var $bc_$6 = common;
  /**
   * 
   * @type {{minimize: Function, maximize: Function, toggleFullScreen: Function, restore: Function, isMaximized: Function, move: Function, resize: Function, setMinSize: Function, setMaxSize: Function}}
   */
  $bc_$6.Window = {

    // 
    minimize: function minimize() {
      if ($bc_$6.pN) {
        $bc_$6.pN.window.minimize();
      }
    },

    // 
    maximize: function maximize() {
      if ($bc_$6.pN) {
        $bc_$6.pN.window.maximize();
      }
    },

    // 
    toggleFullScreen: function toggleFullScreen() {
      if ($bc_$6.pN) {
        $bc_$6.pN.window.toggleFullscreen();
      }
    },

    // 
    restore: function restore() {
      if ($bc_$6.pN) {
        $bc_$6.pN.window.restore();
      }
    },

    // 
    isMaximized: function isMaximized() {
      if ($bc_$6.pN) {
        return $bc_$6.pN.window.isMaximized();
      }

      return false;
    },

    // 
    getOrigin: function getOrigin() {
      if ($bc_$6.pN) {
        return JSON.parse($bc_$6.pN.window.getOrigin());
      }
      return {
        x: 0,
        y: 0
      };
    },

    // 
    move: function move(jsonObj) {
      if ($bc_$6.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['x'] = jsonObj['x'] || 0.0;
          params['y'] = jsonObj['y'] || 0.0;

          // / 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$6.pN.window.move(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      } else {
        alert('!');
      }
    },

    // 
    resize: function resize(jsonObj) {
      if ($bc_$6.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['width'] = jsonObj['width'] || 600;
          params['height'] = jsonObj['height'] || 400;

          // / 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$6.pN.window.resize(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      } else {
        alert('!');
      }
    },

    // 
    getMinSize: function getMinSize() {
      if ($bc_$6.pN) {
        return JSON.parse($bc_$6.pN.window.getMinSize());
      }
      return {
        width: 600,
        height: 400
      };
    },

    // 
    setMinSize: function setMinSize(jsonObj) {
      if ($bc_$6.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['width'] = jsonObj['width'] || 600;
          params['height'] = jsonObj['height'] || 400;

          // / 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$6.pN.window.setMinsize(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      } else {
        alert('!');
      }
    },

    // 
    getMaxSize: function getMaxSize() {
      if ($bc_$6.pN) {
        return JSON.parse($bc_$6.pN.window.getMaxSize());
      }
      return {
        width: 600,
        height: 400
      };
    },

    // 
    setMaxSize: function setMaxSize(jsonObj) {
      if ($bc_$6.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['width'] = jsonObj['width'] || 600;
          params['height'] = jsonObj['height'] || 400;

          // / 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$6.pN.window.setMaxsize(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      } else {
        alert('!');
      }
    },

    // 
    getSize: function getSize() {
      if ($bc_$6.pN) {
        return JSON.parse($bc_$6.pN.window.getSize());
      }

      return {
        width: 600,
        height: 400
      };
    },

    // 
    setSize: function setSize(jsonObj) {
      if ($bc_$6.pN) {
        try {
          var params = jsonObj || {};
          // 
          params['width'] = jsonObj['width'] || 600;
          params['height'] = jsonObj['height'] || 400;

          // / 
          for (var key in jsonObj) {
            if (jsonObj.hasOwnProperty(key)) {
              params[key] = jsonObj[key];
            }
          }

          $bc_$6.Window.resize(params);
        } catch (e) {
          console.error(e);
        }
      } else {
        alert('!');
      }
    }

  };

  // -----------------------------------------------
  var window$1 = $bc_$6;

  var $bc_$7 = common;

  /**
   * 
   * @type {{setMenuProperty: Function, maxRecentDocumentCount: Function, addRecentDocument: Function, clearAllRecentDocuments: Function}}
   */
  $bc_$7.SystemMenus = {
    setMenuProperty: function setMenuProperty(paramOptions, cb, actionCB) {
      try {
        var params = {};
        // 
        params['callback'] = paramOptions['callback'] || $bc_$7._get_callback(function (obj) {
          console.log('call callback.cb ...');
          cb && cb(obj);
        }, true);
        params['menuTag'] = paramOptions['menuTag'] || 999;
        params['hideMenu'] = paramOptions['hideMenu'] || false;
        params['isSeparatorItem'] = paramOptions['isSeparatorItem'] || false; // Item
        params['title'] = paramOptions['title'] || '##**'; // "MenuTitle";
        params['action'] = paramOptions['action'] || $bc_$7._get_callback(function (obj) {
          console.log('call actionCB ...');
          actionCB && actionCB(obj);
        }, true);

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        if ($bc_$7.pN) {
          $bc_$7.pN.window.setMenuProperty(JSON.stringify(params));
        } else {
          alert('!');
        }
      } catch (e) {
        console.error(e);
      }
    },
    maxRecentDocumentCount: function maxRecentDocumentCount() {
      if ($bc_$7.pN) {
        return $bc_$7.pN.window.maxRecentDocumentCount();
      }

      return 0;
    },
    addRecentDocument: function addRecentDocument(paramOptions) {
      if ($bc_$7.pN) {
        try {
          var params = paramOptions || {};
          // 
          params['url'] = paramOptions['url'] || '';
          params['mustWritable'] = paramOptions['mustWritable'] || false;

          // / 
          for (var key in paramOptions) {
            if (paramOptions.hasOwnProperty(key)) {
              params[key] = paramOptions[key];
            }
          }

          $bc_$7.pN.window.addRecentDocument(JSON.stringify(params));
        } catch (e) {
          console.error(e);
        }
      } else {
        alert('');
      }
    },
    clearAllRecentDocuments: function clearAllRecentDocuments() {
      if ($bc_$7.pN) {
        $bc_$7.pN.window.clearAllRecentDocuments();
      }
    }

  };

  // -----------------------------------------------
  var menu = $bc_$7;

  var $bc_$8 = common;

  /**
   * 
   * @type {{copy: Function, paste: Function}}
   */
  $bc_$8.Clipboard = {
    copy: function copy(stringText) {
      if ($bc_$8.pN) {
        $bc_$8.pN.clipboard.copy(stringText);
      }
    },
    paste: function paste() {
      if ($bc_$8.pN) {
        return $bc_$8.pN.clipboard.paste();
      }
    }
  };

  //
  // -----------------------------------------------
  var clipboard = $bc_$8;

  var $bc_$9 = common;

  /**
   * Dock 
   * @type {{setBadge: Function, getBadge: Function}}
   */
  $bc_$9.Dock = {
    setBadge: function setBadge(text) {
      if ($bc_$9.pN) {
        $bc_$9.pN.dock.setBadge(text);
      }
    },
    getBadge: function getBadge() {
      if ($bc_$9.pN) {
        return $bc_$9.pN.dock.badge;
      }

      return 'dock';
    }
  };

  //
  // -----------------------------------------------
  var dock = $bc_$9;

  var $bc_$10 = common;

  /**
   * 
   * @type {{createBinaryFile: Function, createTextFile: Function, getUTF8TextContentFromFile: Function, base64ToFile: Function, base64ToImageFile: Function, imageFileConvertToOthers: Function}}
   */
  $bc_$10.Binary = {
    createBinaryFile: function createBinaryFile(paramOptions, cb) {
      try {
        var params = {};
        // 
        params['callback'] = paramOptions['callback'] || $bc_$10._get_callback(function (obj) {
          cb && cb(obj);
        }, true);
        params['filePath'] = paramOptions['filePath'] || '';
        params['data'] = paramOptions['data'] || '';
        params['offset'] = paramOptions['offset'] || 0;
        params['dataAppend'] = paramOptions['dataAppend'] || false;

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        if ($bc_$10.pN) {
          $bc_$10.pN.binaryFileWriter.writeBinaryArray(JSON.stringify(params));
        } else {
          alert('');
        }
      } catch (e) {
        console.error(e);
      }
    },

    createTextFile: function createTextFile(paramOptions, cb) {
      try {
        var params = {};
        // 
        params['callback'] = paramOptions['callback'] || $bc_$10._get_callback(function (obj) {
          cb && cb(obj);
        }, true);
        params['filePath'] = paramOptions['filePath'] || '';
        params['text'] = paramOptions['text'] || '';
        params['offset'] = paramOptions['offset'] || 0;
        params['dataAppend'] = paramOptions['dataAppend'] || false;

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        if ($bc_$10.pN) {
          $bc_$10.pN.binaryFileWriter.writeTextToFile(JSON.stringify(params));
        } else {
          alert('');
        }
      } catch (e) {
        console.error(e);
      }
    },

    getUTF8TextContentFromFile: function getUTF8TextContentFromFile(paramOptions, cb) {
      try {
        var params = {};
        // 
        params['callback'] = paramOptions['callback'] || $bc_$10._get_callback(function (obj) {
          /**
           obj.success = true || false
           obj.content =  //
           obj.error =    //
           **/
          cb && cb(obj);
        }, true);
        params['filePath'] = paramOptions['filePath'] || '';
        params['encode'] = paramOptions['encode'] || 'utf8';
        params['async'] = paramOptions['async'] !== false; // 

        /**
         encode: 
         ASCII,NEXTSTEP,JapaneseEUC,UTF8,ISOLatin1,Symbol,NonLossyASCII,ShiftJIS,ISOLatin2,Unicode
         WindowsCP1251,WindowsCP1252,WindowsCP1253,WindowsCP1254,WindowsCP1250,ISO2022JP,MacOSRoman
         UTF16,UTF16BigEndian,UTF16LittleEndian
         **/

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        if ($bc_$10.pN) {
          return $bc_$10.pN.binaryFileWriter.getTextFromFile(JSON.stringify(params)); // (async == false)content
        } else {
          alert('UTF8');
          cb && cb({
            success: true,
            text: ''
          });
        }
      } catch (e) {
        console.error(e);
      }
    },

    base64ToFile: function base64ToFile(paramOptions, cb) {
      try {
        var params = {};
        // 
        params['callback'] = paramOptions['callback'] || $bc_$10._get_callback(function (obj) {
          cb && cb(obj);
        }, true);
        params['filePath'] = paramOptions['filePath'] || '';
        params['base64String'] = paramOptions['base64String'] || '';
        params['dataAppend'] = paramOptions['dataAppend'] || false;

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        if ($bc_$10.pN) {
          $bc_$10.pN.binaryFileWriter.base64ToFile(JSON.stringify(params));
        } else {
          alert('base64');
        }
      } catch (e) {
        console.error(e);
      }
    },

    base64ToImageFile: function base64ToImageFile(paramOptions, cb) {
      try {
        var params = {};
        // 
        params['callback'] = paramOptions['callback'] || $bc_$10._get_callback(function (obj) {
          cb && cb(obj);
        }, true);
        params['filePath'] = paramOptions['filePath'] || '';
        params['base64String'] = paramOptions['base64String'] || '';
        params['imageType'] = paramOptions['imageType'] || 'jpeg'; // png,bmp

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        if ($bc_$10.pN) {
          $bc_$10.pN.binaryFileWriter.base64ToImageFile(JSON.stringify(params));
        } else {
          alert('base64');
        }
      } catch (e) {
        console.error(e);
      }
    },

    imageFileConvertToOthers: function imageFileConvertToOthers(paramOptions, cb) {
      try {
        var params = {};
        // 
        params['callback'] = paramOptions['callback'] || $bc_$10._get_callback(function (obj) {
          cb && cb(obj);
        }, true);
        params['filePath'] = paramOptions['filePath'] || ''; // 
        params['orgFilePath'] = paramOptions['orgFilePath'] || ''; // 
        params['imageType'] = paramOptions['imageType'] || 'jpeg'; // png,bmp

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        if ($bc_$10.pN) {
          $bc_$10.pN.binaryFileWriter.imageFileConvertToOthers(JSON.stringify(params));
        } else {
          alert('');
        }
      } catch (e) {
        console.error(e);
      }
    },

    Sound: {
      playResourceSoundFile: function playResourceSoundFile(fileUrl) {
        if ($bc_$10.pN) {
          $bc_$10.pN.sound.play(fileUrl);
        }
      }
    },

    Video: {}

  };

  //
  // -----------------------------------------------
  var binary = $bc_$10;

  var _$5 = underscore._;

  var $bc_$11 = common;
  // 
  $bc_$11.enablePluginCore = function (pluginList, cbFuncName) {
    if ($bc_$11.pN) {
      try {
        var org_pluginArray = pluginList || []; // 
        var pluginArray = [];

        // 'call' 
        for (var i = 0; i < org_pluginArray.length; ++i) {
          var plugin = org_pluginArray[i];
          if (plugin['callMethod'] === 'call') {
            pluginArray.push(plugin);
          }
        }

        var extendObj = _$5.clone($bc_$11.pCorePlugin);
        extendObj['callMethod'] = 'initCore';
        if (_$5.isString(cbFuncName)) {
          extendObj['passBack'] = cbFuncName; // 
        }
        extendObj['arguments'] = [true, pluginArray];

        $bc_$11.pN.window.execTask(JSON.stringify(extendObj));
      } catch (e) {
        console.error(e);
      }
    }
  };

  // -----------------------------------------------
  var plugin = $bc_$11;

  var _$6 = underscore._;

  var $bc_$12 = common;

  // 
  $bc_$12.cb_dragdrop = null; // 
  /**
   *
   * @param params 
   */
  $bc_$12.enableDragDropFeature = function (jsonObj, cb) {
    var t$ = this;
    if (t$.pN) {
      try {
        var params = jsonObj || {};
        params['callback'] = jsonObj['callback'] || t$._get_callback(function (obj) {
          if (_$6.isFunction(t$.cb_dragdrop)) {
            t$.cb_dragdrop && t$.cb_dragdrop(obj);
          } else {
            cb && cb(obj);
          }
        }, true);
        params['enableDir'] = jsonObj['enableDir'] || false;
        params['enableFile'] = jsonObj['enableFile'] !== false;
        params['fileTypes'] = jsonObj['fileTypes'] || ['*']; // ["*","mp3","md", "xls"] 

        // / 
        for (var key in jsonObj) {
          if (jsonObj.hasOwnProperty(key)) {
            params[key] = jsonObj[key];
          }
        }

        if (t$.pIsUseElectron) {
          var $ = common.getJQuery$();
          $(document).ready(function () {
            // document.ondragover = document.ondrop = function(e) {
            //   e.preventDefault();
            //   return false;
            // };

            var holder = document; // document.getElementsByTagName('body');
            holder.ondragstart = function (e) {
              console.log('----- holder.ondragstart -----');
              e.preventDefault();
            };

            holder.ondragover = function () {
              console.log('----- holder.ondragover -----');
              return false;
            };
            holder.ondragleave = holder.ondragend = function () {
              console.log('----- holder.ondragleave or holder.ondragend -----');
              // this.className = '';
              return false;
            };
            holder.ondrop = function (e) {
              console.log('----- holder.ondrop -----');
              // this.className = '';
              e.preventDefault();

              // dataTransfer.files 
              var pathList = [];
              _$6.each(e.dataTransfer.files, function (fileObj, index, list) {
                pathList.push(fileObj.path);
              });

              try {
                t$.pN.window.proxyProcessDragDropWithPaths(pathList);
              } catch (e) {
                console.error(e);
              }
            };
          });
        }

        t$.pN.window.setDragDropConfig(JSON.stringify(params));
      } catch (e) {
        console.error(e);
      }
    } else {
      console.log('[Notice] Not Native enableDragDropFeature');
    }
  };

  //
  // -----------------------------------------------
  var dragdrop = $bc_$12;

  var _$7 = underscore._;
  var $bc_$13 = common;

  var TypeTriggerMsg = {
    UNKnown: 'NativeTask_UNKnown',
    onCreate: 'NativeTask_onCreate',
    // process_init
    //
    onNativeEngineInitSuccess: '_native_engine_init_success',
    onNativeEngineInitFailed: '_native_engine_init_failed',
    // process_dylibCLI
    //
    onDylibCLIStart: '_native_clicall_start',
    onDylibCLIFeedback: '_native_clicall_feedback',
    onDylibCLIEnd: '_native_clicall_end',
    // process_execCommand
    //
    onExecCommandAdded: '_native_execCommand_added',
    onExecCommandStarted: '_native_execCommand_start',
    onExecCommandFeedback: '_native_execCommand_feedback',
    onExecCommandSuccess: '_native_execCommand_success',
    onExecCommandCanceled: '_native_execCommand_canceled',
    onExecCommandError: '_native_execCommand_error',
    // process_task
    //
    onTaskAdded: '_native_task_added',
    onTaskStarted: '_native_task_started',
    onTaskFinished: '_native_task_finished',
    onTaskError: '_native_task_error',
    onTaskCanceled: '_native_task_canceled'
  };

  // 
  var TypeNativeMessageType = {
    // process_init
    InitCoreSuccess: 'type_initcoresuccess',
    InitCoreFailed: 'type_initcorefailed',

    // process_dylibCLI
    CliCallStart: 'type_clicall_start',
    CliCallReportProgress: 'type_clicall_reportprogress',
    CliCallEnd: 'type_clicall_end',

    // process_execCommand
    AddExecCommandQueueSuccess: 'type_addexeccommandqueue_success',
    ExecCommandStart: 'type_execcommandstart',
    ExecCommandReportProgress: 'type_reportexeccommandprogress',
    ExecCommandSuccess: 'type_execcommandsuccess',
    CancelExecCommand: 'type_canceledexeccommand',
    ExecCommandFailed: 'type_execcommanderror',

    // process_task
    AddCallTaskQueueSuccess: 'type_addcalltaskqueue_success',
    CallTaskStart: 'type_calltask_start',
    CallTaskFailed: 'type_calltask_error',
    CallTaskSuccess: 'type_calltask_success',
    CancelCallTask: 'type_type_calltask_cancel'

  };

  /**
   * Task
   */
  var TaskMethodWay = {
    InitCore: 'initCore',
    Task: 'task',
    SendEvent: 'sendEvent'
  };

  /**
   * command
   * "copyPlugin.tool.command" 
   var copyPlugin = $.objClone(t$.plguinData);
   copyPlugin.tool.command = ["-g",
   {
     "$api":"GetXLSFileInfo",
     "filePath":_path
   }];
  
    $bc_.createTask(copyPlugin.callMethod, Date.now(), [copyPlugin.tool], $bc_._get_callback(function(obj)
    * @param commandList
    */
  $bc_$13.formatCommand = function (commandList) {
    // ''
    var formatArgs = [];

    _$7.each(commandList || [], function (ele, index, list) {
      var formatEle = '';
      if (_$7.isBoolean(ele)) {
        formatEle = "'" + ele + "'";
      }
      if (_$7.isNumber(ele)) {
        formatEle = ele;
      }
      if (_$7.isString(ele)) {
        formatEle = "'" + ele + "'";
      }
      if (_$7.isFunction(ele)) {
        formatEle = null;
      }
      if (_$7.isArray(ele)) {
        formatEle = "'" + JSON.stringify(ele) + "'";
      }
      if (_$7.isDate(ele)) {
        formatEle = "'" + JSON.stringify(ele) + "'";
      }
      if (_$7.isRegExp(ele)) {
        formatEle = "'" + ele.toString() + "'";
      }
      if (_$7.isObject(ele)) {
        formatEle = "'" + JSON.stringify(ele) + "'";
      }
      if (formatEle !== null) {
        formatArgs.push(formatEle);
      }
    });

    return formatArgs;
  };
  // 
  /**
   *
   * @param callMethod  tasksendEvent
   * @param taskId
   * @param args
   * @param cbFuncName callback 
   */
  $bc_$13.createTask = function (callMethod, taskId, args, cbFuncName) {
    try {
      var extendObj = _$7.clone($bc_$13.pCorePlugin);
      extendObj['passBack'] = cbFuncName || extendObj['passBack'];
      extendObj['callMethod'] = callMethod;
      extendObj['arguments'] = [taskId, args];

      var argumentJSONString = JSON.stringify(extendObj);
      if ($bc_$13.pN) {
        $bc_$13.pN.window.execTask(argumentJSONString);
      } else {
        cbFuncName && window.eval(cbFuncName + '()');
      }
    } catch (e) {
      console.error(e);
    }
  };

  /**
   * 
   * @param method $bc_.createTask. //task, sendEvent, initCore 
   * @param callbackName 
   * @param args 
   */
  $bc_$13.runTaskSample = function (method, callbackName, args) {
    if (method === void 0) method = TaskMethodWay.Task;
    if (args === void 0) args = [_$7.now(), // TaskID
    [{ // TaskCommand
      appPath: '',
      command: [],
      mainThread: false
    }]];

    try {
      if ($bc_$13.pN) {
        $bc_$13.pN.window.execTask(JSON.stringify({
          useThread: true,
          passBack: callbackName,
          packageMode: 'bundle',
          taskToolPath: '/Plugins/extendLoader.bundle',
          bundleClassName: 'LibCommonInterface',
          callMethod: method,
          arguments: args
        }));
      } else {
        callbackName && window.eval(callbackName + '()');
      }
    } catch (error) {
      console.error(error);
    }
  };

  // (2016.1.20)
  $bc_$13.autoStartTask = function (obj, cbFuncName) {
    try {
      if ($bc_$13.pN) {
        var infoType = obj.type;
        var queueID = null;
        if (infoType === 'type_addexeccommandqueue_success') {
          queueID = obj.queueInfo.id;
          $bc_$13.sendQueueEvent(queueID, 'execcommand', 'start', cbFuncName);
        }
        if (infoType === 'type_addcalltaskqueue_success') {
          queueID = obj.queueInfo.id;
          $bc_$13.sendQueueEvent(queueID, 'calltask', 'start', cbFuncName);
        }
      } else {
        cbFuncName && window.eval(cbFuncName + '()');
      }
    } catch (e) {}
  };

  // 
  $bc_$13.sendQueueEvent = function (queueID, queueType, event, cbFuncName) {
    try {
      var extendObj = _$7.clone($bc_$13.pCorePlugin);
      extendObj['passBack'] = cbFuncName || extendObj['passBack'];
      extendObj['callMethod'] = 'sendEvent';
      extendObj['arguments'] = [event, queueType, queueID];

      if ($bc_$13.pN) {
        $bc_$13.pN.window.execTask(JSON.stringify(extendObj));
      } else {
        cbFuncName && window.eval(cbFuncName + '()');
      }
    } catch (e) {
      console.error(e);
    }
  };

  $bc_$13.Task = {
    TypeDefined: {
      TypeTriggerMsg: TypeTriggerMsg,
      TypeNativeMessageType: TypeNativeMessageType,
      TaskMethodWay: TaskMethodWay
    },
    Methods: {
      formatCommand: $bc_$13.formatCommand,
      createTask: $bc_$13.createTask,
      runTaskSample: $bc_$13.runTaskSample,
      autoStartTask: $bc_$13.autoStartTask,
      sendQueueEvent: $bc_$13.sendQueueEvent
    }
  };

  // -----------------------------------------------
  var task = $bc_$13;

  var _$8 = underscore._;

  var $bc_$14 = common;

  // 
  /**
   BS.$bc_.cb_importFiles({
   "success":true,
   "parentDir":"/Volumes/DiskShareUser/Users/ian/TestResource/xls",
   "filesCount":1,
   "filesArray":[
      {"isExecutable":true,
      "isDeletable":false,
      "fileNameWithoutExtension":"Book1",
      "fileName":"Book1.xls",
      "fileSize":7680,
      "fileSizeStr":"7.7KB",
      "fileUrl":"file:///Volumes/DiskShareUser/Users/ian/TestResource/xls/Book1.xls",
      "isReadable":true,
      "isWritable":true,
      "extension":"xls",
      "filePath":"/Volumes/DiskShareUser/Users/ian/TestResource/xls/Book1.xls"
      }
    ]
  });
    **/
  $bc_$14.cb_importFiles = null; // 
  /**
   * 
   * @param params json
   * @param noNcb Native
   * @param cb    Native
   */
  $bc_$14.importFiles = function (paramOptions, noNcb, cb) {
    var _this = this;
    try {
      var params = {};
      // 
      params['callback'] = paramOptions['callback'] || _this._get_callback(function (obj) {
        if (_this.cb_importFiles) {
          _this.cb_importFiles && _this.cb_importFiles(obj);
        } else {
          cb && cb(obj);
        }
      }, true);
      params['title'] = paramOptions['title'] || 'Select a file';
      params['prompt'] = paramOptions['prompt'] || 'Open';

      params['allowOtherFileTypes'] = paramOptions['allowOtherFileTypes'] || false;
      params['allowMulSelection'] = paramOptions['allowMulSelection'] || false;
      params['canCreateDir'] = paramOptions['canCreateDir'] || false;
      params['canChooseFiles'] = true;
      params['canChooseDir'] = false;
      params['canAddToRecent'] = true; // 
      params['directory'] = paramOptions['directory'] || ''; // 
      params['types'] = paramOptions['types'] || []; // eg. ['png','svg']  ['*']

      // 
      params['enableFileFormatCombox'] = paramOptions['enableFileFormatCombox'] || false;
      params['typesDescript'] = paramOptions['typesDescript'] || [];
      params['lable'] = paramOptions['lable'] || 'File Format:';
      params['label'] = paramOptions['label'] || 'File Format:';
      // [end]

      // / 
      for (var key in paramOptions) {
        if (paramOptions.hasOwnProperty(key)) {
          params[key] = paramOptions[key];
        }
      }

      if ($bc_$14.pN) {
        $bc_$14.pN.window.openFile(JSON.stringify(params));
      } else {
        alert('!');
        noNcb && noNcb();
      }
    } catch (e) {
      console.error(e);
    }
  };

  // 
  /**
   * 
   * {
          callback: "BS.$bc_.cb_selectOutDir",
          allowOtherFileTypes: false,
          canCreateDir: true,
          canChooseDir: true,
          canChooseFiles: false, // 
          title: "Select Directory",
          prompt: "Select",
          types: []              // 
      }
    * @type {null}
    */
  $bc_$14.cb_selectOutDir = null; // 
  /**
   * 
   * @param params json
   * @param noNcb Native
   * @param cb Nativecb
   */
  $bc_$14.selectDir = $bc_$14.selectOutDir = function (paramOptions, noNcb, cb) {
    try {
      var params = {};

      // 
      params['callback'] = paramOptions['callback'] || $bc_$14._get_callback(function (obj) {
        if (_$8.isFunction($bc_$14.cb_selectOutDir)) {
          $bc_$14.cb_selectOutDir && $bc_$14.cb_selectOutDir(obj);
        } else {
          cb && cb(obj);
        }
      }, true);
      params['title'] = paramOptions['title'] || 'Select Directory';
      params['prompt'] = paramOptions['prompt'] || 'Select';

      params['allowOtherFileTypes'] = paramOptions['allowOtherFileTypes'] || false;
      params['allowMulSelection'] = paramOptions['allowMulSelection'] || false;
      params['canCreateDir'] = paramOptions['canCreateDir'] !== false;
      params['canChooseDir'] = true;
      params['canChooseFiles'] = false; // 
      params['canAddToRecent'] = true; // 
      params['directory'] = paramOptions['directory'] || ''; // 
      params['types'] = [];

      // / 
      for (var key in paramOptions) {
        if (paramOptions.hasOwnProperty(key)) {
          params[key] = paramOptions[key];
        }
      }

      if ($bc_$14.pN) {
        $bc_$14.pN.window.openFile(JSON.stringify(params));
      } else {
        alert('!');
        noNcb && noNcb();
      }
    } catch (e) {
      console.error(e);
    }
  };

  // 
  /*
    BS.$bc_.cb_selectOutFile({
    "success":true,
    "fileName":"untitled.csv",
    "fileUrl":"file:///Volumes/DiskShareUser/Users/ian/TestResource/xls/untitled.csv",
    "fileNameWithoutExtension":"untitled",
    "extension":"csv",
    "filePath":"/Volumes/DiskShareUser/Users/ian/TestResource/xls/untitled.csv"
    });
    */
  $bc_$14.cb_selectOutFile = null; // 
  /**
   * 
   * @param params json
   * @param noNcb Native
   * @param cb Nativecb
   */
  $bc_$14.selectOutFile = function (paramOptions, noNcb, cb) {
    if ($bc_$14.pN) {
      try {
        var params = {};

        // 
        params['callback'] = paramOptions['callback'] || $bc_$14._get_callback(function (obj) {
          if (_$8.isFunction($bc_$14.cb_selectOutFile)) {
            $bc_$14.cb_selectOutFile && $bc_$14.cb_selectOutFile(obj);
          } else {
            cb && cb(obj);
          }
        }, true);
        params['title'] = paramOptions['title'] || 'Save as';
        params['prompt'] = paramOptions['prompt'] || 'Save';

        params['allowOtherFileTypes'] = false;
        params['canCreateDir'] = paramOptions['canCreateDir'] !== false;
        params['canAddToRecent'] = true; // 
        params['fileName'] = paramOptions['fileName'] || 'untitled';
        params['directory'] = paramOptions['directory'] || ''; // 
        params['types'] = paramOptions['types'] || ['*']; // 

        // 
        params['enableFileFormatCombox'] = paramOptions['enableFileFormatCombox'] || false;
        params['typesDescript'] = paramOptions['typesDescript'] || [];
        params['lable'] = paramOptions['lable'] || 'File Format:';
        params['label'] = paramOptions['label'] || 'File Format:';
        // [end]

        // / 
        for (var key in paramOptions) {
          if (paramOptions.hasOwnProperty(key)) {
            params[key] = paramOptions[key];
          }
        }

        $bc_$14.pN.window.saveFile(JSON.stringify(params));
      } catch (e) {
        console.error(e);
      }
    } else {
      alert('!');
      noNcb && noNcb();
    }
  };

  // -----------------------------------------------
  var filedialog = $bc_$14;

  var _$11 = underscore._;

  var __$p$$2 = {
    init: function init() {
      this.__mc = new Observable();
    },
    debugLog: false,
    log: function log(title, message, end) {
      if (end === void 0) end = '';

      if (this.debugLog) {
        console.log(title, message, end);
      }
    },

    getEvents: function getEvents() {
      return this.__mc.getMetaDataEvents();
    },
    bind: function bind(eventName, handlers, one) {
      if (one === void 0) one = false;

      this.__mc.bind(eventName, handlers, one);
    },
    one: function one(eventNames, handlers) {
      this.__mc.one(eventNames, handlers);
    },
    first: function first(eventName, handlers) {
      this.__mc.first(eventName, handlers);
    },
    trigger: function trigger(eventName, e) {
      // e
      if (_$11.isString(e)) {
        try {
          e = JSON.parse(e);
        } catch (err) {
          this.log('found err:', err);
          e = {
            data: e
          };
        }
      }
      this.__mc.trigger(eventName, e);
    },
    unbind: function unbind(eventName, handler) {
      this.__mc.unbind(eventName, handler);
    }
  };

  var ProxyMessageCenter = SelfClass.extend(__$p$$2);

  var _$12 = underscore._;

  /**
   * bsutil
   */
  var Tool = {
    /**
     * Get the first item that pass the test
     * by second argument function
     *
     * @param {Array} list
     * @param {Function} f
     * @return {*}
     */
    find: function find(list, f) {
      return list.filter(f)[0];
    },
    /**
     * Deep copy the given object considering circular structure.
     * This function caches all nested objects and its copies.
     * If it detects circular structure, use cached copy to avoid infinite loop.
     *
     * @param {*} obj
     * @param {Array<Object>} cache
     * @return {*}
     */
    deepCopy: function deepCopy(obj, cache) {
      if (cache === void 0) cache = [];

      var t$ = this;
      // just return if obj is immutable value
      if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
        return obj;
      }

      // if obj is hit, it is in circular structure
      var hit = t$.find(cache, function (c) {
        return c.original === obj;
      });
      if (hit) {
        return hit.copy;
      }

      var copy = Array.isArray(obj) ? [] : {};
      // put the copy into cache at first
      // because we want to refer it in recursive deepCopy
      cache.push({
        original: obj,
        copy: copy
      });

      Object.keys(obj).forEach(function (key) {
        copy[key] = t$.deepCopy(obj[key], cache);
      });

      return copy;
    },
    forEachValue: function forEachValue(obj, fn) {
      Object.keys(obj).forEach(function (key) {
        return fn(obj[key], key);
      });
    },
    assert: function assert(condition, msg) {
      if (!condition) {
        throw new Error("[sdk] " + msg);
      }
    },
    getType: function getType(o) {
      return Object.prototype.toString.call(o);
    },
    isUndefinedOrNull: function isUndefinedOrNull(o) {
      return _$12.isUndefined(o) || _$12.isNull(o);
    },
    isUndefinedOrNullOrFalse: function isUndefinedOrNullOrFalse(o) {
      return this.isUndefinedOrNull(o) || o === false;
    },
    isObject: _$12.isObject,
    isError: _$12.isError,
    isNaN: _$12.isNaN,
    isFinite: _$12.isFinite,
    isArguments: _$12.isArguments,
    isElement: _$12.isElement,
    isEmpty: _$12.isEmpty,
    isMatch: _$12.isMatch,
    isEqual: _$12.isEqual,
    isPromise: function isPromise(val) {
      return val && typeof val.then === 'function';
    },
    isArray: _$12.isArray,
    isBoolean: _$12.isBoolean,
    isString: _$12.isString,
    isNull: _$12.isNull,
    isUndefined: _$12.isUndefined,
    isNumber: _$12.isNumber,
    isDate: _$12.isDate,
    isRegExp: _$12.isRegExp,
    isFunction: _$12.isFunction,
    isBlob: function isBlob(o) {
      return Object.prototype.toString.call(o) === '[object Blob]';
    },
    /**
     * Blob data convert to String
     * @param o Blob obj
     * @param cb callback function
     */
    blobData2String: function blobData2String(o, cb) {
      try {
        var reader = new FileReader();
        reader.onload = function (event) {
          cb && cb(reader.result);
        };
        reader.readAsText(o);
      } catch (error) {
        throw error;
      }
    },
    /**
     * Blob data convert to ArrayBuffer
     * @param o Blob obj
     * @param cb callback function
     */
    blobData2ArrayBuffer: function blobData2ArrayBuffer(o, cb) {
      try {
        var reader = new FileReader();
        reader.onload = function (event) {
          cb && cb(reader.result);
        };
        reader.readAsArrayBuffer(o);
      } catch (error) {
        throw error;
      }
    },
    /**
     * param wrapper to Array
     */
    param2Array: function param2Array(param, allowTypes) {
      if (allowTypes === void 0) allowTypes = [];

      var t$ = this;
      if (this.isUndefinedOrNull(param)) {
        return [];
      }
      if (allowTypes.findIndex(function (value, index, err) {
        return value === t$.getType(param);
      }) > -1) {
        return [param];
      }
      if (t$.isArray(param)) {
        return param;
      }
      return [];
    },
    /**
     * convert arguments to a Array
     */
    arguments2Array: function arguments2Array() {
      return [].slice.call(arguments, 0);
    },
    /**
     * Format error string
     * @param err  error object
     * @return String
     */
    getErrorMessage: function getErrorMessage(err) {
      var msg = '';
      try {
        if (this.isString(err)) {
          msg = err;
        } else if (this.isError(err)) {
          msg = err.message;
        } else if (this.isObject(err)) {
          var errMsg = [];
          for (var p in err) {
            if (err.hasOwnProperty(p)) {
              errMsg.push(p + '=' + err[p]);
            }
          }
          if (errMsg.length === 0) {
            msg = err;
          } else {
            msg = errMsg.join('\n');
          }
        } else {
          msg += '[RTY_CANT_TYPE] = ' + this.getType(err);
          msg += JSON.stringify(err);
        }
      } catch (error) {
        throw error;
      }

      return msg;
    },
    queue: function queue(_done) {
      var _next = [];
      var callback = function callback(err) {
        if (!err) {
          var next = _next.shift();
          if (next) {
            var args = arguments;
            args.length ? args[0] = callback : args = [callback];
            return next.apply(null, args);
          }
          return _done.apply(null, arguments);
        }
      };

      var r = {
        next: function next(fn) {
          _next.push(fn);
          return r;
        },
        done: function done(fn) {
          _done = fn;
          r.start();
        },
        start: function start() {
          callback(null, callback);
        }
      };

      return r;
    },
    /**
     * Check fileName's type in the fileTypes
     * @param fileName String
     * @param fileTypes Array []
     * @return Boolean {true, false}
     */
    checkFileType: function checkFileType(fileName, fileTypes) {
      var _fileNameStr = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length).toLowerCase();
      if (fileTypes.indexOf(_fileNameStr) > -1) {
        return true;
      }
      return false;
    },
    obj2string: function obj2string(o) {
      var r = [];
      var t$ = this;
      if (typeof o === 'string') {
        return '\'' + o.replace(/([\'\'\\])/g, '\\$1').replace(/(\n)/g, '\\n').replace(/(\r)/g, '\\r').replace(/(\t)/g, '\\t') + '\'';
      }
      if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && o != null) {
        if (!o.sort) {
          for (var i in o) {
            r.push(i + ':' + t$.obj2string(o[i]));
          }
          if (!!document.all && !/^\n?function\s*toString\(\)\s*\{\n?\s*\[native code\]\n?\s*\}\n?\s*$/.test(o.toString)) {
            r.push('toString:' + o.toString.toString());
          }
          r = '{' + r.join() + '}';
        } else {
          for (var i$1 = 0; i$1 < o.length; i$1++) {
            r.push(t$.obj2string(o[i$1]));
          }
          r = '[' + r.join() + ']';
        }
        return r;
      }

      if (o != null) {
        return o.toString();
      }

      return '';
    },
    //  {index}
    stringFormat: function stringFormat() {
      var arguments$1 = arguments;

      if (arguments.length === 0) {
        return null;
      }
      var str = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        var re = new RegExp('\\{' + (i - 1) + '\\}', 'gm');
        str = str.replace(re, arguments$1[i]);
      }
      return str;
    },
    objClone: function objClone(Obj) {
      var this$1 = this;

      var buf;
      if (Obj instanceof Array) {
        buf = [];
        var i = Obj.length;
        while (i--) {
          buf[i] = this$1.objClone(Obj[i]);
        }
        return buf;
      } else if (Obj instanceof Object) {
        buf = {};
        for (var k in Obj) {
          if (Obj.hasOwnProperty(k)) {
            buf[k] = this$1.objClone(Obj[k]);
          }
        }
        return buf;
      } else {
        return Obj;
      }
    },
    // 
    getFormatDateStr: function getFormatDateStr(dateObj, fmt) {
      // Date Date String
      // (M)(d)(h)(m)(s)(q)  1-2 
      // (y) 1-4 (S) 1 ( 1-3 )
      // 
      // (new Date()).Format('yyyy-MM-dd hh:mm:ss.S') ==> 2006-07-02 08:09:04.423
      // (new Date()).Format('yyyy-M-d h:m:s.S')      ==> 2006-7-2 8:9:4.18
      var that = dateObj;
      var o = {
        'M+': that.getMonth() + 1, // 
        'd+': that.getDate(), // 
        'h+': that.getHours(), // 
        'm+': that.getMinutes(), // 
        's+': that.getSeconds(), // 
        'q+': Math.floor((that.getMonth() + 3) / 3), // 
        'S': that.getMilliseconds() // 
      };

      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (that.getFullYear() + '').substr(4 - RegExp.$1.length));
      }

      for (var k in o) {
        if (new RegExp('(' + k + ')').test(fmt)) {
          fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length));
        }
      }

      return fmt;
    },

    /**
     * 
     * @param version1 {String} || {Number} 1
     * @param version2 {String} || {Number} 2
     * @return {Number} 1, 0 -1 
     */
    compareVersion: function compareVersion(version1, version2) {
      try {
        if (_$12.isNumber(version1) && _$12.isNumber(version2)) {
          if (version1 > version2) {
            return 1;
          }
          if (version1 === version2) {
            return 0;
          }
          if (version1 < version2) {
            return -1;
          }
        } else if (_$12.isNumber(version1) || _$12.isNumber(version2)) {
          version1 += '';
          version2 += '';
        }

        var version1Array = version1.split('.');
        var version2Array = version2.split('.');

        var ver1IntList = [];
        var ver2IntList = [];

        version1Array.forEach(function (value, index, array) {
          ver1IntList.push(parseInt(value));
        });

        version2Array.forEach(function (value, index, array) {
          ver2IntList.push(parseInt(value));
        });

        // format
        if (ver1IntList.length < ver2IntList.length) {
          var i = 0;
          for (; i < ver2IntList.length - ver1IntList.length; ++i) {
            ver1IntList.push(0);
          }
        }

        if (ver1IntList.length > ver2IntList.length) {
          var i$1 = 0;
          for (; i$1 < ver1IntList.length - ver2IntList.length; ++i$1) {
            ver2IntList.push(0);
          }
        }

        var i$2 = 0;
        for (; i$2 < ver1IntList.length; ++i$2) {
          var cVer1 = ver1IntList[i$2];
          var cVer2 = ver2IntList[i$2];

          if (cVer1 > cVer2) {
            return 1;
          }
          if (cVer1 < cVer2) {
            return -1;
          }
        }

        return 0;
      } catch (e) {
        return -1;
      }
    },
    // 
    testObjectType: function testObjectType(obj, type) {
      var actualType = this.getType(obj);
      if (actualType !== type) {
        var errMsg = 'TestType:[' + type + '], actual:[' + actualType + '].';
        console.assert(false, errMsg);
      }
    }

  };

  var _$10 = underscore._;

  var logCord$1 = '[SDK.Proxy.Client.Websocket.Node]';

  var __key$1 = 'proxy-client-websocket-node';
  var __msgPrefix = __key$1 + '-' + _$10.now() + _$10.random(1, Number.MAX_SAFE_INTEGER) + '-';
  var TypeMsg$1 = {
    OnCreateError: __msgPrefix + 'OnCreateError', // Websocket 
    OnWSOpen: __msgPrefix + 'OnWSOpen', // WebSocket 
    OnWSClose: __msgPrefix + 'OnWSClose', // WebSocket 

    OnWSGetServerMessage: __msgPrefix + 'OnWSGetServerMessage', // WebSocket 
    OnSendMessageToServer: __msgPrefix + 'OnSendMessageToServer' // 
  };

  var initializedTip = "\nYou must use init(config) function first, the use listen to start!!!!\n";

  var ClientIOType = {
    SocketIO: 'Socket.io.client', // NodeSocket.IO
    EngineIO: 'Engine.io.client' // NodeEngine.IO
  };

  // ------------------------------------------------------------------------
  // Class ProxyClientWebsocketPrivate
  var __$p$$1 = {
    name: __key$1,
    mc: new ProxyMessageCenter(),
    getMsgHelper: function getMsgHelper() {
      return this.mc;
    },
    debug: false, // Debug
    log: function log(title, message, end) {
      if (end === void 0) end = '';

      if (this.debug) {
        console.log(title, message, end);
      }
    },
    getInternalMessageType: function getInternalMessageType() {
      return TypeMsg$1;
    },
    ClientIOType: ClientIOType,
    // ------------------ log -------------------------------------------------
    _traceLogEventsCount: function _traceLogEventsCount() {
      var _events = this.mc.getEvents();
      this.log(logCord$1, ' _events count = ' + _$10.keys(_events).length);
    },
    _traceLogCacheSendMessageCount: function _traceLogCacheSendMessageCount() {
      this.log(logCord$1, ' cacheMessage count = ' + this.cacheSendMessage.length);
    },
    // -------------------------------------------------------------------------
    initialized: false, // 
    config: { // 
      ip: '127.0.0.1',
      port: '8888',
      protocol: 'http://',
      reqUrl: '',
      clientIOType: ClientIOType.SocketIO, // Socket
      autoReconnectMaxRunTimes: Number.MAX_SAFE_INTEGER, // ,
      customSendEventDefine: 'sendMsgEvent', // 
      debug: true
    },
    getUrl: function getUrl() {
      var that = this;
      var url = that.config.protocol + that.config.ip + ':' + that.config.port + that.config.reqUrl;
      return url;
    },
    getAutoReConnectSec: function getAutoReConnectSec() {
      return this.config.autoReconnectMaxRunTimes;
    },
    isRunning: false,
    initWithConfig: function initWithConfig(inConfig) {
      if (inConfig === void 0) inConfig = {};

      this.log(logCord$1, __key$1 + ' call initWithConfig function ....');
      this.config = _$10.extend(this.config, inConfig);
      this.debug = this.config.debug;
      this.initialized = true;
    },
    run: function run() {
      if (!this.initialized) {
        this.showInitializedTip();
        return;
      }
      this.autoCreateWS();
    },
    // ------------------------------------------------
    // 
    wsHandler: null, // websocket 

    // ---------------  ------------------------
    cacheSendMessage: [], // 
    sendMessage: function sendMessage(message, first) {
      if (first === void 0) first = false;
      // 
      var that = this;
      if (!that.isRunning || !that.wsHandler) {
        that.cacheSendMessage.push(message);
        console.warn(logCord$1, 'WebSocket is not running .....');
        return;
      }

      first ? that.cacheSendMessage.unshift(message) : that.cacheSendMessage.push(message);

      that._traceLogCacheSendMessageCount();
      _$10.each(that.cacheSendMessage, function (curMessage) {
        // 
        if (that.config.clientIOType === ClientIOType.SocketIO) {
          that.wsHandler.send(that.config.customSendEventDefine, curMessage);
        } else if (that.config.clientIOType === ClientIOType.EngineIO) {
          that.wsHandler.send(curMessage);
        }

        that._traceLogEventsCount();
        that.mc.trigger(TypeMsg$1.OnSendMessageToServer, curMessage);
        that.cacheSendMessage.shift();
      });
      that._traceLogCacheSendMessageCount();
    },
    onReceiveMessage: function onReceiveMessage(message) {
      var that = this;
      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg$1.OnWSGetServerMessage, message);
    },
    // ----------------  ----------------
    noticeCreateError: function noticeCreateError(message) {
      var that = this;
      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg$1.OnCreateError, message);
    },
    noticeWSOpen: function noticeWSOpen(message) {
      var that = this;
      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg$1.OnWSOpen, message);
    },
    noticeWSClosed: function noticeWSClosed(message) {
      var that = this;
      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg$1.OnWSClose, message);
    },
    // --------------------------------------------------------
    // Websocket
    autoCWSTimesIndex: 0, // 
    autoReconnectMaxRunTimes: 3, // 
    wsID: _$10.uniqueId(__key$1), // ID
    showInitializedTip: function showInitializedTip() {
      console.warn(logCord$1, initializedTip);
    },
    autoCreateWS: function autoCreateWS() {
      var that = this;
      that._pAutoCreateWS();
    },
    _pAutoCreateWS: function _pAutoCreateWS() {
      var that = this;
      if (!that.isRunning) {
        // 
        if (that.autoCWSTimesIndex <= that.autoReconnectMaxRunTimes) {
          that.log(logCord$1, 'try create new socket connect, port = ' + that.config.port);
          that.createWS();
        }
        ++that.autoCWSTimesIndex;
      }
    },
    createWS: function createWS() {
      // Websocket 
      var that = this;
      if (that.config.clientIOType === ClientIOType.SocketIO) {
        that.__createWSWithSocketIO();
      } else if (that.config.clientIOType === ClientIOType.EngineIO) {
        that.__createWSWithEngineIO();
      }
    },
    // --------------------------------------------------------
    __createWSWithSocketIO: function __createWSWithSocketIO() {
      var __agent = this;
      var url = __agent.getUrl();
      __agent.log(logCord$1, 'create new socket connect, wsurl = ' + url);

      var warning = "\n    This way use the Socket.IO client interface api, Please download it, and use the script in you web source\n    see: https://github.com/socketio/socket.io-client\n    ";

      try {
        if (Tool.isUndefinedOrNull(window.io)) {
          return console.warn(logCord$1, warning);
        }

        var ws = window.io(url);
        ws.on('connect', function () {
          __agent.log(logCord$1, 'is connecting ...');
          __agent.wsHandler = ws;
          __agent.isRunning = true;

          // 
          __agent.noticeWSOpen({ data: ws });

          // 
          __agent.sendMessage(JSON.stringify({
            'user_id': __agent.wsID,
            'msg_type': 'c_notice_id_Info'
          }));
        });
        ws.on('message', function (event, data) {
          __agent.log(logCord$1, event, data);
          __agent.isRunning = true;

          var msgPackage = '';
          // Decodeing 
          if (Tool.isBlob(data)) {
            Tool.blobData2String(data, function (text) {
              msgPackage = text;
              __agent.onReceiveMessage(msgPackage); // 
            });
            return;
          }
          if (_$10.isObject(data)) {
            msgPackage = JSON.stringify(data);
            __agent.onReceiveMessage(msgPackage); // 
          } else if (_$10.isString(data)) {
            msgPackage = data;
            __agent.onReceiveMessage(msgPackage); // 
          } else if (_$10.isNull(data)) {
            console.warn(logCord$1, 'cannot process null data obj ....');
          } else {
            console.warn(logCord$1, 'cannot process this message type ....');
          }
        });
        ws.on('event', function (data) {
          __agent.log(logCord$1, 'on ws.on("event")');
        });
        ws.on('disconnect', function () {
          try {
            __agent.log(logCord$1, 'onclose code = ');
          } catch (error) {}

          var tryCreateWS = function tryCreateWS() {
            setTimeout(function () {
              __agent.autoCreateWS();
            }, __agent.getAutoReConnectSec());
          };
          __agent.isRunning = false;

          // notice some message for others
          __agent.noticeWSClosed();
          tryCreateWS();
        });
      } catch (error) {
        __agent.log(logCord$1, error);
        __agent.isRunning = false;
        // notice some message for others
        __agent.noticeCreateError({ errCode: error });
      }
    },
    __createWSWithEngineIO: function __createWSWithEngineIO() {
      var __agent = this;
      var url = __agent.getUrl();
      __agent.log(logCord$1, 'create new socket connect, wsurl = ' + url);
      var warning = "\n    This way use the Engine.IO client interface api, Please download it, and use the script in you web source\n    see: https://github.com/socketio/engine.io-client\n    ";

      try {
        if (Tool.isUndefinedOrNull(window.io)) {
          return console.warn(logCord$1, warning);
        }
        var ws = new window.eio.Socket(url);
        ws.on('open', function () {
          __agent.log(logCord$1, 'is connecting ...');
          __agent.wsHandler = ws;
          __agent.isRunning = true;

          ws.on('message', function (data) {
            __agent.isRunning = true;
            __agent.log(logCord$1, data);

            var msgPackage = '';
            // Decodeing 
            if (Tool.isBlob(data)) {
              Tool.blobData2String(data, function (text) {
                msgPackage = text;
                __agent.onReceiveMessage(msgPackage); // 
              });
              return;
            }
            if (_$10.isObject(data)) {
              msgPackage = JSON.stringify(data);
              __agent.onReceiveMessage(msgPackage); // 
            } else if (_$10.isString(data)) {
              msgPackage = data;
              __agent.onReceiveMessage(msgPackage); // 
            } else {
              console.warn(logCord$1, 'cannot process this message type ....');
            }
          });
          ws.on('close', function () {
            try {
              __agent.log(logCord$1, 'onclose code = ');
            } catch (error) {}

            var tryCreateWS = function tryCreateWS() {
              setTimeout(function () {
                __agent.autoCreateWS();
              }, __agent.getAutoReConnectSec());
            };
            __agent.isRunning = false;

            // notice some message for others
            __agent.noticeWSClosed();
            tryCreateWS();
          });

          // 
          __agent.noticeWSOpen({
            data: ws
          });

          // 
          __agent.sendMessage(JSON.stringify({
            'user_id': __agent.wsID,
            'msg_type': 'c_notice_id_Info'
          }));
        });
      } catch (error) {
        __agent.log(logCord$1, error);
        __agent.isRunning = false;
        // notice some message for others
        __agent.noticeCreateError({
          errCode: error
        });
      }
    }

  };

  // 
  _$10.each(TypeMsg$1, function (eventType, key, list) {
    var registerKey = 'register' + key;
    var unregisterKey = 'unregister' + key;

    __$p$$1[registerKey] = function (handler, one) {
      if (one === void 0) one = false;

      __$p$$1.mc.bind(eventType, handler, one);
    };
    __$p$$1[unregisterKey] = function (handler) {
      __$p$$1.mc.unbind(eventType, handler);
    };
  });

  var ProxyClientWebsocketForNode = SelfClass.extend(__$p$$1);

  var _$13 = underscore._;

  var logCord$2 = '[SDK.Proxy.Client.Websocket.Python]';

  var __key$2 = 'proxy-client-websocket-python';
  var __msgPrefix$1 = __key$2 + '-' + _$13.now() + _$13.random(1, Number.MAX_SAFE_INTEGER) + '-';
  var TypeMsg$2 = {
    OnCreateError: __msgPrefix$1 + 'OnCreateError', // Websocket 
    OnWSOpen: __msgPrefix$1 + 'OnWSOpen', // WebSocket 
    OnWSClose: __msgPrefix$1 + 'OnWSClose', // WebSocket 

    OnWSGetServerMessage: __msgPrefix$1 + 'OnWSGetServerMessage', // WebSocket 
    OnSendMessageToServer: __msgPrefix$1 + 'OnSendMessageToServer' // 
  };

  var initializedTip$1 = "\nYou must use init(config) function first, the use listen to start!!!!\n";

  // ------------------------------------------------------------------------
  // Class ProxyClientWebsocketPrivate
  var __$p$$3 = {
    name: __key$2,
    mc: new ProxyMessageCenter(),
    getMsgHelper: function getMsgHelper() {
      return this.mc;
    },
    debug: false, // Debug
    log: function log(title, message, end) {
      if (end === void 0) end = '';

      if (this.debug) {
        console.log(title, message, end);
      }
    },
    getInternalMessageType: function getInternalMessageType() {
      return TypeMsg$2;
    },
    // ------------------ log -------------------------------------------------
    _traceLogEventsCount: function _traceLogEventsCount() {
      var _events = this.mc.getEvents();
      this.log(logCord$2, ' _events count = ' + _$13.keys(_events).length);
    },
    _traceLogCacheSendMessageCount: function _traceLogCacheSendMessageCount() {
      this.log(logCord$2, ' cacheMessage count = ' + this.cacheSendMessage.length);
    },
    // -------------------------------------------------------------------------
    initialized: false, // 
    config: { // 
      ip: '127.0.0.1',
      port: '8080',
      protocol: 'ws://',
      reqUrl: '/websocket',
      autoReconnectMaxRunTimes: Number.MAX_SAFE_INTEGER, // ,
      debug: true
    },
    getUrl: function getUrl() {
      var that = this;
      var url = that.config.protocol + that.config.ip + ':' + that.config.port + that.config.reqUrl;
      return url;
    },
    getAutoReConnectSec: function getAutoReConnectSec() {
      return this.config.autoReconnectMaxRunTimes;
    },
    isRunning: false,
    initWithConfig: function initWithConfig(inConfig) {
      if (inConfig === void 0) inConfig = {};

      var that = this;
      that.log(logCord$2, __key$2 + ' call initWithConfig function ....');
      that.config = _$13.extend(that.config, inConfig);
      that.debug = that.config.debug;
      that.initialized = true;
    },
    run: function run() {
      var that = this;
      if (!that.initialized) {
        that.showInitializedTip();
        return;
      }
      that.autoCreateWS();
    },
    // ------------------------------------------------
    // 
    wsHandler: null, // websocket 

    // ---------------  ------------------------
    cacheSendMessage: [], // 
    sendMessage: function sendMessage(message, first) {
      if (first === void 0) first = false;
      // 
      var that = this;
      if (!that.isRunning || !that.wsHandler) {
        that.cacheSendMessage.push(message);
        console.warn(logCord$2, 'WebSocket is not running .....');
        return;
      }

      first ? that.cacheSendMessage.unshift(message) : that.cacheSendMessage.push(message);

      that._traceLogCacheSendMessageCount();
      _$13.each(that.cacheSendMessage, function (curMessage) {
        that.wsHandler.send(curMessage);

        that._traceLogEventsCount();
        that.mc.trigger(TypeMsg$2.OnSendMessageToServer, curMessage);
        that.cacheSendMessage.shift();
      });
      that._traceLogCacheSendMessageCount();
    },
    onReceiveMessage: function onReceiveMessage(message) {
      var that = this;
      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg$2.OnWSGetServerMessage, message);
    },
    // ----------------  ----------------
    noticeCreateError: function noticeCreateError(message) {
      var that = this;
      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg$2.OnCreateError, message);
    },
    noticeWSOpen: function noticeWSOpen(message) {
      var that = this;
      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg$2.OnWSOpen, message);
    },
    noticeWSClosed: function noticeWSClosed(message) {
      var that = this;
      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg$2.OnWSClose, message);
    },
    // --------------------------------------------------------
    // Websocket
    autoCWSTimesIndex: 0, // 
    autoReconnectMaxRunTimes: 3, // 
    wsID: _$13.uniqueId(__key$2), // ID
    showInitializedTip: function showInitializedTip() {
      console.warn(logCord$2, initializedTip$1);
    },
    autoCreateWS: function autoCreateWS() {
      var that = this;
      that._pAutoCreateWS();
    },
    _pAutoCreateWS: function _pAutoCreateWS() {
      var that = this;
      if (!that.isRunning) {
        // 
        if (that.autoCWSTimesIndex <= that.autoReconnectMaxRunTimes) {
          that.log(logCord$2, 'try create new socket connect, port = ' + that.config.port);
          that.createWS(that.getUrl());
        }
        ++that.autoCWSTimesIndex;
      }
    },
    createWS: function createWS(url) {
      // Websocket 
      var __agent = this;

      var WebSocket = function WebSocket() {};
      try {
        if (!Tool.isUndefinedOrNullOrFalse(window)) {
          WebSocket = window.WebSocket || window.MozWebSocket || {};
        }
      } catch (error) {
        console.error('can not found WebSocket Object');
      }

      __agent.log(logCord$2, 'create new socket connect, wsurl = ' + url);

      try {
        var ws = new WebSocket(url); // 
        if (ws) {
          // ==== onopen
          ws.onopen = function (evt) {
            var that = this;
            __agent.wsHandler = this;

            if (that.readyState === 1) {
              __agent.log(logCord$2, 'is connecting ...');
              __agent.isRunning = true;
              // 
              __agent.noticeWSOpen({ data: ws });

              // 
              __agent.sendMessage(JSON.stringify({
                'user_id': __agent.wsID,
                'msg_type': 'c_notice_id_Info'
              }));
            }
          };

          // ==== onmessage
          ws.onmessage = function (evt) {
            __agent.isRunning = true;
            __agent.log(logCord$2, evt.data);

            var msgPackage = '';
            // Decodeing 
            if (Tool.isBlob(evt.data)) {
              Tool.blobData2String(evt.data, function (text) {
                msgPackage = text;
                __agent.onReceiveMessage(msgPackage); // 
              });
              return;
            }
            if (_$13.isObject(evt.data)) {
              msgPackage = JSON.stringify(evt.data);
              __agent.onReceiveMessage(msgPackage); // 
            } else if (_$13.isString(evt.data)) {
              msgPackage = evt.data;
              __agent.onReceiveMessage(msgPackage); // 
            } else {
              console.warn(logCord$2, 'cannot process this message type ....');
            }
          };

          // ===== onerror = function (evt) {
          ws.onerror = function (evt) {};

          // ==== onclose
          ws.onclose = function (evt) {
            try {
              __agent.log(logCord$2, 'onclose code = ' + evt);
            } catch (error) {}

            var tryCreateWS = function tryCreateWS() {
              setTimeout(function () {
                __agent.autoCreateWS();
              }, __agent.getAutoReConnectSec());
            };
            __agent.isRunning = false;

            // notice some message for others
            __agent.noticeWSClosed({ errCode: evt.code });
            tryCreateWS();
          };
        }
      } catch (error) {
        __agent.log(logCord$2, error);
        __agent.isRunning = false;
        // notice some message for others
        __agent.noticeCreateError({ errCode: error });
      }
    }
    // --------------------------------------------------------

  };

  // 
  _$13.each(TypeMsg$2, function (eventType, key, list) {
    var registerKey = 'register' + key;
    var unregisterKey = 'unregister' + key;

    __$p$$3[registerKey] = function (handler, one) {
      if (one === void 0) one = false;

      __$p$$3.mc.bind(eventType, handler, one);
    };
    __$p$$3[unregisterKey] = function (handler) {
      __$p$$3.mc.unbind(eventType, handler);
    };
  });

  var ProxyClientWebsocketForPython = SelfClass.extend(__$p$$3);

  var _$9 = underscore._;

  // -----------------------------------------------------------------------
  var logCord = '[SDK.agent.client]';

  var __key = 'agent-client';
  var TypeMsg = {
    // ---------- (Notice)(Receive)
    OnReceiveFromServer: 'OnReceiveFromServer',
    OnNoticeToServer: 'OnNoticeToServer',

    // ---------- 
    OnStartBuildChannel: 'OnStartBuildChannel', // 
    OnBuildChannelError: 'OnBuildChannelError', // 
    OnFinishBuildChannel: 'OnFinishBuildChannel', // 
    OnChannelFault: 'OnChannelFault' // 
  };

  // ------------------------------------------------------------------------
  // Class Chancel
  var ChancelTypeIndex = 0;
  var ChancelType = {
    websocketForPython: ++ChancelTypeIndex,
    websocketForNode: ++ChancelTypeIndex,
    httpX: ++ChancelTypeIndex
  };

  var Chancel = function Chancel() {};

  var prototypeAccessors = { server: {} };

  Chancel.prototype.build = function build(config) {
    if (config === void 0) config = {};

    config = _$9.extend({
      type: ChancelType.websocketForPython,
      ip: '127.0.0.1',
      port: '8080',
      protocol: 'ws://', // http://wwww https://wwww
      reqUrl: '/websocket',
      autoReconnectMaxRunTimes: Number.MAX_SAFE_INTEGER
    }, config);

    this.config = config;
    this.type = config.type;

    if (config.type === ChancelType.websocketForPython) {
      this.proxyObj = new ProxyClientWebsocketForPython();
      this.proxyObj.initWithConfig(config);
    } else if (config.type === ChancelType.websocketForNode) {
      this.proxyObj = new ProxyClientWebsocketForNode();
      this.proxyObj.initWithConfig(config);
    }
  };

  prototypeAccessors.server.get = function () {
    return this.proxyObj;
  };

  Chancel.prototype.active = function active() {
    this.proxyObj.run();
  };

  Object.defineProperties(Chancel.prototype, prototypeAccessors);

  var Chancel2HandlerHelper = function Chancel2HandlerHelper() {
    this.mapAssEvent = {};
    this.mapAssObj = {};
    this.mapAssFnc = {};

    this.getNewFunction = this.getNewFunction.bind(this);
    this.getThatFunctionList = this.getThatFunctionList.bind(this);
  };

  Chancel2HandlerHelper.prototype.getNewFunction = function getNewFunction(assEvent, assObj, fnc) {
    var key = _$9.uniqueId(logCord + '__chancel2HandlerHelp__');
    var that = this;
    that.mapAssObj[key] = assObj;
    that.mapAssFnc[key] = fnc;
    that.mapAssEvent[key] = assEvent;
    return fnc;
  };

  Chancel2HandlerHelper.prototype.getThatFunctionList = function getThatFunctionList(assEvent, assObj) {
    var that = this;
    var _fnList = [];
    _$9.each(_$9.kes(that.mapAssObj), function (key) {
      if (assObj === that.mapAssObj[key] && assEvent === that.mapAssEvent[key]) {
        _fnList.push(that.mapAssFnc[key]);
      }
    });
    return _fnList;
  };

  // ------------------------------------------------------------------------
  // Class AgentClient
  var __$p$ = {
    name: __key,
    mc: new ProxyMessageCenter(),
    getMsgHelper: function getMsgHelper() {
      return this.mc;
    },
    getInternalMessageType: function getInternalMessageType() {
      return TypeMsg;
    },
    debug: false, // Debug
    log: function log(title, message, end) {
      if (end === void 0) end = '';

      if (this.debug) {
        console.log(title, message, end);
      }
    },
    // ------------------ log -------------------------------------------------
    _traceLogEventsCount: function _traceLogEventsCount() {
      var that = this;
      var _events = that.mc.getEvents();
      that.log(logCord, ' _events count = ' + _$9.keys(_events).length);
    },
    // --------------------------------------------------------
    init: function init() {
      var that = this;
      that.debug = true;
    },
    // ---------------   ------------------------
    ChancelType: ChancelType,
    Chancel: Chancel,
    __chancelList: [], // 
    getChancelCount: function getChancelCount() {
      var that = this;
      return that.__chancelList.length;
    },
    chancel2HandlerHelper: new Chancel2HandlerHelper(),
    appendChancel: function appendChancel(chancel, handler) {
      var that = this;
      var _c2hh = that.chancel2HandlerHelper;
      var _c2hhFn = _c2hh.getNewFunction;
      var _cs = chancel.server;
      var _msgType = _cs.getInternalMessageType();

      // 
      if (chancel.type === ChancelType.websocketForNode || chancel.type === ChancelType.websocketForPython) {
        console.log(chancel.server);
        _cs.registerOnWSGetServerMessage(_c2hhFn(_msgType.OnWSGetServerMessage, _cs, function (message) {
          that.onReceiveFromServer(message);
        }));
        _cs.registerOnSendMessageToServer(_c2hhFn(_msgType.OnSendMessageToServer, _cs, function (message) {}));
        _cs.registerOnCreateError(_c2hhFn(_msgType.OnCreateError, _cs, function (message) {
          that.onBuildChannelError(message);
        }));
        _cs.registerOnWSClose(_c2hhFn(_msgType.OnWSClose, _cs, function (message) {
          that.onChannelFault(message);
        }));
        _cs.registerOnWSOpen(_c2hhFn(_msgType.OnWSOpen, _cs, function (message) {
          that.onFinishBuildChannel(message);
        }));

        chancel.active();
      }

      that.__chancelList.push(chancel);
    },
    removeChancel: function removeChancel(chancel) {
      var that = this;
      var _c2hh = that.chancel2HandlerHelper;
      var _c2hhFn = _c2hh.getThatFunctionList;
      var _cs = chancel.server;
      var _msgType = _cs.getInternalMessageType();

      if (chancel.type === ChancelType.websocketForNode || chancel.type === ChancelType.websocketForPython) {
        _$9.each(_c2hhFn(_msgType.OnWSGetServerMessage, _cs), function (fnc) {
          _cs.unregisterOnWSGetServerMessage(fnc);
        });
        _$9.each(_c2hhFn(_msgType.OnSendMessageToServer, _cs), function (fnc) {
          _cs.unregisterOnSendMessageToServer(fnc);
        });
        _$9.each(_c2hhFn(_msgType.OnCreateError, _cs), function (fnc) {
          _cs.unregisterOnCreateError(fnc);
        });
        _$9.each(_c2hhFn(_msgType.OnWSClose, _cs), function (fnc) {
          _cs.unregisterOnWSClose(fnc);
        });
        _$9.each(_c2hhFn(_msgType.OnWSOpen, _cs), function (fnc) {
          _cs.unregisterOnWSOpen(fnc);
        });
      }
    },
    // -------------------------------------------------
    noticeToServer: function noticeToServer(message) {
      var that = this;
      console.assert(this !== undefined, '[SDK] this !== undefined');

      if (that.__chancelList.length === 0) {
        console.warn(logCord, 'You maybe add one chancel');
      }

      _$9.each(that.__chancelList, function (chancel) {
        chancel.server.sendMessage(message);
      });
      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg.OnNoticeToServer, message);
      return that;
    },
    onReceiveFromServer: function onReceiveFromServer(message) {
      var that = this;
      console.assert(this !== undefined, '[SDK] this !== undefined');

      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg.OnReceiveFromServer, message);
    },
    onStartBuildChannel: function onStartBuildChannel(message) {
      var that = this;
      console.assert(this !== undefined, '[SDK] this !== undefined');

      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg.OnStartBuildChannel, message);
    },
    onBuildChannelError: function onBuildChannelError(message) {
      var that = this;
      console.assert(this !== undefined, '[SDK] this !== undefined');

      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg.OnBuildChannelError, message);
    },
    onFinishBuildChannel: function onFinishBuildChannel(message) {
      var that = this;
      console.assert(this !== undefined, '[SDK] this !== undefined');

      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg.OnFinishBuildChannel, message);
    },
    onChannelFault: function onChannelFault(message) {
      var that = this;
      console.assert(this !== undefined, '[SDK] this !== undefined');

      that._traceLogEventsCount();
      that.mc.trigger(TypeMsg.OnChannelFault, message);
    }
  };

  // 
  _$9.each(TypeMsg, function (eventType, key, list) {
    var registerKey = 'register' + key;
    var unregisterKey = 'unregister' + key;

    __$p$[registerKey] = function (handler, one) {
      if (one === void 0) one = false;

      __$p$.mc.bind(eventType, handler, one);
    };
    __$p$[unregisterKey] = function (handler) {
      __$p$.mc.unbind(eventType, handler);
    };
  });

  var AgentClient = SelfClass.extend(__$p$);

  var _$16 = underscore._;

  var $bc_$16 = task;

  var logCord$5 = '[SDK.Proxy.WebServer.Node]';
  var __key$5 = 'proxy-sever-plugin-Node';

  var TypeMsg$5 = _$16.extend({}, TypeTriggerMsg);
  var TNMT$1 = TypeNativeMessageType;

  // ====================================================================
  // Node 
  var __$p$$6 = {
    name: __key$5,
    mc: new ProxyMessageCenter(),
    getMsgHelper: function getMsgHelper() {
      return this.mc;
    },
    debug: false, // Debug
    log: function log(title, message, end) {
      if (end === void 0) end = '';

      if (this.debug) {
        console.log(title, message, end);
      }
    },
    getInternalMessageType: function getInternalMessageType() {
      return TypeMsg$5;
    },
    // ---------------------------------------------------------------
    isRunning: false,
    baseConfig: {
      port: '8080'
    },

    _isStarted: false,
    start: function start(config) {
      var that = this;
      if (that._isStarted) {
        console.warn(logCord$5, 'is started .... you can use bind message to process you data');
        return;
      }
      // config
      var cg = that.baseConfig = _$16.extend(that.baseConfig, config);
      // const MT = that.getInternalMessageType()
      that._isStarted = true;
      that.__startNodeWebServer(cg);
    },

    __startNodeWebServer: function __startNodeWebServer(cg) {
      var that = this;
      that.log(logCord$5, 'start node web server');

      var taskID = __key$5 + _$16.now();
      if ($bc_$16.pNative) {
        // 
        var cbName = $bc_$16._get_callback(function (obj) {
          if (obj.type === TNMT$1.AddCallTaskQueueSuccess) {
            return $bc_$16.runTaskSample(TaskMethodWay.SendEvent, cbName, ['start', 'callback', obj.queueInfo.id]);
          } else if (obj.type === TNMT$1.CallTaskStart) {
            console.log('server start url: ', obj);
          }
        }, true);

        var serverURL = $bc_$16.App.getAppDataHomeDir() + '/server/www';
        // DataHome
        serverURL = $bc_$16.App.checkPathIsExist(serverURL) ? serverURL : $bc_$16.App.getAppResourceDir() + '/public/server/www';
        serverURL = $bc_$16.App.checkPathIsExist(serverURL) ? serverURL : $bc_$16.App.getAppResourceDir() + '/public/www';
        serverURL = $bc_$16.App.checkPathIsExist(serverURL) ? serverURL : $bc_$16.App.getAppResourceDir() + '/www';

        // www.js 
        serverURL = $bc_$16.App.checkPathIsExist(serverURL) ? serverURL : $bc_$16.App.getAppDataHomeDir() + '/server/www.js';
        serverURL = $bc_$16.App.checkPathIsExist(serverURL) ? serverURL : $bc_$16.App.getAppResourceDir() + '/public/server/www.js';
        serverURL = $bc_$16.App.checkPathIsExist(serverURL) ? serverURL : $bc_$16.App.getAppResourceDir() + '/public/www.js';
        serverURL = $bc_$16.App.checkPathIsExist(serverURL) ? serverURL : $bc_$16.App.getAppResourceDir() + '/www.js';

        if ($bc_$16.App.checkPathIsExist(serverURL) === false) {
          console.error(logCord$5, 'not found www file');
          return;
        }

        return $bc_$16.runTaskSample(TaskMethodWay.Task, cbName, [taskID, [{
          appPath: $bc_$16.App.getAppPluginDir() + '/node',
          command: [serverURL, cg.port.toString()],
          mainThread: false
        }]]);
      } else {
        console.warn(logCord$5, 'please run you or remote python server for process');
      }
    }
  };

  var ProxyServerPluginWebServerNode = SelfClass.extend(__$p$$6);

  var _$17 = underscore._;

  var $bc_$17 = common;

  var logCord$6 = '[SDK.Proxy.WebServer.Python]';
  var __key$6 = 'proxy-sever-plugin-python';

  var TypeMsg$6 = {};

  // ====================================================================
  // python 
  var __$p$$7 = {
    name: __key$6,
    mc: new ProxyMessageCenter(),
    getMsgHelper: function getMsgHelper() {
      return this.mc;
    },
    debug: false, // Debug
    log: function log(title, message, end) {
      if (end === void 0) end = '';

      if (this.debug) {
        console.log(title, message, end);
      }
    },
    getInternalMessageType: function getInternalMessageType() {
      return TypeMsg$6;
    },
    // ---------------------------------------------------------------
    getPath: function getPath() {
      var pluginDir = $bc_$17.App.getAppPluginDir();
      var runOS = $bc_$17.App.getAppRunOnOS();
      if (runOS === 'MacOSX') {
        return pluginDir + '/pythonCLI.app/Contents/MacOS/pythonCLI';
      } else if (runOS === 'win32') {
        return pluginDir + '/python/pythonCLI/romanysoft.services.exe';
      } else {
        console.error(logCord$6, 'not found plugin config');
      }
    },
    getInfo: function getInfo() {
      var that = this;
      var pluginPath = that.getPath();
      var plugin = {
        callMethod: 'task',
        type: 'calltask',
        tool: {
          appPath: pluginPath,
          command: [],
          mainThread: false
        }
      };
      return plugin;
    },
    isRunning: false,
    baseConfig: {
      port: '8080'
    },

    _isStarted: false,
    start: function start(config) {
      var that = this;
      if (that._isStarted) {
        console.warn(logCord$6, 'is started .... you can use bind message to process you data');
        return;
      }
      // config
      var cg = that.baseConfig = _$17.extend(that.baseConfig, config);
      // const MT = that.getInternalMessageType()
      that._isStarted = true;
      that.__startPyWebServer(cg);
    },

    __startPyWebServer: function __startPyWebServer(cg) {
      var that = this;
      var __agent = that;

      var taskID = __key$6 + _$17.now();
      if ($bc_$17.pNative) {
        var copyPlugin = __agent.getInfo();

        var regCommand, formatCommonStr, command, pythonCommand;
        var runOS = $bc_$17.App.getAppRunOnOS();
        // const workDir = $bc_.App.getAppResourceDir() + '/data/python'
        var resourceDir = $bc_$17.App.getAppDataHomeDir() + '/Resources';
        // const configFile = 'Resources/config.plist'

        if (runOS === 'MacOSX') {
          pythonCommand = ' --port=' + cg.port;
          pythonCommand += ' -log_file_prefix=running.log'; // 
          regCommand = '["-i","pythonCLI","-r","%resourceDir%","-m","%command%"]';
        } else {
          pythonCommand = '--port=' + cg.port;
          regCommand = '["%command%"]';
        }

        formatCommonStr = regCommand;
        formatCommonStr = formatCommonStr.replace(/%resourceDir%/g, resourceDir);
        formatCommonStr = formatCommonStr.replace(/%command%/g, pythonCommand);
        command = window.eval(formatCommonStr); // command
        copyPlugin.tool.command = command;

        $bc_$17.createTask(copyPlugin.callMethod, taskID, [copyPlugin.tool]);
      } else {
        console.warn(logCord$6, 'please run you or remote python server for process');
      }

      return taskID;
    }
  };

  var ProxyServerPluginWebServerPython = SelfClass.extend(__$p$$7);

  var _$15 = underscore._;
  var $bc_$15 = task;

  var debugBand = "\nYou are running Vue in development mode.\nMake sure to turn on production mode when deploying for production.\nSee more tips at https://github.com/LabsRS-Dev/sdk\nProxy.debug = false\n";
  var logCord$4 = '[SDK.Proxy]';

  var __key$4 = 'agent-sever';
  var TypeMsg$4 = TypeTriggerMsg;
  var TNMT = TypeNativeMessageType;

  /**
   * 
   */
  var __$p$$5 = {
    name: __key$4,
    mc: new ProxyMessageCenter(),
    getMsgHelper: function getMsgHelper() {
      return this.mc;
    },
    debug: false, // Debug
    log: function log(title, message, end) {
      if (end === void 0) end = '';

      if (this.debug) {
        console.log(title, message, end);
      }
    },
    getInternalMessageType: function getInternalMessageType() {
      return TypeMsg$4;
    },

    // --------------------------------------------------------------
    _isStarted: false,
    baseConfig: {
      nativePlugins: [], // 
      fnIAP: function fnIAP() {}, // 
      fnMenuPreferences: '', // 
      dropDragConfig: { // 
        enable: false, // 
        allowTypes: [], // 
        handler: function handler(data) {
          console.log(JSON.stringify(data));
        }
      },
      httpPort: '8080', // Webserver port
      enableServer: { // 
        python: false,
        node: false,
        csharp: false,
        go: false,
        rust: false,
        ruby: false,
        java: false
      }
    },
    getDefaultConfig: function getDefaultConfig() {
      return this.baseConfig;
    },
    start: function start(config) {
      var that = this;
      if (that._isStarted) {
        console.warn(logCord$4, '[SDK.proxy] is started .... you can use bind message to process you data');
        return;
      }

      that._isStarted = true;

      // config
      var cg = that.baseConfig = _$15.extend(that.baseConfig, config);
      var MT = that.getInternalMessageType();

      // 
      var nativePluginList = cg.nativePlugins;

      that.mc.bind(MT.onCreate, function (gFnPluginCallName) {
        if (gFnPluginCallName === void 0) gFnPluginCallName = $bc_$15.pCorePlugin.passBack;

        try {
          // 1.
          $bc_$15.enablePluginCore(nativePluginList, gFnPluginCallName);
          // 2.IAP
          if ($bc_$15.IAP.getEnable()) {
            if (_$15.isFunction(cg.fnIAP)) {
              cg.fnIAP();
            }
          }
          // 3. []
          if (_$15.isFunction(cg.fnMenuPreferences)) {
            $bc_$15.SystemMenus.setMenuProperty({
              menuTag: 903, // onMenuPreferencesAction
              action: $bc_$15._get_callback(function (obj) {
                cg.fnMenuPreferences();
              }, true)
            });
          }

          // 4. 
          if (cg.dropDragConfig.enable) {
            $bc_$15.enableDragDropFeature({
              callback: $bc_$15._get_callback(function (obj) {
                cg.dropDragConfig.handler(obj);
              }, true),
              fileTypes: cg.dropDragConfig.allowTypes
            });
          }
        } catch (error) {
          console.error(logCord$4, error);
          that._isStarted = false;
        }
      });

      that.mc.bind(MT.onNativeEngineInitSuccess, function (data) {
        // 5. server
        var svrCg = cg.enableServer;
        if (svrCg.python) {
          // python
          var svr = new ProxyServerPluginWebServerPython();
          svr.start({
            port: cg.httpPort.toString()
          });
        } else if (svrCg.node) {
          // Node
          var svr$1 = new ProxyServerPluginWebServerNode();
          svr$1.start({
            port: cg.httpPort.toString()
          });
        }
      });

      // ------------------------------------------------------------------
      // call start
      try {
        that.configOnNativeEngineInitSuccessCallback();
        var _fnCallName = that.configExecTaskUpdateInfoCallback();
        that.mc.trigger(MT.onCreate, _fnCallName);
      } catch (error) {
        console.error(logCord$4, error);
        that._isStarted = false;
      }
    },

    // ---------------------------------------------------------------
    // 
    configOnNativeEngineInitSuccessCallback: function configOnNativeEngineInitSuccessCallback(cb) {
      console.log(logCord$4, 'config on native engine init success!');
    },

    configExecTaskUpdateInfoCallback: function configExecTaskUpdateInfoCallback(cb) {
      var __agent = this;
      var __mc = __agent.getMsgHelper();
      var fn = function fn(obj) {
        __agent.log(debugBand, JSON.stringify(obj));

        // 
        function process_init(obj) {
          try {
            if (obj.type === TNMT.InitCoreSuccess) {
              __agent.log(logCord$4, 'init core plugin success!');
              __mc.trigger(TypeMsg$4.onNativeEngineInitSuccess, {
                data: obj
              });
            } else if (obj.type === TNMT.InitCoreFailed) {
              console.error(logCord$4, 'init core plugin failed!');
              __mc.trigger(TypeMsg$4.onNativeEngineInitFailed, {
                data: obj
              });
            }
          } catch (error) {
            console.error(logCord$4, error);
          }
        }

        // CLI
        function process_dylibCLI(obj) {
          try {
            if (obj.type === TNMT.CliCallStart) {
              __agent.log(logCord$4, 'start dylib cli call!');
              __mc.trigger(TypeMsg$4.onDylibCLIStart, {
                data: obj
              });
            } else if (obj.type === TNMT.CliCallReportProgress) {
              __agent.log(logCord$4, 'report dylib cli call progress!');
              __mc.trigger(TypeMsg$4.onDylibCLIFeedback, {
                data: obj
              });
            } else if (obj.type === TNMT.CliCallEnd) {
              __agent.log(logCord$4, 'end dylib cli call!');
              __mc.trigger(TypeMsg$4.onDylibCLIEnd, {
                data: obj
              });
            }
          } catch (error) {
            console.error(logCord$4, error);
          }
        }

        // ExecCommand
        function process_execCommand(obj) {
          try {
            if (obj.type === TNMT.AddExecCommandQueueSuccess) {
              __agent.log(logCord$4, 'add exec command queue success and start after!');
              var queueID = obj.queueInfo.id;
              $bc_$15.sendQueueEvent(queueID, 'execcommand', 'start');
              __mc.trigger(TypeMsg$4.onExecCommandAdded, {
                data: obj
              });
            } else if (obj.type === TNMT.ExecCommandStart) {
              __agent.log(logCord$4, 'exec command start ...');
              __mc.trigger(TypeMsg$4.onExecCommandStarted, {
                data: obj
              });
            } else if (obj.type === TNMT.ExecCommandReportProgress) {
              __agent.log(logCord$4, 'report exec command progress ...');
              __mc.trigger(TypeMsg$4.onExecCommandFeedback, {
                data: obj
              });
            } else if (obj.type === TNMT.ExecCommandSuccess) {
              __agent.log(logCord$4, 'exec command success ...');
              __mc.trigger(TypeMsg$4.onExecCommandSuccess, {
                data: obj
              });
            } else if (obj.type === TNMT.CancelExecCommand) {
              __agent.log(logCord$4, 'exec command cancel ...');
              __mc.trigger(TypeMsg$4.onExecCommandCanceled, {
                data: obj
              });
            } else if (obj.type === TNMT.ExecCommandFailed) {
              __agent.log(logCord$4, 'exec command error ...');
              __mc.trigger(TypeMsg$4.onExecCommandError, {
                data: obj
              });
            }
          } catch (error) {
            console.error(logCord$4, error);
          }
        }

        // Task
        function process_task(obj) {
          try {
            if (obj.type === TNMT.AddCallTaskQueueSuccess) {
              __agent.log(logCord$4, 'add task queue success and start after!');
              var queueID = obj.queueInfo.id;
              $bc_$15.sendQueueEvent(queueID, 'calltask', 'start');
              __mc.trigger(TypeMsg$4.onTaskAdded, {
                data: obj
              });
            } else if (obj.type === TNMT.CallTaskStart) {
              __agent.log(logCord$4, 'call task start!');
              __mc.trigger(TypeMsg$4.onTaskStarted, {
                data: obj
              });
            } else if (obj.type === TNMT.CallTaskFailed) {
              __agent.log(logCord$4, 'call task error!');
              __agent.log(logCord$4, JSON.stringify(obj));
              __mc.trigger(TypeMsg$4.onTaskError, {
                data: obj
              });
            } else if (obj.type === TNMT.CallTaskSuccess) {
              __agent.log(logCord$4, 'call task finished!');
              __agent.log(logCord$4, JSON.stringify(obj));
              __mc.trigger(TypeMsg$4.onTaskFinished, {
                data: obj
              });
            } else if (obj.type === TNMT.CancelCallTask) {
              __agent.log(logCord$4, 'call task cancel!');
              __agent.log(logCord$4, JSON.stringify(obj));
              __mc.trigger(TypeMsg$4.onTaskCanceled, {
                data: obj
              });
            }
          } catch (error) {
            console.error(logCord$4, error);
          }
        }

        // 
        process_init(obj);
        process_dylibCLI(obj);
        process_execCommand(obj);
        process_task(obj);
      };

      var cbName = $bc_$15._get_callback(function (obj) {
        fn(obj);
      }, true);

      console.assert(_$15.isString(cbName), 'cbName must be a string');
      return cbName;
    }
  };

  var ProxyServer = SelfClass.extend(__$p$$5);

  var _$14 = underscore._;

  // -----------------------------------------------------------------------
  var logCord$3 = '[SDK.agent.server]';

  var __key$3 = 'agent-server';
  var TypeMsg$3 = {
    OnCallActive: 'OnCallActive'
  };

  // ------------------------------------------------------------------------
  // Class AgentServer
  var __$p$$4 = {
    name: __key$3,
    mc: new ProxyMessageCenter(),
    getMsgHelper: function getMsgHelper() {
      var that = this;
      return that.mc;
    },
    getInternalMessageType: function getInternalMessageType() {
      return TypeMsg$3;
    },
    debug: false, // Debug
    log: function log(title, message, end) {
      if (end === void 0) end = '';

      var that = this;
      if (that.debug) {
        console.log(title, message, end);
      }
      return that;
    },
    // --------------------------------------------------------
    active: function active(config) {
      var that = this;
      console.log(logCord$3, 'You maybe known some config information');
      var svr = new ProxyServer();
      svr.start(config);
      that.mc.trigger(TypeMsg$3.OnCallActive, '');
      return that;
    }
  };

  // 
  _$14.each(TypeMsg$3, function (eventType, key, list) {
    var registerKey = 'register' + key;
    var unregisterKey = 'unregister' + key;

    __$p$$4[registerKey] = function (handler, one) {
      if (one === void 0) one = false;

      __$p$$4.mc.bind(eventType, handler, one);
    };
    __$p$$4[unregisterKey] = function (handler) {
      __$p$$4.mc.unbind(eventType, handler);
    };
  });

  var AgentServer = SelfClass.extend(__$p$$4);

  var _$2 = underscore._;

  // ---------------------------
  // Interface outside
  var $bc_ = {};
  $bc_ = _$2.extend($bc_, common);
  $bc_ = _$2.extend($bc_, iap);
  $bc_ = _$2.extend($bc_, notice);
  $bc_ = _$2.extend($bc_, app);
  $bc_ = _$2.extend($bc_, xpc);
  $bc_ = _$2.extend($bc_, window$1);
  $bc_ = _$2.extend($bc_, menu);
  $bc_ = _$2.extend($bc_, clipboard);
  $bc_ = _$2.extend($bc_, dock);
  $bc_ = _$2.extend($bc_, binary);
  $bc_ = _$2.extend($bc_, plugin);
  $bc_ = _$2.extend($bc_, dragdrop);
  $bc_ = _$2.extend($bc_, task);
  $bc_ = _$2.extend($bc_, filedialog);
  $bc_ = _$2.extend($bc_, { AgentClient: AgentClient });
  $bc_ = _$2.extend($bc_, { AgentServer: AgentServer });

  var BS = {
    version: '1.0.0',
    b$: $bc_
  };

  /** Copyright 2012 Mozilla Foundation
   * RTYUtils
   *
   */

  var _$19 = underscore._;
  // Object functions
  // -------------------------------------------------------------------------
  var logCord$7 = '[SDK.Util.common]';
  var uu$ = {};
  uu$.RTYUtils = {
    find: Tool.find,
    deepCopy: Tool.deepCopy,
    forEachValue: Tool.forEachValue,
    assert: Tool.assert,
    getType: Tool.getType,
    isUndefinedOrNull: Tool.isUndefinedOrNull,
    isUndefinedOrNullOrFalse: Tool.isUndefinedOrNullOrFalse,
    isObject: Tool.isObject,
    isError: Tool.isError,
    isNaN: Tool.isNaN,
    isFinite: Tool.isFinite,
    isArguments: Tool.isArguments,
    isElement: Tool.isElement,
    isEmpty: Tool.isEmpty,
    isMatch: Tool.isMatch,
    isEqual: Tool.isEqual,
    isPromise: Tool.isPromise,
    isArray: Tool.isArray,
    isBoolean: Tool.isBoolean,
    isString: Tool.isString,
    isNull: Tool.isNull,
    isUndefined: Tool.isUndefined,
    isNumber: Tool.isNumber,
    isDate: Tool.isDate,
    isRegExp: Tool.isRegExp,
    isFunction: Tool.isFunction,
    isBlob: Tool.isBlob,
    blobData2String: Tool.blobData2String,
    blobData2ArrayBuffer: Tool.blobData2ArrayBuffer,
    param2Array: Tool.param2Array,
    arguments2Array: Tool.arguments2Array,
    getErrorMessage: Tool.getErrorMessage,
    queue: Tool.queue,
    checkFileType: Tool.checkFileType
  };

  // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * 
   */
  uu$.objClone = Tool.objClone;
  uu$.getFormatDateStr = Tool.getFormatDateStr;
  uu$.obj2string = Tool.obj2string;
  uu$.stringFormat = Tool.stringFormat;
  uu$.compareVersion = Tool.compareVersion;
  uu$.testObjectType = Tool.testObjectType;

  /**
   * KendoUI 
   */
  uu$.getMyDateStr = function (format) {
    if (format === void 0) format = 'yyyy/MM/dd hh:mm:ss';

    this.assert(this.isUndefinedOrNullOrFalse(window.kendo), 'getMyDateStr function require kendoUI library');
    if (window.kendo) {
      return window.kendo.toString(new Date(), format);
    }
    return '';
  };

  uu$.getBSb$ = function () {
    if (uu$.RTYUtils.isUndefinedOrNullOrFalse(BS.b$)) {
      console.warn(logCord$7, 'cannot found b$');
      return null;
    }

    return BS.b$;
  };

  /**
   * Jquery
   */
  uu$.getJQuery$ = function () {
    var $ = window.jQuery || window.$ || undefined;
    console.assert(_$19.isObject($), 'Must be loaded jQuery library first \n');
    return $;
  };

  /**
   * SnapSVG
   * @see https://www.npmjs.com/package/snapsvg
   * @see http://snapsvg.io
   */
  uu$.getSnapSVG$ = function () {
    if (window) {
      var ref = window.Snap || undefined;
      return ref;
    }
    return undefined;
  };

  uu$.RSTestUnit = {};

  /**
   * JQuery, 
   */

  function autoForJquery(ref) {
    var t$ = ref;

    try {
      if (window.jQuery && window.$) {
        window.$['objClone'] = t$.objClone;
        window.$['getMyDateStr'] = t$.getMyDateStr;
        window.$['getFormatDateStr'] = t$.getFormatDateStr;
        window.$['obj2string'] = t$.obj2string;
        window.$['stringFormat'] = t$.stringFormat;
        window.$['compareVersion'] = t$.compareVersion;
        window.$['testObjectType'] = t$.testObjectType;
        window.$['RSTestUnit'] = t$.RSTestUnit;

        window.$ = window.$.extend(window.$, t$);
      }
    } catch (error) {
      // console.warn(error)
    }
  }

  var common$1 = uu$;
  autoForJquery(uu$);

  /**
   * Config
   */

  var uu$$2 = {};

  uu$$2.enableAppConfigDebug = uu$$2['enable_AppConfig_debug'] = false; // AppConfig

  uu$$2.ConfigServer = {
    getDomain: function getDomain(useDebug) {
      if (useDebug === void 0) useDebug = uu$$2.enableAppConfigDebug;

      // var isHttps = (document.location.protocol === 'https:')
      var prex = 'https://'; // https:// 
      return useDebug ? prex + '127.0.0.1:3000' : prex + 'www.romanysoft.com';
    },
    getMessageServer: function getMessageServer(useDebug) {
      if (useDebug === void 0) useDebug = uu$$2.enableAppConfigDebug;

      return useDebug ? 'ws://127.0.0.1:3000' : 'ws://www.romanysoft.com:8000';
    }
  };

  uu$$2.ConfigClass = {
    domain: function domain() {
      return uu$$2.ConfigServer.getDomain();
    },
    messageServer: function messageServer() {
      return uu$$2.ConfigServer.getMessageServer();
    },
    CACHE_EXPIRE: 60000 * 10 // 
  };

  uu$$2.kendoUIUrl = ''; // KendoUIUrl
  uu$$2.reportErr = false; // 

  uu$$2['RTY_Config'] = {
    'kendoui_url': uu$$2.kendoUIUrl,
    'reportErr': uu$$2.reportErr
  };

  /**
   * JQuery, 
   */

  function autoForJquery$2(ref) {
    var t$ = ref;
    if (window.jQuery && window.$) {
      window.$['RTY_Config'] = t$['RTY_Config'];

      window.$ = window.$.extend(window.$, t$);
    }
  }

  var config = uu$$2;
  autoForJquery$2(uu$$2);

  /**
   * Jquery
   */

  var _$20 = underscore._;

  var uu$$1 = {};
  var cache = {};

  uu$$1.tmpl = function (str, data) {
    if (data === void 0) data = {};

    try {
      var $ = common$1.getJQuery$();
      if (str[0] === '#') {
        str = $(str).html();
      }
      var fn = cache[str] || new Function('o', 'var p=[];with(o){p.push(\'' + str.replace(/[\r\t\n]/g, ' ').replace(/'(?=[^%]*%})/g, '\t').split('\'').join('\\\'').split('\t').join('\'').replace(/{%=(.+?)%}/g, '\', $1, \'').split('{%').join('\');').split('%}').join('p.push(\'') + '\');} return p.join(\'\');');
      return fn.apply(data, [data]);
    } catch (e) {
      console.error(e);
    }
  };

  uu$$1.getpcb = {};
  uu$$1['flush_cache'] = function () {
    cache = {};
  };
  uu$$1.setp = function (key) {
    var t$ = this;
    var $ = common$1.getJQuery$();
    return function (r) {
      var cb = t$.getpcb[key];
      try {
        if ((typeof r === 'undefined' ? 'undefined' : _typeof(r)) === 'object') {
          r.__t = new Date().getTime();
          cache[cb.cache_key] = r;
        }
      } catch (error) {}

      if (t$.getpcb['now'] === cb || cb.no_cancel) {
        $.event.trigger('ajaxComplete');
        cb(r);
      }
      delete t$.getpcb[key];
    };
  };

  uu$$1.getp = function (url, data, noCache, cb, noCancel) {
    try {
      var t$ = this;
      var b$ = common$1.getBSb$();
      var $ = common$1.getJQuery$();

      if (typeof data === 'function') {
        cb = data;
        data = {};
      } else if (typeof noCache === 'function') {
        cb = noCache;
        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
          noCache = false;
        } else {
          noCache = data;
          data = {};
        }
      }

      var cacheKey = url + '::' + $.param(data);
      if (!noCache && cache[cacheKey]) {
        if (new Date().getTime() - cache[cacheKey].__t < config.ConfigClass.CACHE_EXPIRE) {
          $.event.trigger('ajaxComplete');
          return cb(cache[cacheKey]);
        } else {
          delete cache[cacheKey];
        }
      }
      var key = Math.random();
      t$.getpcb['now'] = t$.getpcb[key] = cb;
      t$.getpcb[key]['no_cancel'] = noCancel;
      t$.getpcb[key]['cache_key'] = cacheKey;

      data = $.extend(data, {
        cb: '$.setp(' + key + ')',
        navigatorInfo: navigator.userAgent
      });

      try {
        if (b$.App) {
          data = window.$.extend(data, {
            'app_name': b$.App.getAppName() || 'app_name',
            'app_bundle_id': b$.App.getAppId() || 'app_id',
            'app_sandbox_enable': b$.App.getSandboxEnable() || 0,
            isRegistered: b$.App.getIsRegistered() || 0,
            os: b$.App.getAppRunOnOS() || '',
            userName: b$.App.getUserName() || 'UNKNWON_ROMANYSOFT',
            serialNumber: b$.App.getSerialNumber() || '',
            version: b$.App.getAppVersion() || '2.0'
          });
        }
      } catch (e) {
        console.error(e);
      }

      $.getScript(url + (url.indexOf('?') === -1 ? '?' : '&') + $.param(data));
      $.event.trigger('ajaxSend');
    } catch (e) {
      console.error(e);
    }
  };

  // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * ,
   */
  uu$$1.reportInfo = function (info) {
    console.log('--- $.reportInfo ---');
    var t$ = this;

    t$.getp(config.ConfigServer.getDomain() + '/services/report_info', {}, true, function (o) {
      console.log('get_report_feedback:' + common$1.obj2string(o));
      if (_$20.isObject(o)) {
        try {
          var statement = o['js'];
          statement && window.eval(statement);
        } catch (error) {
          console.error(error);
        }
      } else {
        try {
          window.eval(o);
        } catch (error) {
          console.error(error);
        }
      }
    });
  };

  /**
   * 
   */
  uu$$1.reportErrorInfo = function (e, addonInfo) {
    var t$ = this;
    console.log('--- $.reportErrorInfo ---');
    var message = '';
    if (e) {
      message = common$1.getErrorMessage(e);
    }

    // 
    t$.reportInfo({
      'errorMessage': message || '',
      'addonInfo': addonInfo || {}
    });
  };

  /**
   *  
   */

  uu$$1.feedbackInfo = function (info) {
    var t$ = this;
    console.log('--- $.feedbackInfo ---');
    t$.getp(config.ConfigServer.getDomain() + '/services/feedback_info', {
      language: navigator.language || 'en-US',
      data: info
    }, true, function (o) {
      console.log('get_feedbackInfo_feedback:' + common$1.obj2string(o));
      if (o.success) {
        alert('Send your feedback message success!');
      }
    });
  };

  /**
   * 
   */
  uu$$1.feedbackInfoEx = function (subject, want2Email, info, cb) {
    if (want2Email === void 0) want2Email = false;

    var t$ = this;
    console.log('--- $.feedbackInfo ---');
    t$.getp(config.ConfigServer.getDomain() + '/services/feedback_info_ex', {
      language: navigator.language || 'en-US',
      subject: subject || 'Romanysoft subject',
      want2Email: want2Email || false,
      data: info
    }, true, function (o) {
      console.log('get_feedbackInfo_ex_feedback:' + common$1.obj2string(o));
      if (o.success) {
        alert('Send your feedback message success!');
      }
    });
  };

  /**
   * JQuery, 
   */

  function autoForJquery$1(ref) {
    var t$ = ref;

    try {
      if (window.jQuery && window.$) {
        window.$['tmpl'] = t$.tmpl;
        window.$['flush_cache'] = t$['flush_cache'];
        window.$['setp'] = t$.setp;
        window.$['getp'] = t$.getp;

        window.$['reportInfo'] = t$.reportInfo;
        window.$['reportErrorInfo'] = t$.reportErrorInfo;
        window.$['feedbackInfo'] = t$.feedbackInfo;
        window.$['feedbackInfoEx'] = t$.feedbackInfoEx;

        window.$ = window.$.extend(window.$, t$);
      }
    } catch (error) {
      // console.warn(error)
    }
  }

  var communication = uu$$1;
  autoForJquery$1(uu$$1);

  /*eslint-disable*/

  /* Copyright 2012 Mozilla Foundation
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  (function compatibilityWrapper() {
    'use strict';

    var userAgent = navigator.userAgent;

    var isAndroid = /Android/.test(userAgent);
    var isAndroidPre3 = /Android\s[0-2][^\d]/.test(userAgent);
    var isAndroidPre5 = /Android\s[0-4][^\d]/.test(userAgent);
    var isChrome = userAgent.indexOf('Chrom') >= 0;
    var isChromeWithRangeBug = /Chrome\/(39|40)\./.test(userAgent);
    var isIE = userAgent.indexOf('Trident') >= 0;
    var isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent);
    var isOpera = userAgent.indexOf('Opera') >= 0;
    var isSafari = /Safari\//.test(userAgent) && !/(Chrome\/|Android\s)/.test(userAgent);

    // Initializing RTYCompatibilityWrapper global object here, it case if we need to change/disable
    // some PDF.js features, e.g. range requests
    if (typeof RTYCompatibilityWrapper === 'undefined') {
      (typeof window !== 'undefined' ? window : this).RTYCompatibilityWrapper = {};
    }

    // Checking if the typed arrays are supported
    // Support: iOS<6.0 (subarray), IE<10, Android<4.0
    (function checkTypedArrayCompatibility() {
      if (typeof Uint8Array !== 'undefined') {
        // Support: iOS<6.0
        if (typeof Uint8Array.prototype.subarray === 'undefined') {
          Uint8Array.prototype.subarray = function subarray(start, end) {
            return new Uint8Array(this.slice(start, end));
          };
          Float32Array.prototype.subarray = function subarray(start, end) {
            return new Float32Array(this.slice(start, end));
          };
        }

        // Support: Android<4.1
        if (typeof Float64Array === 'undefined') {
          window.Float64Array = Float32Array;
        }
        return;
      }

      function subarray(start, end) {
        return new TypedArray(this.slice(start, end));
      }

      function setArrayOffset(array, offset) {
        var this$1 = this;

        if (arguments.length < 2) {
          offset = 0;
        }
        for (var i = 0, n = array.length; i < n; ++i, ++offset) {
          this$1[offset] = array[i] & 0xFF;
        }
      }

      function TypedArray(arg1) {
        var result, i, n;
        if (typeof arg1 === 'number') {
          result = [];
          for (i = 0; i < arg1; ++i) {
            result[i] = 0;
          }
        } else if ('slice' in arg1) {
          result = arg1.slice(0);
        } else {
          result = [];
          for (i = 0, n = arg1.length; i < n; ++i) {
            result[i] = arg1[i];
          }
        }

        result.subarray = subarray;
        result.buffer = result;
        result.byteLength = result.length;
        result.set = setArrayOffset;

        if ((typeof arg1 === 'undefined' ? 'undefined' : _typeof(arg1)) === 'object' && arg1.buffer) {
          result.buffer = arg1.buffer;
        }
        return result;
      }

      window.Uint8Array = TypedArray;
      window.Int8Array = TypedArray;

      // we don't need support for set, byteLength for 32-bit array
      // so we can use the TypedArray as well
      window.Uint32Array = TypedArray;
      window.Int32Array = TypedArray;
      window.Uint16Array = TypedArray;
      window.Float32Array = TypedArray;
      window.Float64Array = TypedArray;
    })();

    // URL = URL || webkitURL
    // Support: Safari<7, Android 4.2+
    (function normalizeURLObject() {
      if (!window.URL) {
        window.URL = window.webkitURL;
      }
    })();

    // Object.defineProperty()?
    // Support: Android<4.0, Safari<5.1
    (function checkObjectDefinePropertyCompatibility() {
      if (typeof Object.defineProperty !== 'undefined') {
        var definePropertyPossible = true;
        try {
          // some browsers (e.g. safari) cannot use defineProperty() on DOM objects
          // and thus the native version is not sufficient
          Object.defineProperty(new Image(), 'id', { value: 'test' });
          // ... another test for android gb browser for non-DOM objects
          var Test = function Test() {};
          Test.prototype = { get id() {} };
          Object.defineProperty(new Test(), 'id', { value: '', configurable: true, enumerable: true, writable: false });
        } catch (e) {
          definePropertyPossible = false;
        }
        if (definePropertyPossible) {
          return;
        }
      }

      Object.defineProperty = function objectDefineProperty(obj, name, def) {
        delete obj[name];
        if ('get' in def) {
          obj.__defineGetter__(name, def['get']);
        }
        if ('set' in def) {
          obj.__defineSetter__(name, def['set']);
        }
        if ('value' in def) {
          obj.__defineSetter__(name, function objectDefinePropertySetter(value) {
            this.__defineGetter__(name, function objectDefinePropertyGetter() {
              return value;
            });
            return value;
          });
          obj[name] = def.value;
        }
      };
    })();

    // No XMLHttpRequest#response?
    // Support: IE<11, Android <4.0
    (function checkXMLHttpRequestResponseCompatibility() {
      var xhrPrototype = XMLHttpRequest.prototype;
      var xhr = new XMLHttpRequest();
      if (!('overrideMimeType' in xhr)) {
        // IE10 might have response, but not overrideMimeType
        // Support: IE10
        Object.defineProperty(xhrPrototype, 'overrideMimeType', {
          value: function xmlHttpRequestOverrideMimeType(mimeType) {}
        });
      }
      if ('responseType' in xhr) {
        return;
      }

      // The worker will be using XHR, so we can save time and disable worker.
      RTYCompatibilityWrapper.disableWorker = true;

      Object.defineProperty(xhrPrototype, 'responseType', {
        get: function xmlHttpRequestGetResponseType() {
          return this._responseType || 'text';
        },
        set: function xmlHttpRequestSetResponseType(value) {
          if (value === 'text' || value === 'arraybuffer') {
            this._responseType = value;
            if (value === 'arraybuffer' && typeof this.overrideMimeType === 'function') {
              this.overrideMimeType('text/plain; charset=x-user-defined');
            }
          }
        }
      });

      // Support: IE9
      if (typeof VBArray !== 'undefined') {
        Object.defineProperty(xhrPrototype, 'response', {
          get: function xmlHttpRequestResponseGet() {
            if (this.responseType === 'arraybuffer') {
              return new Uint8Array(new VBArray(this.responseBody).toArray());
            }
            return this.responseText;
          }
        });
        return;
      }

      Object.defineProperty(xhrPrototype, 'response', {
        get: function xmlHttpRequestResponseGet() {
          if (this.responseType !== 'arraybuffer') {
            return this.responseText;
          }
          var text = this.responseText;
          var i,
              n = text.length;
          var result = new Uint8Array(n);
          for (i = 0; i < n; ++i) {
            result[i] = text.charCodeAt(i) & 0xFF;
          }
          return result.buffer;
        }
      });
    })();

    // window.btoa (base64 encode function) ?
    // Support: IE<10
    (function checkWindowBtoaCompatibility() {
      if ('btoa' in window) {
        return;
      }

      var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

      window.btoa = function windowBtoa(chars) {
        var buffer = '';
        var i, n;
        for (i = 0, n = chars.length; i < n; i += 3) {
          var b1 = chars.charCodeAt(i) & 0xFF;
          var b2 = chars.charCodeAt(i + 1) & 0xFF;
          var b3 = chars.charCodeAt(i + 2) & 0xFF;
          var d1 = b1 >> 2,
              d2 = (b1 & 3) << 4 | b2 >> 4;
          var d3 = i + 1 < n ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
          var d4 = i + 2 < n ? b3 & 0x3F : 64;
          buffer += digits.charAt(d1) + digits.charAt(d2) + digits.charAt(d3) + digits.charAt(d4);
        }
        return buffer;
      };
    })();

    // window.atob (base64 encode function)?
    // Support: IE<10
    (function checkWindowAtobCompatibility() {
      if ('atob' in window) {
        return;
      }

      // https://github.com/davidchambers/Base64.js
      var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
      window.atob = function (input) {
        input = input.replace(/=+$/, '');
        if (input.length % 4 === 1) {
          throw new Error('bad atob input');
        }
        for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = input.charAt(idx++);
        // character found in table?
        // initialize bit storage and add its ascii value
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
          // try to find character in table (0-63, not found => -1)
          buffer = digits.indexOf(buffer);
        }
        return output;
      };
    })();

    // Function.prototype.bind?
    // Support: Android<4.0, iOS<6.0
    (function checkFunctionPrototypeBindCompatibility() {
      if (typeof Function.prototype.bind !== 'undefined') {
        return;
      }

      Function.prototype.bind = function functionPrototypeBind(obj) {
        var fn = this,
            headArgs = Array.prototype.slice.call(arguments, 1);
        var bound = function functionPrototypeBindBound() {
          var args = headArgs.concat(Array.prototype.slice.call(arguments));
          return fn.apply(obj, args);
        };
        return bound;
      };
    })();

    // HTMLElement dataset property
    // Support: IE<11, Safari<5.1, Android<4.0
    (function checkDatasetProperty() {
      var div = document.createElement('div');
      if ('dataset' in div) {
        return; // dataset property exists
      }

      Object.defineProperty(HTMLElement.prototype, 'dataset', {
        get: function get() {
          var this$1 = this;

          if (this._dataset) {
            return this._dataset;
          }

          var dataset = {};
          for (var j = 0, jj = this.attributes.length; j < jj; j++) {
            var attribute = this$1.attributes[j];
            if (attribute.name.substring(0, 5) !== 'data-') {
              continue;
            }
            var key = attribute.name.substring(5).replace(/\-([a-z])/g, function (all, ch) {
              return ch.toUpperCase();
            });
            dataset[key] = attribute.value;
          }

          Object.defineProperty(this, '_dataset', {
            value: dataset,
            writable: false,
            enumerable: false
          });
          return dataset;
        },
        enumerable: true
      });
    })();

    // HTMLElement classList property
    // Support: IE<10, Android<4.0, iOS<5.0
    (function checkClassListProperty() {
      var div = document.createElement('div');
      if ('classList' in div) {
        return; // classList property exists
      }

      function changeList(element, itemName, add, remove) {
        var s = element.className || '';
        var list = s.split(/\s+/g);
        if (list[0] === '') {
          list.shift();
        }
        var index = list.indexOf(itemName);
        if (index < 0 && add) {
          list.push(itemName);
        }
        if (index >= 0 && remove) {
          list.splice(index, 1);
        }
        element.className = list.join(' ');
        return index >= 0;
      }

      var classListPrototype = {
        add: function add(name) {
          changeList(this.element, name, true, false);
        },
        contains: function contains(name) {
          return changeList(this.element, name, false, false);
        },
        remove: function remove(name) {
          changeList(this.element, name, false, true);
        },
        toggle: function toggle(name) {
          changeList(this.element, name, true, true);
        }
      };

      Object.defineProperty(HTMLElement.prototype, 'classList', {
        get: function get() {
          if (this._classList) {
            return this._classList;
          }

          var classList = Object.create(classListPrototype, {
            element: {
              value: this,
              writable: false,
              enumerable: true
            }
          });
          Object.defineProperty(this, '_classList', {
            value: classList,
            writable: false,
            enumerable: false
          });
          return classList;
        },
        enumerable: true
      });
    })();

    // Check console compatibility
    // In older IE versions the console object is not available
    // unless console is open.
    // Support: IE<10
    (function checkConsoleCompatibility() {
      if (!('console' in window)) {
        window.console = {
          log: function log() {},
          error: function error() {},
          warn: function warn() {}
        };
      } else if (!('bind' in console.log)) {
        // native functions in IE9 might not have bind
        console.log = function (fn) {
          return function (msg) {
            return fn(msg);
          };
        }(console.log);
        console.error = function (fn) {
          return function (msg) {
            return fn(msg);
          };
        }(console.error);
        console.warn = function (fn) {
          return function (msg) {
            return fn(msg);
          };
        }(console.warn);
      }
    })();

    // Check onclick compatibility in Opera
    // Support: Opera<15
    (function checkOnClickCompatibility() {
      // workaround for reported Opera bug DSK-354448:
      // onclick fires on disabled buttons with opaque content
      function ignoreIfTargetDisabled(event) {
        if (isDisabled(event.target)) {
          event.stopPropagation();
        }
      }
      function isDisabled(node) {
        return node.disabled || node.parentNode && isDisabled(node.parentNode);
      }
      if (isOpera) {
        // use browser detection since we cannot feature-check this bug
        document.addEventListener('click', ignoreIfTargetDisabled, true);
      }
    })();

    // Checks if possible to use URL.createObjectURL()
    // Support: IE
    (function checkOnBlobSupport() {
      // sometimes IE loosing the data created with createObjectURL(), see #3977
      if (isIE) {
        RTYCompatibilityWrapper.disableCreateObjectURL = true;
      }
    })();

    // Checks if navigator.language is supported
    (function checkNavigatorLanguage() {
      if ('language' in navigator) {
        return;
      }
      RTYCompatibilityWrapper.locale = navigator.userLanguage || 'en-US';
    })();

    // Support: Safari 6.0+, Android<3.0, Chrome 39/40, iOS
    (function checkRangeRequests() {
      // Safari has issues with cached range requests see:
      // https://github.com/mozilla/pdf.js/issues/3260
      // Last tested with version 6.0.4.

      // Older versions of Android (pre 3.0) has issues with range requests, see:
      // https://github.com/mozilla/pdf.js/issues/3381.
      // Make sure that we only match webkit-based Android browsers,
      // since Firefox/Fennec works as expected.

      // Range requests are broken in Chrome 39 and 40, https://crbug.com/442318
      if (isSafari || isAndroidPre3 || isChromeWithRangeBug || isIOS) {
        RTYCompatibilityWrapper.disableRange = true;
        RTYCompatibilityWrapper.disableStream = true;
      }
    })();

    // Check if the browser supports manipulation of the history.
    // Support: IE<10, Android<4.2
    (function checkHistoryManipulation() {
      // Android 2.x has so buggy pushState support that it was removed in
      // Android 3.0 and restored as late as in Android 4.2.
      // Support: Android 2.x
      if (!history.pushState || isAndroidPre3) {
        RTYCompatibilityWrapper.disableHistory = true;
      }
    })();

    // Support: IE<11, Chrome<21, Android<4.4, Safari<6
    (function checkSetPresenceInImageData() {
      // IE < 11 will use window.CanvasPixelArray which lacks set function.
      if (window.CanvasPixelArray) {
        if (typeof window.CanvasPixelArray.prototype.set !== 'function') {
          window.CanvasPixelArray.prototype.set = function (arr) {
            var this$1 = this;

            for (var i = 0, ii = this.length; i < ii; i++) {
              this$1[i] = arr[i];
            }
          };
        }
      } else {
        // Old Chrome and Android use an inaccessible CanvasPixelArray prototype.
        // Because we cannot feature detect it, we rely on user agent parsing.
        var polyfill = false,
            versionMatch;
        if (isChrome) {
          versionMatch = userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
          // Chrome < 21 lacks the set function.
          polyfill = versionMatch && parseInt(versionMatch[2]) < 21;
        } else if (isAndroid) {
          // Android < 4.4 lacks the set function.
          // Android >= 4.4 will contain Chrome in the user agent,
          // thus pass the Chrome check above and not reach this block.
          polyfill = isAndroidPre5;
        } else if (isSafari) {
          versionMatch = userAgent.match(/Version\/([0-9]+)\.([0-9]+)\.([0-9]+) Safari\//);
          // Safari < 6 lacks the set function.
          polyfill = versionMatch && parseInt(versionMatch[1]) < 6;
        }

        if (polyfill) {
          var contextPrototype = window.CanvasRenderingContext2D.prototype;
          var createImageData = contextPrototype.createImageData;
          contextPrototype.createImageData = function (w, h) {
            var imageData = createImageData.call(this, w, h);
            imageData.data.set = function (arr) {
              var this$1 = this;

              for (var i = 0, ii = this.length; i < ii; i++) {
                this$1[i] = arr[i];
              }
            };
            return imageData;
          };
          // this closure will be kept referenced, so clear its vars
          contextPrototype = null;
        }
      }
    })();

    // Support: IE<10, Android<4.0, iOS
    (function checkRequestAnimationFrame() {
      function fakeRequestAnimationFrame(callback) {
        window.setTimeout(callback, 20);
      }

      if (isIOS) {
        // requestAnimationFrame on iOS is broken, replacing with fake one.
        window.requestAnimationFrame = fakeRequestAnimationFrame;
        return;
      }
      if ('requestAnimationFrame' in window) {
        return;
      }
      window.requestAnimationFrame = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || fakeRequestAnimationFrame;
    })();

    // Support: Android, iOS
    (function checkCanvasSizeLimitation() {
      if (isIOS || isAndroid) {
        // 5MP
        RTYCompatibilityWrapper.maxCanvasPixels = 5242880;
      }
    })();

    // Disable fullscreen support for certain problematic configurations.
    // Support: IE11+ (when embedded).
    (function checkFullscreenSupport() {
      if (isIE && window.parent !== window) {
        RTYCompatibilityWrapper.disableFullscreen = true;
      }
    })();

    // Provides document.currentScript support
    // Support: IE, Chrome<29.
    (function checkCurrentScript() {
      if ('currentScript' in document) {
        return;
      }
      Object.defineProperty(document, 'currentScript', {
        get: function get() {
          var scripts = document.getElementsByTagName('script');
          return scripts[scripts.length - 1];
        },
        enumerable: true,
        configurable: true
      });
    })();

    // Provides `input.type = 'type'` runtime failure protection.
    // Support: IE9,10.
    (function checkInputTypeNumberAssign() {
      var el = document.createElement('input');
      try {
        el.type = 'number';
      } catch (ex) {
        var inputProto = el.constructor.prototype;
        var typeProperty = Object.getOwnPropertyDescriptor(inputProto, 'type');
        Object.defineProperty(inputProto, 'type', {
          get: function get() {
            return typeProperty.get.call(this);
          },
          set: function set(value) {
            typeProperty.set.call(this, value === 'number' ? 'text' : value);
          },
          enumerable: true,
          configurable: true
        });
      }
    })();

    // Provides correct document.readyState value for legacy browsers.
    // Support: IE9,10.
    (function checkDocumentReadyState() {
      if (!document.attachEvent) {
        return;
      }
      var documentProto = document.constructor.prototype;
      var readyStateProto = Object.getOwnPropertyDescriptor(documentProto, 'readyState');
      Object.defineProperty(documentProto, 'readyState', {
        get: function get() {
          var value = readyStateProto.get.call(this);
          return value === 'interactive' ? 'loading' : value;
        },
        set: function set(value) {
          readyStateProto.set.call(this, value);
        },
        enumerable: true,
        configurable: true
      });
    })();
  }).call(window);

  /// Polyfill
  (function checkArrayPolyFill() {
    if (!Array.from) {
      Array.from = function () {
        var toStr = Object.prototype.toString;
        var isCallable = function isCallable(fn) {
          return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
        };
        var toInteger = function toInteger(value) {
          var number = Number(value);
          if (isNaN(number)) {
            return 0;
          }
          if (number === 0 || !isFinite(number)) {
            return number;
          }
          return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
        };
        var maxSafeInteger = Math.pow(2, 53) - 1;
        var toLength = function toLength(value) {
          var len = toInteger(value);
          return Math.min(Math.max(len, 0), maxSafeInteger);
        };

        // The length property of the from method is 1.
        return function from(arrayLike /*, mapFn, thisArg */) {
          // 1. Let C be the this value.
          var C = this;

          // 2. Let items be ToObject(arrayLike).
          var items = Object(arrayLike);

          // 3. ReturnIfAbrupt(items).
          if (arrayLike == null) {
            throw new TypeError("Array.from requires an array-like object - not null or undefined");
          }

          // 4. If mapfn is undefined, then let mapping be false.
          var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
          var T;
          if (typeof mapFn !== 'undefined') {
            // 5. else
            // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
            if (!isCallable(mapFn)) {
              throw new TypeError('Array.from: when provided, the second argument must be a function');
            }

            // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
            if (arguments.length > 2) {
              T = arguments[2];
            }
          }

          // 10. Let lenValue be Get(items, "length").
          // 11. Let len be ToLength(lenValue).
          var len = toLength(items.length);

          // 13. If IsConstructor(C) is true, then
          // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.
          // 14. a. Else, Let A be ArrayCreate(len).
          var A = isCallable(C) ? Object(new C(len)) : new Array(len);

          // 16. Let k be 0.
          var k = 0;
          // 17. Repeat, while k < len (also steps a - h)
          var kValue;
          while (k < len) {
            kValue = items[k];
            if (mapFn) {
              A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
            } else {
              A[k] = kValue;
            }
            k += 1;
          }
          // 18. Let putStatus be Put(A, "length", len, true).
          A.length = len;
          // 20. Return A.
          return A;
        };
      }();
    }

    if (!Array.prototype.findIndex) {
      Array.prototype.findIndex = function (predicate) {
        if (this === null) {
          throw new TypeError('Array.prototype.findIndex called on null or undefined');
        }
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return i;
          }
        }
        return -1;
      };
    }
  })();

  var compatibilityWrapper = {};

  /**
   * Google Lang maps
   */
  var uu$$3 = {
    googleLangIDMaps: {
      'af': {
        englishName: 'Afrikaans',
        localName: 'Afrikaans',
        zhName: '',
        compatible: ['af', 'af-AF', 'af_af'],
        compatibleForKendoUI: {
          culture: 'af',
          message: ''
        }
      },
      'sq': {
        englishName: 'Albanian',
        localName: 'Shqiptar',
        zhName: '',
        compatible: ['sq', 'sq-SQ', 'sq_sq'],
        compatibleForKendoUI: {
          culture: 'sq',
          message: ''
        }
      },
      'ar': {
        englishName: 'Arabic',
        localName: '',
        zhName: '',
        compatible: ['ar', 'ar-AR', 'ar_ar'],
        compatibleForKendoUI: {
          culture: 'ar',
          message: ''
        }
      },
      'hy': {
        englishName: 'Armenian',
        localName: '',
        zhName: '',
        compatible: ['hy', 'hy-HY', 'hy_HY'],
        compatibleForKendoUI: {
          culture: 'hy',
          message: 'hy-AM'
        }
      },
      'az': {
        englishName: 'Azerbaijani',
        localName: 'Azrbaycan',
        zhName: '',
        compatible: ['az', 'az-AZ', 'az_AZ'],
        compatibleForKendoUI: {
          culture: 'az',
          message: ''
        }
      },
      'eu': {
        englishName: 'Basque',
        localName: 'Euskal',
        zhName: '',
        compatible: ['eu', 'eu-EU', 'en_EU'],
        compatibleForKendoUI: {
          culture: 'eu',
          message: ''
        }
      },
      'be': {
        englishName: 'Belarusian',
        localName: '',
        zhName: '',
        compatible: ['be', 'be-BE', 'be_BE'],
        compatibleForKendoUI: {
          culture: 'be',
          message: ''
        }
      },
      'bn': {
        englishName: 'Bengali',
        localName: '',
        zhName: '',
        compatible: ['bn', 'bn-BN', 'bn_BN'],
        compatibleForKendoUI: {
          culture: 'bn',
          message: ''
        }
      },
      'bs': {
        englishName: 'Bosnian',
        localName: 'Bosanski',
        zhName: '',
        compatible: ['bs', 'bs-BS', 'bs_BS'],
        compatibleForKendoUI: {
          culture: 'bs',
          message: ''
        }
      },
      'bg': {
        englishName: 'Bulgarian',
        localName: '',
        zhName: '',
        compatible: ['bg', 'bg-BG', 'bg_BG'],
        compatibleForKendoUI: {
          culture: 'bg',
          message: 'bg-BG'
        }
      },
      'ca': {
        englishName: 'Catalan',
        localName: 'Catal',
        zhName: '',
        compatible: ['ca', 'ca-ES', 'ca-es'],
        compatibleForKendoUI: {
          culture: 'ca',
          message: ''
        }
      },
      'ceb': {
        englishName: 'Cebuano',
        localName: 'Cebuano',
        zhName: '',
        compatible: ['ceb'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'ny': {
        englishName: 'Chichewa',
        localName: 'Chichewa',
        zhName: '',
        compatible: ['ny', 'ny-NY', 'ny_NY'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'zh-CN': {
        englishName: 'Chinese Simplified',
        localName: '',
        zhName: '',
        compatible: ['zh', 'zh-CN', 'zh_cn', 'zh-Hans'],
        compatibleForKendoUI: {
          culture: 'zh-CN',
          message: 'zh-CN'
        }
      },
      'zh-TW': {
        englishName: 'Chinese Traditional',
        localName: '',
        zhName: '',
        compatible: ['zh-TW', 'zh_tw', 'zh-Hant'],
        compatibleForKendoUI: {
          culture: 'zh-TW',
          message: 'zh-TW'
        }
      },
      'hr': {
        englishName: 'Croatian',
        localName: 'Hrvatski',
        zhName: '',
        compatible: ['hr', 'hr-HR', 'hr_hr'],
        compatibleForKendoUI: {
          culture: 'hr',
          message: ''
        }
      },
      'cs': {
        englishName: 'Czech',
        localName: 'etina',
        zhName: '',
        compatible: ['cs', 'cs-CZ', 'cs_cz'],
        compatibleForKendoUI: {
          culture: 'cs',
          message: 'cs-CZ'
        }
      },
      'da': {
        englishName: 'Danish',
        localName: 'Dansk',
        zhName: '',
        compatible: ['da', 'da-DK', 'da-da', 'da_da'],
        compatibleForKendoUI: {
          culture: 'da',
          message: 'da-DK'
        }
      },
      'nl': {
        englishName: 'Dutch',
        localName: 'Nederlands',
        zhName: '',
        compatible: ['nl', 'nl-NL', 'nl_nl'],
        compatibleForKendoUI: {
          culture: 'nl',
          message: 'nl-NL'
        }
      },
      'en': {
        englishName: 'English',
        localName: 'English',
        zhName: '',
        compatible: ['en', 'en-US', 'en_us'],
        compatibleForKendoUI: {
          culture: 'en-US',
          message: 'en-US'
        }
      },
      'eo': {
        englishName: 'Esperanto',
        localName: 'Esperanto',
        zhName: '',
        compatible: ['eo', 'eo-EO', 'eo_eo'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'et': {
        englishName: 'Estonian',
        localName: 'Eesti',
        zhName: '',
        compatible: ['et', 'et-ET', 'et_ET'],
        compatibleForKendoUI: {
          culture: 'et',
          message: ''
        }
      },
      'tl': {
        englishName: 'Filipino',
        localName: 'Pilipino',
        zhName: '',
        compatible: ['tl', 'tl-TL', 'tl_TL'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'fi': {
        englishName: 'Finnish',
        localName: 'Suomi',
        zhName: '',
        compatible: ['fi', 'fi-FI', 'fi_fi'],
        compatibleForKendoUI: {
          culture: 'fi',
          message: 'fi-FI'
        }
      },
      'fr': {
        englishName: 'French',
        localName: 'Franais',
        zhName: '',
        compatible: ['fr', 'fr-FR', 'fr_fr'],
        compatibleForKendoUI: {
          culture: 'fr',
          message: 'fr-FR'
        }
      },
      'gl': {
        englishName: 'Galician',
        localName: 'Galega',
        zhName: '',
        compatible: ['gl', 'gl-GL', 'gl_GL'],
        compatibleForKendoUI: {
          culture: 'gl',
          message: ''
        }
      },
      'ka': {
        englishName: 'Georgian',
        localName: '',
        zhName: '',
        compatible: ['ka', 'ka-kA', 'ka_ka'],
        compatibleForKendoUI: {
          culture: 'ka',
          message: ''
        }
      },
      'de': {
        englishName: 'German',
        localName: 'Deutsch',
        zhName: '',
        compatible: ['de', 'de-DE', 'de_de'],
        compatibleForKendoUI: {
          culture: 'de',
          message: 'de-DE'
        }
      },
      'el': {
        englishName: 'Greek',
        localName: '',
        zhName: '',
        compatible: ['el', 'el-GR', 'el_gr'],
        compatibleForKendoUI: {
          culture: 'el',
          message: ''
        }
      },
      'gu': {
        englishName: 'Gujarati',
        localName: '',
        zhName: '',
        compatible: ['gu', 'gu-GU', 'gu_gu'],
        compatibleForKendoUI: {
          culture: 'gu',
          message: ''
        }
      },
      'ht': {
        englishName: 'Haitian Creole',
        localName: 'Kreyl ayisyen',
        zhName: '',
        compatible: ['ht', 'ht-HT', 'ht_ht'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'ha': {
        englishName: 'Hausa',
        localName: 'Hausa',
        zhName: '',
        compatible: ['ha', 'ha-HA', 'ha_ha'],
        compatibleForKendoUI: {
          culture: 'ha',
          message: ''
        }
      },
      'iw': {
        englishName: 'Hebrew',
        localName: '',
        zhName: '',
        compatible: ['iw', 'iw-IW', 'iw_iw', 'he', 'he-IL', 'he-il'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'hi': {
        englishName: 'Hindi',
        localName: '',
        zhName: '',
        compatible: ['hi', 'hi-HI', 'hi_hi'],
        compatibleForKendoUI: {
          culture: 'hi',
          message: ''
        }
      },
      'hmn': {
        englishName: 'Hmong',
        localName: 'Hmoob',
        zhName: '',
        compatible: ['hmn'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'hu': {
        englishName: 'Hungarian',
        localName: 'Magyar',
        zhName: '',
        compatible: ['hu', 'hu-HU', 'hu_hu'],
        compatibleForKendoUI: {
          culture: 'hu',
          message: ''
        }
      },
      'is': {
        englishName: 'Icelandic',
        localName: 'Icelandic',
        zhName: '',
        compatible: ['is', 'is-IS', 'is_is'],
        compatibleForKendoUI: {
          culture: 'is',
          message: ''
        }
      },
      'ig': {
        englishName: 'Igbo',
        localName: 'Igbo',
        zhName: '',
        compatible: ['ig', 'ig-IG', 'ig_ig'],
        compatibleForKendoUI: {
          culture: 'ig',
          message: ''
        }
      },
      'id': {
        englishName: 'Indonesian',
        localName: 'Indonesia',
        zhName: '',
        compatible: ['id', 'id-ID', 'id_id'],
        compatibleForKendoUI: {
          culture: 'id',
          message: ''
        }
      },
      'ga': {
        englishName: 'Irish',
        localName: 'Gaeilge',
        zhName: '',
        compatible: ['ga', 'ga-GA', 'ga_ga'],
        compatibleForKendoUI: {
          culture: 'ga',
          message: ''
        }
      },
      'it': {
        englishName: 'Italian',
        localName: 'Italiano',
        zhName: '',
        compatible: ['it', 'it-IT', 'it_it'],
        compatibleForKendoUI: {
          culture: 'it',
          message: 'it-IT'
        }
      },
      'ja': {
        englishName: 'Japanese',
        localName: '',
        zhName: '',
        compatible: ['ja', 'ja-JP', 'ja_jp'],
        compatibleForKendoUI: {
          culture: 'ja-JP',
          message: 'ja-JP'
        }
      },
      'jw': {
        englishName: 'Javanese',
        localName: 'Jawa',
        zhName: '',
        compatible: ['jw', 'jw-JW', 'jw_jw'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'kn': {
        englishName: 'Kannada',
        localName: '',
        zhName: '',
        compatible: ['kn', 'kn-KN', 'kn_kn'],
        compatibleForKendoUI: {
          culture: 'kn',
          message: ''
        }
      },
      'kk': {
        englishName: 'Kazakh',
        localName: '',
        zhName: '',
        compatible: ['kk', 'kk-KK', 'kk_kk'],
        compatibleForKendoUI: {
          culture: 'kk',
          message: ''
        }
      },
      'km': {
        englishName: 'Khmer',
        localName: '',
        zhName: '',
        compatible: ['km', 'km-KM', 'km_km'],
        compatibleForKendoUI: {
          culture: 'km',
          message: ''
        }
      },
      'ko': {
        englishName: 'Korean',
        localName: '',
        zhName: '',
        compatible: ['ko', 'ko-KR', 'ko_kr'],
        compatibleForKendoUI: {
          culture: 'ko',
          message: ''
        }
      },
      'lo': {
        englishName: 'Lao',
        localName: '',
        zhName: '',
        compatible: ['lo', 'lo-LO', 'lo_lo'],
        compatibleForKendoUI: {
          culture: 'lo',
          message: ''
        }
      },
      'la': {
        englishName: 'Latin',
        localName: 'Latine',
        zhName: '',
        compatible: ['la', 'la-LA', 'la_la'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'lv': {
        englishName: 'Latvian',
        localName: 'Latvijas',
        zhName: '',
        compatible: ['lv', 'lv-LV', 'lv_lv'],
        compatibleForKendoUI: {
          culture: 'lv',
          message: ''
        }
      },
      'lt': {
        englishName: 'Lithuanian',
        localName: 'Lietuvos',
        zhName: '',
        compatible: ['lt', 'lt-LT', 'lt_lt'],
        compatibleForKendoUI: {
          culture: 'lt',
          message: ''
        }
      },
      'mk': {
        englishName: 'Macedonian',
        localName: '',
        zhName: '',
        compatible: ['mk', 'mk-MK', 'mk_mk'],
        compatibleForKendoUI: {
          culture: 'mk',
          message: ''
        }
      },
      'mg': {
        englishName: 'Malagasy',
        localName: 'Malagasy',
        zhName: '',
        compatible: ['mg', 'mg-MG', 'mg_mg'],
        compatibleForKendoUI: {
          culture: 'mg',
          message: ''
        }
      },
      'ms': {
        englishName: 'Malay',
        localName: 'Melayu',
        zhName: '',
        compatible: ['ms', 'ms-MS', 'ms_ms'],
        compatibleForKendoUI: {
          culture: 'ms',
          message: ''
        }
      },
      'ml': {
        englishName: 'Malayalam',
        localName: '',
        zhName: '',
        compatible: ['ml', 'ml-ML', 'ml_ml'],
        compatibleForKendoUI: {
          culture: 'ml',
          message: ''
        }
      },
      'mt': {
        englishName: 'Maltese',
        localName: 'Malti',
        zhName: '',
        compatible: ['mt', 'mt-MT', 'mt_mt'],
        compatibleForKendoUI: {
          culture: 'mt',
          message: ''
        }
      },
      'mi': {
        englishName: 'Maori',
        localName: 'Maori',
        zhName: '',
        compatible: ['mi', 'mi-MI', 'mi_mi'],
        compatibleForKendoUI: {
          culture: 'mi',
          message: ''
        }
      },
      'mr': {
        englishName: 'Marathi',
        localName: '',
        zhName: '',
        compatible: ['mr', 'mr-MR', 'mr_mr', 'mr-IN'],
        compatibleForKendoUI: {
          culture: 'mr',
          message: ''
        }
      },
      'mn': {
        englishName: 'Mongolian',
        localName: '',
        zhName: '',
        compatible: ['mn', 'mn-MN', 'mn_mn'],
        compatibleForKendoUI: {
          culture: 'mn',
          message: ''
        }
      },
      'my': {
        englishName: 'Myanmar (Burmese)',
        localName: ' ()',
        zhName: '',
        compatible: ['my', 'my-MY', 'my_my'],
        compatibleForKendoUI: {
          culture: 'my',
          message: ''
        }
      },
      'ne': {
        englishName: 'Nepali',
        localName: '',
        zhName: '',
        compatible: ['ne', 'ne-NE', 'ne_ne'],
        compatibleForKendoUI: {
          culture: 'ne',
          message: ''
        }
      },
      'no': {
        englishName: 'Norwegian',
        localName: 'Norsk',
        zhName: '',
        compatible: ['no', 'no-NO', 'no_no', 'nb', 'nb-NO', 'nb_no'],
        compatibleForKendoUI: {
          culture: 'no',
          message: ''
        }
      },
      'fa': {
        englishName: 'Persian',
        localName: '',
        zhName: '',
        compatible: ['fa', 'fa-FA', 'fa_fa'],
        compatibleForKendoUI: {
          culture: 'fa',
          message: ''
        }
      },
      'pl': {
        englishName: 'Polish',
        localName: 'Polski',
        zhName: '',
        compatible: ['pl', 'pl-PL', 'pl_pl'],
        compatibleForKendoUI: {
          culture: 'pl',
          message: 'pl-PL'
        }
      },
      'pt': {
        englishName: 'Portuguese',
        localName: 'Portugus',
        zhName: '',
        compatible: ['pt', 'pt-BR', 'pt_br', 'pt-PT', 'pt_pt'],
        compatibleForKendoUI: {
          culture: 'pt',
          message: 'pt-PT'
        }
      },
      'ma': {
        englishName: 'Punjabi',
        localName: ' ',
        zhName: '',
        compatible: ['ma', 'ma-MA', 'ma_ma'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'ro': {
        englishName: 'Romanian',
        localName: 'Romn',
        zhName: '',
        compatible: ['ro', 'ro-RO', 'ro_ro'],
        compatibleForKendoUI: {
          culture: 'ro',
          message: 'ro-RO'
        }
      },
      'ru': {
        englishName: 'Russian',
        localName: '',
        zhName: '',
        compatible: ['ru', 'ru-RU', 'ru_ru'],
        compatibleForKendoUI: {
          culture: 'ru',
          message: 'ru-RU'
        }
      },
      'sr': {
        englishName: 'Serbian',
        localName: '',
        zhName: '',
        compatible: ['sr', 'sr-SR', 'sr_sr'],
        compatibleForKendoUI: {
          culture: 'sr',
          message: ''
        }
      },
      'st': {
        englishName: 'Sesotho',
        localName: 'Sesotho',
        zhName: '',
        compatible: ['st', 'st-ST', 'st_st'],
        compatibleForKendoUI: {
          culture: 'st',
          message: ''
        }
      },
      'si': {
        englishName: 'Sinhala',
        localName: '',
        zhName: '',
        compatible: ['si', 'si-SI', 'si_si'],
        compatibleForKendoUI: {
          culture: 'si',
          message: ''
        }
      },
      'sk': {
        englishName: 'Slovak',
        localName: 'Slovensk',
        zhName: '',
        compatible: ['sk', 'sk-SK', 'sk_sk'],
        compatibleForKendoUI: {
          culture: 'sk',
          message: 'sk-SK'
        }
      },
      'sl': {
        englishName: 'Slovenian',
        localName: 'Slovenina',
        zhName: '',
        compatible: ['sl', 'sl-SL', 'sl_sl'],
        compatibleForKendoUI: {
          culture: 'sl',
          message: ''
        }
      },
      'so': {
        englishName: 'Somali',
        localName: 'Somali',
        zhName: '',
        compatible: ['so', 'so-SO', 'so_so'],
        compatibleForKendoUI: {
          culture: 'so',
          message: ''
        }
      },
      'es': {
        englishName: 'Spanish',
        localName: 'Espaol',
        zhName: '',
        compatible: ['es', 'es-ES', 'es_es', 'es-MX', 'es-XL', 'es-xl'],
        compatibleForKendoUI: {
          culture: 'es',
          message: 'es-ES'
        }
      },
      'su': {
        englishName: 'Sudanese',
        localName: 'Sudanese',
        zhName: '',
        compatible: ['su', 'su-SU', 'su_su'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'sw': {
        englishName: 'Swahili',
        localName: 'Kiswahili',
        zhName: '',
        compatible: ['sw', 'sw-SW', 'sw_sw'],
        compatibleForKendoUI: {
          culture: 'sw',
          message: ''
        }
      },
      'sv': {
        englishName: 'Swedish',
        localName: 'Svenska',
        zhName: '',
        compatible: ['sv', 'sv-SE', 'sv_se', 'sv-SV', 'sv_sv'],
        compatibleForKendoUI: {
          culture: 'sv',
          message: 'sv-SV'
        }
      },
      'tg': {
        englishName: 'Tajik',
        localName: '',
        zhName: '',
        compatible: ['tg', 'tg-TG', 'tg_tg'],
        compatibleForKendoUI: {
          culture: 'tg',
          message: ''
        }
      },
      'ta': {
        englishName: 'Tamil',
        localName: '',
        zhName: '',
        compatible: ['ta', 'ta-TA', 'ta_ta'],
        compatibleForKendoUI: {
          culture: 'ta',
          message: ''
        }
      },
      'te': {
        englishName: 'Telugu',
        localName: '',
        zhName: '',
        compatible: ['te', 'te-TE', 'te_te'],
        compatibleForKendoUI: {
          culture: 'te',
          message: ''
        }
      },
      'th': {
        englishName: 'Thai',
        localName: '',
        zhName: '',
        compatible: ['th', 'th-TH', 'th_th'],
        compatibleForKendoUI: {
          culture: 'th',
          message: ''
        }
      },
      'tr': {
        englishName: 'Turkish',
        localName: 'Trk',
        zhName: '',
        compatible: ['tr', 'tr-TR', 'tr_tr'],
        compatibleForKendoUI: {
          culture: 'tr',
          message: 'tr-TR'
        }
      },
      'uk': {
        englishName: 'Ukrainian',
        localName: '',
        zhName: '',
        compatible: ['uk', 'uk-UA', 'uk__ua', 'uk-UK', 'uk__uk'],
        compatibleForKendoUI: {
          culture: 'uk',
          message: 'uk-UA'
        }
      },
      'ur': {
        englishName: 'Urdu',
        localName: '',
        zhName: '',
        compatible: ['ur', 'ur-UR', 'ur__ur'],
        compatibleForKendoUI: {
          culture: 'ur',
          message: ''
        }
      },
      'uz': {
        englishName: 'Uzbek',
        localName: 'O\'zbekiston',
        zhName: '',
        compatible: ['uz', 'uz-UZ', 'uz__uz'],
        compatibleForKendoUI: {
          culture: 'uz',
          message: ''
        }
      },
      'vi': {
        englishName: 'Vietnamese',
        localName: 'Ting Vit',
        zhName: '',
        compatible: ['vi', 'vi-VN', 'vi-vn', 'vi-VI', 'vi_vi'],
        compatibleForKendoUI: {
          culture: 'vi',
          message: ''
        }
      },
      'cy': {
        englishName: 'Welsh',
        localName: 'Cymraeg',
        zhName: '',
        compatible: ['cy', 'cy-CY', 'cy_cy'],
        compatibleForKendoUI: {
          culture: 'cy',
          message: ''
        }
      },
      'yi': {
        englishName: 'Yiddish',
        localName: '',
        zhName: '',
        compatible: ['yi', 'yi-YI', 'yi_yi'],
        compatibleForKendoUI: {
          culture: '',
          message: ''
        }
      },
      'yo': {
        englishName: 'Yoruba',
        localName: 'Yoruba',
        zhName: '',
        compatible: ['yo', 'yo-YO', 'yo_yo'],
        compatibleForKendoUI: {
          culture: 'yo',
          message: ''
        }
      },
      'zu': {
        englishName: 'Zulu',
        localName: 'Zulu',
        zhName: '',
        compatible: ['zu', 'zu-ZU', 'zu_zu'],
        compatibleForKendoUI: {
          culture: 'zu',
          message: ''
        }
      }
    },
    getGoogleLangID: function getGoogleLangID(langKey) {
      var foundLangID = null;
      var obj = this.googleLangIDMaps;
      var fn = function fn(value, key) {
        var compatibleList = value['compatible'];
        compatibleList.forEach(function (value, index, compatibleList) {
          if (value.toLowerCase() === langKey.toLowerCase()) {
            foundLangID = key;
            return false;
          }
        });
      };

      Object.keys(obj).forEach(function (key) {
        return fn(obj[key], key);
      });
      return foundLangID;
    }
  };

  /**
   * JQuery, 
   */
  function autoForJquery$3(ref) {
    var t$ = ref;
    try {
      if (window.jQuery && window.$) {
        window.$.RTYUtils = window.$.extend(window.$.RTYUtils, uu$$3);
        window.$ = window.$.extend(window.$, t$);
      }
    } catch (error) {
      console.warn(error);
    }
  }

  var googleLangIDMaps = uu$$3;
  autoForJquery$3(uu$$3);

  /**
   * Google Lang maps
   */

  var uu$$4 = {};

  uu$$4.loadedLanguage = {
    js: [],
    json: [],

    insert: function insert(info, ext) {
      var jsonStr = JSON.stringify(info);
      var list = ext === '.js' ? this.js : this.json;
      var found = false;

      list.forEach(function (value, index, array) {
        if (JSON.stringify(value) === jsonStr) {
          found = true;
          return false;
        }
      });

      if (!found) {
        list.push(info);
      }
    }
  };

  uu$$4.loadLanguage = function (languageFilesPath, fileExt, callback, referLang, trySafeMode) {
    if (trySafeMode === void 0) trySafeMode = true;

    var t$ = this;

    // Note: Check jQuery library
    common$1.assert(!common$1.isUndefinedOrNullOrFalse(window.jQuery), 'loadLanguage function require jQuery library');
    var $ = window.jQuery || window.$ || {};

    var referLangList = common$1.param2Array(referLang, ['string']);

    /**
     * [gotoLoadLanguageFile ]
     * @param  {[array]} langsFiles             
     * @param  {[string]} ext                   ,: .josn  .js
     * @param  {[function]} successCallback     
     * @return {[type]}                         null
     */
    function gotoLoadLanguageFile(langsFiles, ext, successCallback) {
      /**
       * [_tryLoad ]
       * @param  {[string]} file        []
       * @param  {[string]} langKey     [KEY]
       * @param  {[string]} ext         [: .josn  .js]
       * @param  {[function]} fnNext     []
       * @param  {[function]} fnCallback []
       * @return {[type]}             [description]
       */
      function _tryLoad(file, langKey, ext, fnNext, fnCallback) {
        try {
          $.ajax({
            url: file,
            dataType: ext === '.js' ? 'script' : 'json',
            success: function success(data, status) {
              console.log('[x] ' + status + ' =' + file);
              var obj = {
                data: data,
                status: status,
                info: {
                  file: file,
                  langKey: langKey,
                  langID: googleLangIDMaps.getGoogleLangID(langKey),
                  ext: ext
                }
              };

              t$.loadedLanguage.insert(obj.info, ext);
              fnCallback && fnCallback(obj);
            },
            error: function error(req, status, err) {
              console.log(err);
              try {
                throw new Error('[x]no found... continue.. = ' + file);
              } catch (error) {
                console.warn(error);
                fnNext && fnNext(fnCallback);
              }
            }
          });
        } catch (error) {
          console.error(error);
          fnNext && fnNext();
        }
      }

      /**
       * [gotoTry ]
       * @param  {[type]}   list     []
       * @param  {[type]}   ext      []
       * @param  {Function} callback []
       * @return {[type]}            [description]
       */
      function _gotoTry(list, ext, callback) {
        if (common$1.isArray(list) && list.length > 0) {
          var ele = list[0];
          _tryLoad(ele.path, ele.key, ext, function (cb) {
            var newLangFileList = list.splice(1);
            _gotoTry(newLangFileList, ext, cb);
          }, callback);
        } else {
          console.warn('[x] language list length is 0 or not a array. TYPE=' + common$1.getType(list));
        }
      }

      // Try start
      _gotoTry(langsFiles, ext, successCallback);
    }

    // 
    var curUserLanguage = null;
    var b$ = null;
    if (!common$1.isUndefinedOrNullOrFalse(window.BS)) {
      if (!common$1.isUndefinedOrNullOrFalse(window.BS.b$)) {
        b$ = window.BS.b$;
        if (!common$1.isUndefinedOrNullOrFalse(b$.App)) {
          curUserLanguage = b$.App.getUserLanguage();
        }
      }
    }

    curUserLanguage = curUserLanguage || window.navigator.language || window.navigator.browserLanguage;

    var defaultLangKeys = [];

    // 
    if (trySafeMode) {
      var _safeList = ['en-US', 'en-US'.toLowerCase(), 'en_US', 'en_US'.toLowerCase(), 'en'];

      // GoogleID
      var langID = googleLangIDMaps.getGoogleLangID(curUserLanguage);
      if (langID) {
        defaultLangKeys.push(langID);
      }

      // SafeList
      if (_safeList.findIndex(function (value, index, err) {
        return value === curUserLanguage.toLowerCase();
      }) > -1) {
        defaultLangKeys = defaultLangKeys.concat(_safeList);
      } else {
        // , 
        defaultLangKeys = defaultLangKeys.concat([curUserLanguage, curUserLanguage.toLowerCase()]);

        // "zh-CN"
        if (curUserLanguage.split('-').length >= 2) {
          defaultLangKeys = defaultLangKeys.concat([curUserLanguage.split('-')[0], curUserLanguage.split('-')[0].toLowerCase()]);
        }

        // "zh_CN"
        if (curUserLanguage.split('_').length >= 2) {
          defaultLangKeys = defaultLangKeys.concat([curUserLanguage.split('_')[0], curUserLanguage.split('_')[0].toLowerCase()]);
        }

        defaultLangKeys = defaultLangKeys.concat(_safeList);
      }

      // 
      defaultLangKeys = referLangList.concat(defaultLangKeys);
      // 
      var tryLangFileList = [];
      console.log('tryLangFileList = \n');
      defaultLangKeys.forEach(function (value, index, array) {
        tryLangFileList.push({
          key: value,
          path: languageFilesPath + value + fileExt
        });
        console.log(value);
      });

      // start load language ....
      gotoLoadLanguageFile(tryLangFileList, fileExt, callback);
    }
  };

  /**
   * JQuery, 
   */

  function autoForJquery$4(ref) {
    var t$ = ref;
    if (window.jQuery && window.$) {
      window.$ = window.$.extend(window.$, t$);
    }
  }

  var loadLanguage = uu$$4;
  autoForJquery$4(uu$$4);

  var uu$$6 = {};

  uu$$6.RTYWebHelper = {
    ua: function ua() {
      return navigator.userAgent.toLowerCase();
    },
    isOpera: function isOpera() {
      var t$ = this;
      var ua = t$.ua();
      return ua.indexOf('opera') > -1;
    },
    isChrome: function isChrome() {
      var t$ = this;
      var ua = t$.ua();
      return ua.indexOf('chrome') > -1;
    },
    isSafari: function isSafari() {
      var t$ = this;
      var ua = t$.ua();
      var isChrome = t$.isChrome();
      return !isChrome && /webkit|khtml/.test(ua);
    },
    isSafari3: function isSafari3() {
      var t$ = this;
      var ua = t$.ua();
      var isSafari = t$.isSafari();
      return isSafari && ua.indexOf('webkit/5') !== -1;
    },
    isSafariExtend: function isSafariExtend(version) {
      var t$ = this;
      var ua = t$.ua();
      var isSafari = t$.isSafari();

      /** 
       *  http://www.51.la/report/3_Client.asp?t=soft&id=2812271 
       * AppleWebKit 602.4.6,Safari 10.0
       * AppleWebKit 602.3.12,Safari 10.0
       * AppleWebKit 602.1.50,Safari 10.0
       * AppleWebKit/601.6.17    MacOSX 10.11.5
       * AppleWebKit 601.5.17
       * AppleWebKit 601.1.46,Safari 9.0
       * AppleWebKit/600.8.9     MacSOX 10.10.5
       * AppleWebKit 600.1.4,Safari 8.0
          * AppleWebKit/537.75.14   MacSOX 10.9.3
        * AppleWebKit/537.71      MacOSX 10.9
        * AppleWebKit 537.36,Safari 4.0
        * AppleWebKit/534.57      ==================== Windows, Safari Windows
        * AppleWebKit/534.55      MacSOX 10.7.3
        * AppleWebKit/534.46
        * AppleWebKit 534.34
        * AppleWebKit/537.13      MacSOX 10.6.8
        * AppleWebKit 534.30,Safari 4.0
        * AppleWebKit/534.15      MacSOX 10.6.5
        * AppleWebKit 533.1,Safari 4.0
        */
      return isSafari && ua.indexOf('webkit/' + version) !== -1; // Mac 10.10.5
    },
    isMacOS: function isMacOS() {
      var nav = navigator;
      try {
        var oscpu = nav['oscpu']; // for firefox developer editon version
        if (oscpu) {
          var lowCaseOSCPU = oscpu.toLowerCase();
          return lowCaseOSCPU.indexOf('mac') !== -1;
        }
      } catch (e) {
        console.error(e);
      }

      return false;
    },
    isWinOS: function isWinOS() {
      var nav = navigator;
      try {
        var oscpu = nav['oscpu']; // for firefox developer editon version
        if (oscpu) {
          var lowCaseOSCPU = oscpu.toLowerCase();
          return lowCaseOSCPU.indexOf('windows') !== -1;
        }
      } catch (e) {
        console.error(e);
      }

      return false;
    }
  };

  /**
   * JQuery, 
   */

  function autoForJquery$6(ref) {
    var t$ = ref;
    if (window.jQuery && window.$) {
      window.$['RTYWebHelper'] = t$.RTYWebHelper;

      window.$ = window.$.extend(window.$, t$);
    }
  }

  var webHelper = uu$$6;
  autoForJquery$6(uu$$6);

  /*globals Sys, Ajax*/

  /**
   *  CSS/JS/HTML
   *  @created 2017-2-27 17:13:09
   */

  var RTYWebHelper = webHelper.RTYWebHelper;

  var uu$$5 = {};

  // Creates a gloabl object called templateLoader with a single method "loadExtTemplate"
  uu$$5.templateLoader = function ($, host) {
    // Loads external templates from path and injects in to page DOM
    return {
      cache: [],
      // Method: loadExtTemplate
      // Params: (string) path: the relative path to a file that contains template definition(s)
      loadExtTemplate: function loadExtTemplate(path, next) {
        var t$ = this;
        // Check Cache
        if ($.inArray(path, t$.cache) > -1) {
          return next && next();
        }

        // Use jQuery Ajax to fetch the template file
        var _templateLoader = $.get(path).success(function (result) {
          if ($.inArray(path, t$.cache) === -1) {
            t$.cache.push(path);
            // On success, Add templates to DOM (assumes file only has template definitions)
            $('body').append(result);
          }
        }).error(function (result) {
          alert('Error Loading Templates -- TODO: Better Error Handling');
        });

        _templateLoader.complete(function () {
          // Publish an event that indicates when a template is done loading
          $(host).trigger('TEMPLATE_LOADED', [path]);
          next && next();
        });
      }
    };
  }(window.jQuery, document);

  uu$$5.templateLoaderAgent = function (templateFileList, successCallBack) {
    var loadedList = [];
    var list = templateFileList;

    var t$ = this;
    list.forEach(function (path, index, array) {
      t$.templateLoader.loadExtTemplate(path, function () {
        if (list.findIndex(function (value, index, err) {
          return value === path;
        }) > -1) {
          loadedList.push(path);
          if (loadedList.length === list.length) {
            successCallBack && successCallBack();
          }
        }
      });
    });
  };

  // JSCSS
  uu$$5.cssjsLoader = function ($, host) {
    // Loads external templates from path and injects in to page DOM
    return {
      cache: [],
      includePath: '',
      // Method: loadExtTemplate
      // Params: (string) path: the relative path to a file that contains template definition(s)
      load: function load(path, next) {
        var t$ = this;

        var files = typeof path === 'string' ? [path] : path;

        for (var i = 0; i < files.length; i++) {
          var name = files[i].replace(/^\s|\s$/g, '');
          var att = name.split('.');
          var ext = att[att.length - 1].toLowerCase();
          var isCSS = ext === 'css';
          var tag = isCSS ? 'link' : 'script';
          var attr = isCSS ? ' type=\'text/css\' rel=\'stylesheet\' ' : ' language=\'javascript\' type=\'text/javascript\' ';
          var link = (isCSS ? 'href' : 'src') + '=\'' + t$.includePath + name + '\'';
          if ($(tag + '[' + link + ']').length === 0) {
            if ($.inArray(path, t$.cache) === -1) {
              t$.cache.push(path);
              var content = '<' + tag + attr + link + '></' + tag + '>';
              isCSS ? $('head').append(content) : $('head').append(content);
            }
          }
        }
        next && next();
      }
    };
  }(window.jQuery, document);

  var userAgent = navigator.userAgent.toLowerCase();
  var $du = {};
  var HttpLibrary = $du.HttpLibrary = {
    browser: {
      version: (userAgent.match(/.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/) || [])[1],
      safari: RTYWebHelper.isSafari(),
      opera: RTYWebHelper.isOpera(),
      msie: /msie/.test(userAgent) && !/opera/.test(userAgent),
      mozilla: /mozilla/.test(userAgent) && !/(compatible|webkit)/.test(userAgent)
    },

    loadedUrls: {},

    isUrlLoaded: function isUrlLoaded(url) {
      return HttpLibrary.loadedUrls[url] === true;
    },
    unregisterUrl: function unregisterUrl(url) {
      HttpLibrary.loadedUrls[url] = false;
    },
    registerUrl: function registerUrl(url) {
      HttpLibrary.loadedUrls[url] = true;
    },

    createScriptTag: function createScriptTag(url, success, error) {
      var scriptTag = document.createElement('script');
      scriptTag.setAttribute('id', 'dove-js-' + url.replace(/[\./]+/g, '-'));
      scriptTag.setAttribute('type', 'text/javascript');
      scriptTag.setAttribute('charset', 'utf-8');
      scriptTag.setAttribute('src', url);

      scriptTag.onload = scriptTag.onreadystatechange = function () {
        if (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete') {
          success();
        }
      };
      scriptTag.onerror = function () {
        error && error(url, url + ' failed to load');
      };

      var toBody = true;
      if (!toBody) {
        var head = HttpLibrary.getHead();
        head.appendChild(scriptTag);
      } else {
        var body = HttpLibrary.getBody();
        body.appendChild(scriptTag);
      }
    },
    getHead: function getHead() {
      return document.getElementsByTagName('head')[0] || document.documentElement;
    },
    getBody: function getBody() {
      return document.body;
    },
    globalEval: function globalEval(data, url, into) {
      var script = document.createElement('script');
      script.type = 'text/javascript';
      script.id = 'dove-js-' + url.replace(/[\./]+/g, '-');
      script.charset = 'UTF-8';
      if (HttpLibrary.browser.msie) {
        script.text = data;
      } else {
        script.appendChild(document.createTextNode(data));
      }

      into = into || 'head';
      if (into === 'head') {
        var head = HttpLibrary.getHead();
        head.appendChild(script);
      } else {
        var body = HttpLibrary.getBody();
        body.appendChild(script);
      }
    },
    loadJavascript_jQuery: function loadJavascript_jQuery(data) {
      if (HttpLibrary.browser.safari) {
        return window.jQuery.ajax({
          type: 'GET',
          url: data.url,
          data: null,
          success: function success(content) {
            HttpLibrary.globalEval(content, data.url, 'body');
            data.success();
          },
          error: function error(xml, status, e) {
            if (xml && xml.responseText) {
              data.error(xml.responseText);
            } else {
              data.error(data.url + '\n' + e.message);
            }
          },
          dataType: 'html'
        });
      } else {
        HttpLibrary.createScriptTag(data.url, data.success, data.error);
      }
    },
    loadJavascript_MSAJAX: function loadJavascript_MSAJAX(data) {
      if (HttpLibrary.browser.safari) {
        var params = {
          url: data.url,
          success: function success(content) {
            HttpLibrary.globalEval(content);
            data.success(content);
          },
          error: data.error
        };
        HttpLibrary.httpGet_MSAJAX(params);
      } else {
        HttpLibrary.createScriptTag(data.url, data.success, data.error);
      }
    },
    loadJavascript_Prototype: function loadJavascript_Prototype(data) {
      if (HttpLibrary.browser.safari) {
        var params = {
          url: data.url,
          success: function success(content) {
            HttpLibrary.globalEval(content);
            data.success(content);
          },
          error: data.error
        };
        HttpLibrary.httpGet_Prototype(params);
      } else {
        HttpLibrary.createScriptTag(data.url, data.success, data.error);
      }
    },
    httpGet_jQuery: function httpGet_jQuery(data) {
      return window.jQuery.ajax({
        type: 'GET',
        url: data.url,
        data: null,
        success: data.success,
        error: function error(xml, status, e) {
          if (xml && xml.responseText) {
            data.error(xml.responseText);
          } else {
            data.error('Error occured while loading: ' + data.url + '\n' + e.message);
          }
        },
        dataType: data.type || 'html'
      });
    },
    httpGet_MSAJAX: function httpGet_MSAJAX(data) {
      var _wRequest = new Sys.Net.WebRequest();
      _wRequest.set_url(data.url);
      _wRequest.set_httpVerb('GET');
      _wRequest.add_completed(function (result) {
        var errorMsg = 'Failed to load:' + data.url;
        if (result.get_timedOut()) {
          errorMsg = 'Timed out';
        }
        if (result.get_aborted()) {
          errorMsg = 'Aborted';
        }

        if (result.get_responseAvailable()) {
          data.success(result.get_responseData());
        } else {
          data.error(errorMsg);
        }
      });

      var executor = new Sys.Net.XMLHttpExecutor();
      _wRequest.set_executor(executor);
      executor.executeRequest();
    },
    httpGet_Prototype: function httpGet_Prototype(data) {
      new Ajax.Request(data.url, {
        method: 'get',
        evalJS: false, // Make sure prototype does not automatically evan scripts
        onSuccess: function onSuccess(transport, json) {
          data.success(transport.responseText || '');
        },
        onFailure: data.error
      });
    }
  };
  $du.EnsureExecutor = function (data, callback, failCall, scope) {
    this.data = this.clone(data);
    this.callback = typeof scope === 'undefined' || scope === null ? callback : this.delegate(callback, scope);
    this.failCall = typeof scope === 'undefined' || scope === null ? failCall : this.delegate(failCall, scope);
    this.loadStack = [];

    if (data.js && data.js.constructor !== Array) {
      this.data.js = [data.js];
    }
    if (data.html && data.html.constructor !== Array) {
      this.data.html = [data.html];
    }
    if (data.css && data.css.constructor !== Array) {
      this.data.css = [data.css];
    }

    if (typeof data.js === 'undefined') {
      this.data.js = [];
    }
    if (typeof data.html === 'undefined') {
      this.data.html = [];
    }
    if (typeof data.css === 'undefined') {
      this.data.css = [];
    }

    this.init();
    this.load();
  };
  $du.EnsureExecutor.prototype = {
    init: function init() {
      // Fetch Javascript using Framework specific library
      if (typeof jQuery !== 'undefined') {
        this.getJS = HttpLibrary.loadJavascript_jQuery;
        this.httpGet = HttpLibrary.httpGet_jQuery;
      } else if (typeof Prototype !== 'undefined') {
        this.getJS = HttpLibrary.loadJavascript_Prototype;
        this.httpGet = HttpLibrary.httpGet_Prototype;
      } else if (typeof Sys !== 'undefined') {
        this.getJS = HttpLibrary.loadJavascript_MSAJAX;
        this.httpGet = HttpLibrary.httpGet_MSAJAX;
      } else {
        throw new Error('jQuery, Prototype or MS AJAX framework not found');
      }
    },
    getJS: function getJS(data) {
      // abstract function to get Javascript and execute it
    },
    httpGet: function httpGet(url, callback) {
      // abstract function to make HTTP GET call
    },
    load: function load() {
      var fnc_fail = function fnc_fail(urlList) {
        this.failcall && this.failcall(urlList);
      };

      this.loadJavascripts(this.delegate(function () {
        this.loadCSS(this.delegate(function () {
          this.loadHtml(this.delegate(function () {
            this.callback && this.callback();
          }), this.delegate(fnc_fail));
        }), this.delegate(fnc_fail));
      }), this.delegate(fnc_fail));
    },
    loadJavascripts: function loadJavascripts(complete, fail) {
      var scriptsToLoad = this.data.js.length;
      if (scriptsToLoad === 0) {
        return complete();
      }

      var hasError = false;
      var hasErrorJsList = [];
      this.forEach(this.data.js, function (href) {
        if (HttpLibrary.isUrlLoaded(href) || this.isTagLoaded('script', 'src', href)) {
          scriptsToLoad--;
        } else {
          this.getJS({
            url: href,
            success: this.delegate(function (content) {
              scriptsToLoad--;
              HttpLibrary.registerUrl(href);
            }),
            error: this.delegate(function (msg) {
              scriptsToLoad--;
              if (typeof this.data.error === 'function') {
                this.data.error(href, msg);
              }

              console.log('[Error] loadJavascripts: ' + href + ' \t[Meesage]: ' + msg);
              hasErrorJsList.push(href);
              hasError = true;
            })
          });
        }
      });

      // wait until all the external scripts are downloaded
      this.until({
        test: function test() {
          return scriptsToLoad === 0;
        },
        delay: 50,
        callback: this.delegate(function () {
          if (hasError) {
            fail && fail(hasErrorJsList);
          } else {
            complete && complete();
          }
        })
      });
    },
    loadCSS: function loadCSS(complete, fail) {
      if (this.data.css.length === 0) {
        return complete();
      }

      var hasError = false;
      var hasErrorCSSList = [];

      var head = HttpLibrary.getHead();
      this.forEach(this.data.css, function (href) {
        if (HttpLibrary.isUrlLoaded(href) || this.isTagLoaded('link', 'href', href)) {
          // Do nothing
        } else {
          var self = this;
          try {
            (function (href, head) {
              var link = document.createElement('link');
              link.setAttribute('href', href);
              link.setAttribute('rel', 'Stylesheet');
              link.setAttribute('type', 'text/css');
              head.appendChild(link);

              HttpLibrary.registerUrl(href);
            }).apply(window, [href, head]);
          } catch (e) {
            if (typeof self.data.error === 'function') {
              self.data.error(href, e.message);
              console.log('[Error] loadCSS: ' + href + ' \t[Meesage]: ' + e.message);
            }
            hasErrorCSSList.push(href);
            hasError = true;
          }
        }
      });

      if (!hasError) {
        complete && complete();
      } else {
        fail && fail(hasErrorCSSList);
      }
    },
    loadHtml: function loadHtml(complete, fail) {
      var htmlToDownload = this.data.html.length;
      if (htmlToDownload === 0) {
        return complete();
      }

      var hasError = false;
      var hasErrorHtmlList = [];
      this.forEach(this.data.html, function (href) {
        if (HttpLibrary.isUrlLoaded(href)) {
          htmlToDownload--;
        } else {
          this.httpGet({
            url: href,
            success: this.delegate(function (content) {
              htmlToDownload--;
              HttpLibrary.registerUrl(href);

              var parent = this.data.parent || document.body.appendChild(document.createElement('div'));
              if (typeof parent === 'string') {
                parent = document.getElementById(parent);
              }
              parent.innerHTML = content;
            }),
            error: this.delegate(function (msg) {
              htmlToDownload--;
              if (typeof this.data.error === 'function') {
                this.data.error(href, msg);
              }

              console.log('[Error] loadHtml: ' + href + ' \t[Meesage]: ' + msg);
              hasErrorHtmlList.push(href);
              hasError = true;
            })
          });
        }
      });

      // wait until all the external scripts are downloaded
      this.until({
        test: function test() {
          return htmlToDownload === 0;
        },
        delay: 50,
        callback: this.delegate(function () {
          if (hasError) {
            fail && fail(hasErrorHtmlList);
          } else {
            complete && complete();
          }
        })
      });
    },
    clone: function clone(obj) {
      var this$1 = this;

      var cloned = {};
      for (var p in obj) {
        var x = obj[p];

        if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object') {
          if (x.constructor === Array) {
            var a = [];
            for (var i = 0; i < x.length; i++) {
              a.push(x[i]);
            }
            cloned[p] = a;
          } else {
            cloned[p] = this$1.clone(x);
          }
        } else {
          cloned[p] = x;
        }
      }

      return cloned;
    },
    forEach: function forEach(arr, callback) {
      var self = this;
      for (var i = 0; i < arr.length; i++) {
        callback.apply(self, [arr[i]]);
      }
    },
    delegate: function delegate(func, obj) {
      var context = obj || this;
      return function () {
        func.apply(context, arguments);
      };
    },
    until: function until(o) {
      if (o.test() === true) {
        o.callback();
      } else {
        window.setTimeout(this.delegate(function () {
          this.until(o);
        }), o.delay || 50);
      }
    },
    isTagLoaded: function isTagLoaded(tagName, attName, value) {
      // Create a temporary tag to see what value browser eventually
      // gives to the attribute after doing necessary encoding
      var tag = document.createElement(tagName);
      tag[attName] = value;
      var tagFound = false;
      var tags = document.getElementsByTagName(tagName);
      this.forEach(tags, function (t) {
        if (tag[attName] === t[attName]) {
          tagFound = true;
          return false;
        }
      });
      return tagFound;
    }
  };
  $du.ensure = function (data, callback, failCall, scope) {
    if (typeof jQuery === 'undefined' && typeof Sys === 'undefined' && typeof Prototype === 'undefined') {
      return alert('jQuery, Microsoft ASP.NET AJAX or Prototype library not found. One must be present for ensure to work');
    }

    // There's a test criteria which when false, the associated components must be loaded. But if true,
    // no need to load the components
    if (typeof data.test !== 'undefined') {
      var test = function test() {
        return data.test;
      };

      if (typeof data.test === 'string') {
        test = function test() {
          // If there's no such Javascript variable and there's no such DOM element with ID then
          // the test fails. If any exists, then test succeeds
          return !(window.eval('typeof ' + data.test) === 'undefined' && document.getElementById(data.test) == null);
        };
      } else if (typeof data.test === 'function') {
        test = data.test;
      }

      // Now we have test prepared, time to execute the test and see if it returns null, undefined or false in any
      // scenario. If it does, then load the specified javascript/html/css
      if (test() === false || typeof test() === 'undefined' || test() == null) {
        new $du.EnsureExecutor(data, callback, failCall, scope);
      } else {
        // Test succeeded! Just fire the callback
        callback();
      }
    } else {
      // No test specified. So, load necessary javascript/html/css and execute the callback
      new $du.EnsureExecutor(data, callback, failCall, scope);
    }
  };

  uu$$5['RTY_3rd_Ensure'] = $du;

  /**
   * JQuery, 
   */
  function autoForJquery$5(ref) {
    var t$ = ref;
    if (window.jQuery && window.$) {
      window.$.templateLoader = t$.templateLoader;
      window.$.templateLoaderAgent = t$.templateLoaderAgent;
      window.$.cssjsLoader = t$.cssjsLoader;

      window.$['RTY_3rd_Ensure'] = t$['RTY_3rd_Ensure'];

      window.$ = window.$.extend(window.$, t$);
    }
  }

  var loaderWrapper = uu$$5;
  autoForJquery$5(uu$$5);

  // 
  /**
   * appId, AppID
   * promptText, 
   * getDataCB. 
   * cb, 
   */
  var uu$$7 = {};
  uu$$7.hasUpdateChecked = false;
  uu$$7.checkUpdate = function (appId, promptText, getDataCB, cb) {
    try {
      var t$ = this;
      var b$ = common$1.getBSb$();
      var $ = common$1.getJQuery$();

      var _checkUpdate = function _checkUpdate(data) {
        try {
          var lastVersion = data.checkUpdate.lastVersion || '';
          var updateURL = data.checkUpdate.updateURL || '';

          // Apple 
          var enableForMacOSAppStore = data.checkUpdate.enableForMacOSAppStore !== false;
          var enableForElectron = data.checkUpdate.enableForElectron !== false;
          var enableForNoMacOSAppStore = true;

          enableForMacOSAppStore = enableForMacOSAppStore && b$.pIsUseMacCocoEngine && b$.App.getSandboxEnable();
          enableForElectron = enableForElectron && b$.pIsUseElectron;
          enableForNoMacOSAppStore = b$.pIsUseMacCocoEngine && !b$.App.getSandboxEnable();

          // 
          if (enableForMacOSAppStore || enableForElectron || enableForNoMacOSAppStore) {
            // 
            var curAppVersion = b$.App.getAppVersion();
            console.log('last:' + lastVersion + ',cur:' + curAppVersion);
            if (common$1.compareVersion(lastVersion, curAppVersion) === 1) {
              var foundNewVersion = promptText || data.checkUpdate.prompt || 'The new version has been released.';
              alert(foundNewVersion);
              updateURL !== '' && b$.App.open(updateURL);
              cb && cb(data);
            }
          }
        } catch (e) {
          console.error(e);
        }
      };

      // 
      var jsonFile = appId || b$.App.getAppId() + '.json';
      var serverUrl = 'https://romanysoft.github.io/assert-config/configs/' + jsonFile;
      $.getJSON(serverUrl, function (data) {
        if (t$.hasUpdateChecked) {
          return;
        }
        t$.hasUpdateChecked = true;

        data = (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' ? data : {};
        data = data instanceof Array ? {
          'data': data
        } : data;
        getDataCB && getDataCB(data);
        _checkUpdate(data);
      });
    } catch (e) {
      console.error(e);
    }
  };

  // 
  uu$$7.checkStartInfo = function (info) {
    var b$ = common$1.getBSb$();
    if (b$.pN) {
      communication.reportInfo({
        'SYS_state': 'Starting...',
        'Add_info': info || {}
      });
    }
  };

  // 
  uu$$7.checkPatches = function (info) {
    loaderWrapper.RTY_3rd_Ensure.ensure({
      js: 'https://romanysoft.github.io/assert-config/patchs/config.js'
    }, function () {});
  };

  // 
  try {
    var $ = common$1.getJQuery$();
    var b$ = common$1.getBSb$();
    if ($) {
      $(document).ready(function () {
        console.log('-------------Delayed loading method, do not reflect here-------');

        // / 
        setTimeout(function () {
          uu$$7.checkStartInfo();

          if (b$.App.getSandboxEnable() && b$.App.getAppRunOnOS() === 'MacOSX') {
            console.log('------------- common app starting .... -------');
          } else {
            uu$$7.checkUpdate();
            // uu$.checkPatches()
          }
        }, 35 * 1000); // 35sec
      });
    }
  } catch (e) {
    console.error(e);
  }

  // -----------------------------------------------
  var update = uu$$7;

  var _$18 = underscore._;

  /**
   * 
   *  see http://my.oschina.net/zhangstephen/blog/673838
   * 
   * 
   * try... catch Error
   */
  try {
    var _callReport = function _callReport(e) {
      try {
        var message = common$1.RTYUtils.getErrorMessage(e);
        if (message && message !== '') {
          console.log('------ _callReport -----');
          console.log(message);

          if (config.reportErr) {
            // 
            communication.reportInfo({
              type: 'HTML5_RTY_EXCEPTION',
              errorMessage: message
            });
          }
        }
      } catch (err) {
        console.error(err);
      }
    };

    window.addEventListener('error', function (e) {
      _callReport(e);
    });
  } catch (error) {
    console.error(error);
  }

  var util = {};
  util = _$18.extend(util, compatibilityWrapper);
  util = _$18.extend(util, common$1);
  util = _$18.extend(util, config);
  util = _$18.extend(util, webHelper);
  util = _$18.extend(util, communication);
  util = _$18.extend(util, googleLangIDMaps);
  util = _$18.extend(util, loadLanguage);
  util = _$18.extend(util, loaderWrapper);
  util = _$18.extend(util, update);

  var util$1 = {
    version: '1.0.0',
    util: util
  };

  try {
    if (window) {
      window.BS = BS;
      window.Romanysoft = {
        _: underscore._,
        Util: util$1,
        Observable: Observable,
        SelfClass: SelfClass,
        BS: BS
      };
      window.DoveMax = window.Romanysoft;
    }
  } catch (error) {
    console.warn(error);
  }

  var index = {
    _: underscore._,
    Util: util$1,
    BS: BS,
    Observable: Observable,
    SelfClass: SelfClass,
    version: '1.0.0'
  };

  return index;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(71), __webpack_require__(72)(module), __webpack_require__(34)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(35);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(4)
  , core    = __webpack_require__(0)
  , fails   = __webpack_require__(15);
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};

/***/ }),
/* 18 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(64)
  , enumBugKeys = __webpack_require__(38);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(6).f
  , has = __webpack_require__(14)
  , TAG = __webpack_require__(1)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at  = __webpack_require__(155)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(39)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(159);
var global        = __webpack_require__(2)
  , hide          = __webpack_require__(10)
  , Iterators     = __webpack_require__(16)
  , TO_STRING_TAG = __webpack_require__(1)('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transfer = undefined;

var _dovemaxsdk = __webpack_require__(12);

var AgentClient = _dovemaxsdk.BS.b$.AgentClient;
var AgentServer = _dovemaxsdk.BS.b$.AgentServer;

var __$p$ = {
  backAgent: new AgentServer(),
  startBackAgent: function startBackAgent() {
    var agent = this.backAgent;
    agent.active({});
  },

  isRunning: false,
  frontAgent: new AgentClient(),
  startFrontAgent: function startFrontAgent() {
    var that = this;
    var agent = that.frontAgent;
    var wsSocketIO = new agent.Chancel();
    wsSocketIO.build({
      type: agent.ChancelType.websocketForNode,
      ip: '192.168.1.2',
      port: '8888',
      protocol: 'http://',
      reqUrl: '',
      clientIOType: 'Socket.io.client'
    });
    agent.registerOnFinishBuildChannel(function () {
      console.log('frontAgent is finish build');
      that.isRunning = true;
      console.log('__$p$.isRunning = ', that.isRunning);
    });
    agent.appendChancel(wsSocketIO);
  },
  run: function run() {
    var startBackAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    console.log('start transfer.js ....');
    if (startBackAgent) {
      this.startBackAgent();
    }
    this.startFrontAgent();
    return this;
  },

  send: function send(message, handler) {
    var one = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    handler && this.frontAgent.registerOnReceiveFromServer(handler, one);
    this.frontAgent.noticeToServer(message);
    return this;
  }
};

__$p$.Tools = {
  Hello: function Hello(handler) {
    var one = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    __$p$.send({ data: 'Hello' }, function (data) {
      handler(data);
    }, one);
  },
  Fix: {
    Image: {
      run: function run() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var handler = arguments[1];
        var one = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var debugMode = false;
        if (debugMode === false) {
          var taskInfo = {
            task_id: options.taskID,
            cli: 'aiexifcool/fix.image/index',
            reload: false,
            command: [{ action: 'startFix', data: options.data, lang: options.lang || 'en' }]
          };

          var info = {
            taskInfo: taskInfo,
            msg_type: 'c_task_exec'
          };

          __$p$.send(info, function (data) {
            if (data.task_id === options.taskID) {
              handler && handler(data);
            }
          }, one);
        } else {
          handler && handler();
        }
      },
      chancel: function chancel() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var taskInfo = {
          task_id: options.taskID,
          cli: 'aiexifcool/fix.image/index',
          reload: false,
          command: [{ action: 'stopFix', data: options.data, lang: options.lang || 'en' }]
        };

        var info = {
          taskInfo: taskInfo,
          msg_type: 'c_task_exec'
        };

        __$p$.send(info);
      }
    }
  },
  RemoveExifInfo: {
    run: function run() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var handler = arguments[1];
      var one = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var debugMode = false;
      if (debugMode === false) {
        var taskInfo = {
          task_id: options.taskID,
          cli: 'aiexifcool/remove.exif/index',
          reload: false,
          command: [{ action: 'startRemoveExifInfoAction', data: options.data, lang: options.lang || 'en' }]
        };

        var info = {
          taskInfo: taskInfo,
          msg_type: 'c_task_exec'
        };

        __$p$.send(info, function (data) {
          if (data.task_id === options.taskID) {
            handler && handler(data);
          }
        }, one);
      } else {
        handler && handler();
      }
    },
    stop: function stop() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var taskInfo = {
        task_id: options.taskID,
        cli: 'aiexifcool/remove.exif/index',
        reload: false,
        command: [{ action: 'stopRemoveExifInfoAction', data: options.data, lang: options.lang || 'en' }]
      };

      var info = {
        taskInfo: taskInfo,
        msg_type: 'c_task_exec'
      };

      __$p$.send(info);
    }
  }

};

var TransferClass = _dovemaxsdk.Observable.extend(__$p$);
var Transfer = new TransferClass();
Transfer.run();

exports.Transfer = Transfer;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(18)
  , TAG = __webpack_require__(1)('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 26 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var ctx         = __webpack_require__(13)
  , call        = __webpack_require__(148)
  , isArrayIter = __webpack_require__(147)
  , anObject    = __webpack_require__(7)
  , toLength    = __webpack_require__(46)
  , getIterFn   = __webpack_require__(68)
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = true;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(33)('meta')
  , isObject = __webpack_require__(5)
  , has      = __webpack_require__(14)
  , setDesc  = __webpack_require__(6).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(15)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(7)
  , dPs         = __webpack_require__(59)
  , enumBugKeys = __webpack_require__(38)
  , IE_PROTO    = __webpack_require__(43)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(37)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(54).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(26);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 33 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 34 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5)
  , document = __webpack_require__(2).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 38 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY        = __webpack_require__(28)
  , $export        = __webpack_require__(4)
  , redefine       = __webpack_require__(65)
  , hide           = __webpack_require__(10)
  , has            = __webpack_require__(14)
  , Iterators      = __webpack_require__(16)
  , $iterCreate    = __webpack_require__(149)
  , setToStringTag = __webpack_require__(20)
  , getPrototypeOf = __webpack_require__(63)
  , ITERATOR       = __webpack_require__(1)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(41)
  , createDesc     = __webpack_require__(31)
  , toIObject      = __webpack_require__(11)
  , toPrimitive    = __webpack_require__(47)
  , has            = __webpack_require__(14)
  , IE8_DOM_DEFINE = __webpack_require__(55)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(3) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 41 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(10);
module.exports = function(target, src, safe){
  for(var key in src){
    if(safe && target[key])target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(44)('keys')
  , uid    = __webpack_require__(33);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 45 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(45)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(5);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(2)
  , core           = __webpack_require__(0)
  , LIBRARY        = __webpack_require__(28)
  , wksExt         = __webpack_require__(49)
  , defineProperty = __webpack_require__(6).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(1);

/***/ }),
/* 50 */
/***/ (function(module, exports) {



/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var SysConfig = {
  appName: 'AiEXifCool',
  version: '1.0.0',
  homepage: 'https://github.com/LabsRS-Dev/AiEXifCool',
  docPage: 'https://github.com/LabsRS-Dev/AiEXifCool'
};

exports.SysConfig = SysConfig;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _About = __webpack_require__(75);

var _About2 = _interopRequireDefault(_About);

var _icon = __webpack_require__(98);

var _icon2 = _interopRequireDefault(_icon);

var _Modify = __webpack_require__(76);

var _Modify2 = _interopRequireDefault(_Modify);

var _Remove = __webpack_require__(77);

var _Remove2 = _interopRequireDefault(_Remove);

var _Repair = __webpack_require__(78);

var _Repair2 = _interopRequireDefault(_Repair);

var _sysConfig = __webpack_require__(51);

var _Welcome = __webpack_require__(79);

var _Welcome2 = _interopRequireDefault(_Welcome);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var icons = _icon2.default.iconSet;
var rootPath = '/' + _sysConfig.SysConfig.appName;

var menu = [{
  title: 'routes.common.title',
  isExpand: true,
  enableExpand: false,
  visible: true,
  menu: [{
    path: '',
    redirect: rootPath + '/welcome',
    show: false
  }, {
    path: rootPath + '/welcome',
    show: true,
    component: _Welcome2.default,
    title: 'routes.common.menu.welcome.title',
    tip: 'routes.common.menu.welcome.tip',
    tipAsSubTitle: false,
    icon: icons.adjust,
    sourceUrl: ''
  }, {
    path: rootPath + '/adjust',
    show: true,
    component: _Modify2.default,
    title: 'routes.common.menu.adjust.title',
    tip: 'routes.common.menu.adjust.tip',
    tipAsSubTitle: false,
    icon: icons.adjust,
    sourceUrl: ''
  }, {
    path: rootPath + '/remove',
    show: true,
    component: _Remove2.default,
    title: 'routes.common.menu.remove.title',
    tip: 'routes.common.menu.remove.tip',
    tipAsSubTitle: false,
    icon: icons.remove,
    sourceUrl: ''
  }, {
    path: rootPath + '/repair',
    show: true,
    component: _Repair2.default,
    title: 'routes.common.menu.repair.title',
    tip: 'routes.common.menu.repair.tip',
    tipAsSubTitle: false,
    icon: icons.repair,
    sourceUrl: ''
  }, {
    path: rootPath + '/compare',
    show: false,
    component: _About2.default,
    title: 'routes.common.menu.compare.title',
    tip: 'routes.common.menu.compare.tip',
    icon: icons.compare,
    sourceUrl: ''
  }, {
    path: rootPath + '/report',
    show: false,
    component: _About2.default,
    title: 'routes.common.menu.report.title',
    tip: 'routes.common.menu.report.tip',
    icon: icons.report,
    sourceUrl: ''
  }]
}, {
  title: '',
  isExpand: true,
  enableExpand: false,
  visible: false,
  menu: [{
    path: '/MyTool/local',
    show: true,
    component: _About2.default,
    title: '',
    tip: '',
    icon: icons.discover,
    sourceUrl: ''
  }, {
    path: '/MyTool/download',
    show: true,
    component: _About2.default,
    title: '',
    tip: '',
    icon: icons.discover,
    sourceUrl: ''
  }, {
    path: '/MyTool/cloud',
    show: false,
    component: _About2.default,
    title: '',
    tip: '',
    icon: icons.discover,
    sourceUrl: ''
  }, {
    path: '/MyTool/author',
    show: true,
    component: _About2.default,
    title: '',
    tip: '',
    icon: icons.discover,
    sourceUrl: ''
  }]
}, {
  title: '',
  isExpand: false,
  enableExpand: true,
  visible: false,
  menu: []
}, {
  title: '',
  isExpand: false,
  enableExpand: true,
  visible: false,
  menu: [{
    path: '/ui-about',
    component: _About2.default,
    title: 'About',
    tip: '',
    icon: icons.discover,
    sourceUrl: ''
  }]
}];

var routes = menu.reduce(function (paths, section) {
  var sectionPaths = section.menu.map(function (menuItem) {
    return {
      path: menuItem.path,
      redirect: menuItem.redirect || '',
      component: menuItem.component,
      meta: {
        section: section.title,
        title: menuItem.title,
        tip: menuItem.tip,
        tipAsSubTitle: menuItem.tipAsSubTitle || false,
        icon: menuItem.icon,
        show: menuItem.show,
        sourceUrl: menuItem.sourceUrl
      }
    };
  });

  return paths.concat(sectionPaths);
}, []);

exports.default = {
  SysConfig: _sysConfig.SysConfig,
  icons: icons,
  menu: menu,
  routes: routes
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(130), __esModule: true };

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2).document && document.documentElement;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(3) && !__webpack_require__(15)(function(){
  return Object.defineProperty(__webpack_require__(37)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(18);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(18);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(6)
  , anObject = __webpack_require__(7)
  , getKeys  = __webpack_require__(19);

module.exports = __webpack_require__(3) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(11)
  , gOPN      = __webpack_require__(61).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(64)
  , hiddenKeys = __webpack_require__(38).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 62 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(14)
  , toObject    = __webpack_require__(32)
  , IE_PROTO    = __webpack_require__(43)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(14)
  , toIObject    = __webpack_require__(11)
  , arrayIndexOf = __webpack_require__(138)(false)
  , IE_PROTO     = __webpack_require__(43)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(10);

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global      = __webpack_require__(2)
  , core        = __webpack_require__(0)
  , dP          = __webpack_require__(6)
  , DESCRIPTORS = __webpack_require__(3)
  , SPECIES     = __webpack_require__(1)('species');

module.exports = function(KEY){
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var ctx                = __webpack_require__(13)
  , invoke             = __webpack_require__(146)
  , html               = __webpack_require__(54)
  , cel                = __webpack_require__(37)
  , global             = __webpack_require__(2)
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(__webpack_require__(18)(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(25)
  , ITERATOR  = __webpack_require__(1)('iterator')
  , Iterators = __webpack_require__(16);
module.exports = __webpack_require__(0).getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(2)
  , has            = __webpack_require__(14)
  , DESCRIPTORS    = __webpack_require__(3)
  , $export        = __webpack_require__(4)
  , redefine       = __webpack_require__(65)
  , META           = __webpack_require__(29).KEY
  , $fails         = __webpack_require__(15)
  , shared         = __webpack_require__(44)
  , setToStringTag = __webpack_require__(20)
  , uid            = __webpack_require__(33)
  , wks            = __webpack_require__(1)
  , wksExt         = __webpack_require__(49)
  , wksDefine      = __webpack_require__(48)
  , keyOf          = __webpack_require__(151)
  , enumKeys       = __webpack_require__(145)
  , isArray        = __webpack_require__(57)
  , anObject       = __webpack_require__(7)
  , toIObject      = __webpack_require__(11)
  , toPrimitive    = __webpack_require__(47)
  , createDesc     = __webpack_require__(31)
  , _create        = __webpack_require__(30)
  , gOPNExt        = __webpack_require__(60)
  , $GOPD          = __webpack_require__(40)
  , $DP            = __webpack_require__(6)
  , $keys          = __webpack_require__(19)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(61).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(41).f  = $propertyIsEnumerable;
  __webpack_require__(62).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(28)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/*!
 * vue-i18n v6.0.0-beta.1 
 * (c) 2017 kazuya kawaguchi
 * Released under the MIT License.
 */


/*  */

/**
 * utilites
 */

function warn (msg, err) {
  if (typeof console !== 'undefined') {
    console.warn('[vue-i18n] ' + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}



function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject (obj) {
  return toString.call(obj) === OBJECT_STRING
}

function isNull (val) {
  return val === null || val === undefined
}

function parseArgs () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  var locale = null;
  var params = null;
  if (args.length === 1) {
    if (isObject(args[0]) || Array.isArray(args[0])) {
      params = args[0];
    } else if (typeof args[0] === 'string') {
      locale = args[0];
    }
  } else if (args.length === 2) {
    if (typeof args[0] === 'string') {
      locale = args[0];
    }
    if (isObject(args[1]) || Array.isArray(args[1])) {
      params = args[1];
    }
  }

  return { locale: locale, params: params }
}

function getOldChoiceIndexFixed (choice) {
  return choice
    ? choice > 1
      ? 1
      : 0
    : 1
}

function getChoiceIndex (choice, choicesLength) {
  choice = Math.abs(choice);

  if (choicesLength === 2) { return getOldChoiceIndexFixed(choice) }

  return choice ? Math.min(choice, 2) : 0
}

function fetchChoice (message, choice) {
  if (!message && typeof message !== 'string') { return null }
  var choices = message.split('|');

  choice = getChoiceIndex(choice, choices.length);
  if (!choices[choice]) { return message }
  return choices[choice].trim()
}

function looseClone (obj) {
  return JSON.parse(JSON.stringify(obj))
}

/*  */

var $t = function (vm) {
  // add dependency tracking !!
  var locale = vm.$i18n.locale;
  /* eslint-disable no-unused-vars */
  var fallback = vm.$i18n.fallbackLocal;
  /* eslint-enable no-unused-vars */
  var messages = vm.$i18n.vm.messages;
  return function (key) {
    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

    return (ref = vm.$i18n)._t.apply(ref, [ key, locale, messages, vm ].concat( values ))
    var ref;
  }
};
var $tc = function (vm) {
  // add dependency tracking !!
  var locale = vm.$i18n.locale;
  /* eslint-disable no-unused-vars */
  var fallback = vm.$i18n.fallbackLocal;
  /* eslint-enable no-unused-vars */
  var messages = vm.$i18n.vm.messages;
  return function (key, choice) {
    var values = [], len = arguments.length - 2;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];

    return (ref = vm.$i18n)._tc.apply(ref, [ key, locale, messages, vm, choice ].concat( values ))
    var ref;
  }
};
var $te = function (vm) {
  // add dependency tracking !!
  var locale = vm.$i18n.locale;
  var messages = vm.$i18n.vm.messages;
  return function (key) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

    return (ref = vm.$i18n)._te.apply(ref, [ key, locale, messages ].concat( args ))
    var ref;
  }
};

function defineComputed (vm, options) {
  options.computed = options.computed || {};
  options.computed.$t = function () { return $t(vm); };
  options.computed.$tc = function () { return $tc(vm); };
  options.computed.$te = function () { return $te(vm); };
}

var mixin = {
  beforeCreate: function beforeCreate () {
    var options = this.$options;
    if (options.i18n) {
      if (options.i18n instanceof VueI18n) {
        this._i18n = options.i18n;
        defineComputed(this, options);
      } else if (isPlainObject(options.i18n)) {
        // component local i18n
        if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {
          options.i18n.root = this.$root.$i18n;
        }
        this._i18n = new VueI18n(options.i18n);
        defineComputed(this, options);
        if (options.i18n.sync === undefined || !!options.i18n.sync) {
          this._localeWatcher = this.$i18n.watchLocale();
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn("Cannot be interpreted 'i18n' option.");
        }
      }
    } else if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {
      // root i18n
      this._i18n = this.$root.$i18n;
      defineComputed(this, options);
    }
  },

  beforeDestroy: function beforeDestroy () {
    if (!this._i18n) { return }

    if (this._localeWatcher) {
      this.$i18n.unwatchLocale();
      delete this._localeWatcher;
    }

    this._i18n = null;
  }
};

var Vue;

function install (_Vue) {
  Vue = _Vue;

  var version = (Vue.version && Number(Vue.version.split('.')[0])) || -1;
  if (process.env.NODE_ENV !== 'production' && install.installed) {
    warn('already installed.');
    return
  }
  install.installed = true;

  if (process.env.NODE_ENV !== 'production' && version < 2) {
    warn(("vue-i18n (" + (install.version) + ") need to use Vue 2.0 or later (Vue: " + (Vue.version) + ")."));
    return
  }

  Object.defineProperty(Vue.prototype, '$i18n', {
    get: function get () { return this._i18n }
  });

  Vue.mixin(mixin);

  // use object-based merge strategy
  var strats = Vue.config.optionMergeStrategies;
  strats.i18n = strats.methods;
}

/*  */

var BaseFormatter = function BaseFormatter (options) {
  if ( options === void 0 ) options = {};

  this._options = options;
};

var prototypeAccessors$1 = { options: {} };

prototypeAccessors$1.options.get = function () { return this._options };

BaseFormatter.prototype.format = function format (message) {
    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

  return template.apply(void 0, [ message ].concat( values ))
};

Object.defineProperties( BaseFormatter.prototype, prototypeAccessors$1 );

/**
 *  String format template
 *  - Inspired:
 *    https://github.com/Matt-Esch/string-template/index.js
 */

var RE_NARGS = /(%|)\{([0-9a-zA-Z_]+)\}/g;

/**
 * template
 *
 * @param {String} string
 * @param {Array} ...values
 * @return {String}
 */

function template (str) {
  var values = [], len = arguments.length - 1;
  while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

  if (values.length === 1 && typeof values[0] === 'object') {
    values = values[0];
  } else {
    values = {};
  }

  if (!values || !values.hasOwnProperty) {
    values = {};
  }

  return str.replace(RE_NARGS, function (match, prefix, i, index) {
    var result;

    if (str[index - 1] === '{' &&
      str[index + match.length] === '}') {
      return i
    } else {
      result = hasOwn(values, i) ? values[i] : match;
      if (isNull(result)) {
        return ''
      }

      return result
    }
  })
}

/*  */

/**
 *  Path paerser
 *  - Inspired:
 *    Vue.js Path parser
 */

// cache
var pathCache = Object.create(null);

// actions
var APPEND = 0;
var PUSH = 1;
var INC_SUB_PATH_DEPTH = 2;
var PUSH_SUB_PATH = 3;

// states
var BEFORE_PATH = 0;
var IN_PATH = 1;
var BEFORE_IDENT = 2;
var IN_IDENT = 3;
var IN_SUB_PATH = 4;
var IN_SINGLE_QUOTE = 5;
var IN_DOUBLE_QUOTE = 6;
var AFTER_PATH = 7;
var ERROR = 8;

var pathStateMachine = [];

pathStateMachine[BEFORE_PATH] = {
  'ws': [BEFORE_PATH],
  'ident': [IN_IDENT, APPEND],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[IN_PATH] = {
  'ws': [IN_PATH],
  '.': [BEFORE_IDENT],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[BEFORE_IDENT] = {
  'ws': [BEFORE_IDENT],
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND]
};

pathStateMachine[IN_IDENT] = {
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND],
  'ws': [IN_PATH, PUSH],
  '.': [BEFORE_IDENT, PUSH],
  '[': [IN_SUB_PATH, PUSH],
  'eof': [AFTER_PATH, PUSH]
};

pathStateMachine[IN_SUB_PATH] = {
  "'": [IN_SINGLE_QUOTE, APPEND],
  '"': [IN_DOUBLE_QUOTE, APPEND],
  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
  ']': [IN_PATH, PUSH_SUB_PATH],
  'eof': ERROR,
  'else': [IN_SUB_PATH, APPEND]
};

pathStateMachine[IN_SINGLE_QUOTE] = {
  "'": [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_SINGLE_QUOTE, APPEND]
};

pathStateMachine[IN_DOUBLE_QUOTE] = {
  '"': [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_DOUBLE_QUOTE, APPEND]
};

/**
 * Check if an expression is a literal value.
 */

var literalValueRE = /^\s?(true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral (exp) {
  return literalValueRE.test(exp)
}

/**
 * Strip quotes from a string
 */

function stripQuotes (str) {
  var a = str.charCodeAt(0);
  var b = str.charCodeAt(str.length - 1);
  return a === b && (a === 0x22 || a === 0x27)
    ? str.slice(1, -1)
    : str
}

/**
 * Determine the type of a character in a keypath.
 */

function getPathCharType (ch) {
  if (ch === undefined || ch === null) { return 'eof' }

  var code = ch.charCodeAt(0);

  switch (code) {
    case 0x5B: // [
    case 0x5D: // ]
    case 0x2E: // .
    case 0x22: // "
    case 0x27: // '
    case 0x30: // 0
      return ch

    case 0x5F: // _
    case 0x24: // $
    case 0x2D: // -
      return 'ident'

    case 0x20: // Space
    case 0x09: // Tab
    case 0x0A: // Newline
    case 0x0D: // Return
    case 0xA0:  // No-break space
    case 0xFEFF:  // Byte Order Mark
    case 0x2028:  // Line Separator
    case 0x2029:  // Paragraph Separator
      return 'ws'
  }

  // a-z, A-Z
  if ((code >= 0x61 && code <= 0x7A) || (code >= 0x41 && code <= 0x5A)) {
    return 'ident'
  }

  // 1-9
  if (code >= 0x31 && code <= 0x39) { return 'number' }

  return 'else'
}

/**
 * Format a subPath, return its plain form if it is
 * a literal string or number. Otherwise prepend the
 * dynamic indicator (*).
 */

function formatSubPath (path) {
  var trimmed = path.trim();
  // invalid leading 0
  if (path.charAt(0) === '0' && isNaN(path)) { return false }

  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed
}

/**
 * Parse a string path into an array of segments
 */

function parse (path) {
  var keys = [];
  var index = -1;
  var mode = BEFORE_PATH;
  var subPathDepth = 0;
  var c;
  var key;
  var newChar;
  var type;
  var transition;
  var action;
  var typeMap;
  var actions = [];

  actions[PUSH] = function () {
    if (key !== undefined) {
      keys.push(key);
      key = undefined;
    }
  };

  actions[APPEND] = function () {
    if (key === undefined) {
      key = newChar;
    } else {
      key += newChar;
    }
  };

  actions[INC_SUB_PATH_DEPTH] = function () {
    actions[APPEND]();
    subPathDepth++;
  };

  actions[PUSH_SUB_PATH] = function () {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = IN_SUB_PATH;
      actions[APPEND]();
    } else {
      subPathDepth = 0;
      key = formatSubPath(key);
      if (key === false) {
        return false
      } else {
        actions[PUSH]();
      }
    }
  };

  function maybeUnescapeQuote () {
    var nextChar = path[index + 1];
    if ((mode === IN_SINGLE_QUOTE && nextChar === "'") ||
      (mode === IN_DOUBLE_QUOTE && nextChar === '"')) {
      index++;
      newChar = '\\' + nextChar;
      actions[APPEND]();
      return true
    }
  }

  while (mode !== null) {
    index++;
    c = path[index];

    if (c === '\\' && maybeUnescapeQuote()) {
      continue
    }

    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap['else'] || ERROR;

    if (transition === ERROR) {
      return // parse error
    }

    mode = transition[0];
    action = actions[transition[1]];
    if (action) {
      newChar = transition[2];
      newChar = newChar === undefined
        ? c
        : newChar;
      if (action() === false) {
        return
      }
    }

    if (mode === AFTER_PATH) {
      return keys
    }
  }
}

/**
 * External parse that check for a cache hit first
 */

function parsePath (path) {
  var hit = pathCache[path];
  if (!hit) {
    hit = parse(path);
    if (hit) {
      pathCache[path] = hit;
    }
  }
  return hit || []
}





function empty (target) {
  if (target === null || target === undefined) { return true }

  if (Array.isArray(target)) {
    if (target.length > 0) { return false }
    if (target.length === 0) { return true }
  } else if (isPlainObject(target)) {
    for (var key in target) {
      if (hasOwn(target, key)) { return false }
    }
  }

  return true
}

/**
 * Get path value from path string
 */
function getPathValue (obj, path) {
  if (!isObject(obj)) { return null }

  var paths = parsePath(path);
  if (empty(paths)) {
    return null
  } else {
    var length = paths.length;
    var ret = null;
    var last = obj;
    var i = 0;
    while (i < length) {
      var value = last[paths[i]];
      if (value === undefined) {
        last = null;
        break
      }
      last = value;
      i++;
    }

    ret = last;
    return ret
  }
}

/*  */

var VueI18n = function VueI18n (options) {
  if ( options === void 0 ) options = {};

  var locale = options.locale || 'en-US';
  var fallbackLocale = options.fallbackLocale || 'en-US';
  var messages = options.messages || {};
  this._vm = null;
  this._formatter = options.formatter || new BaseFormatter();
  this._missing = options.missing;
  this._root = options.root || null;
  this._sync = options.sync === undefined ? true : !!options.sync;
  this._fallbackRoot = options.fallbackRoot === undefined ? true : !!options.fallbackRoot;

  this._exist = function (message, key) {
    if (!message || !key) { return false }
    return !isNull(getPathValue(message, key))
  };

  this._initVM({ locale: locale, fallbackLocale: fallbackLocale, messages: messages });
};

var prototypeAccessors = { vm: {},messages: {},locale: {},fallbackLocale: {},missing: {},formatter: {} };

VueI18n.prototype._initVM = function _initVM (data) {
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  this._vm = new Vue({ data: data });
  Vue.config.silent = silent;
};

VueI18n.prototype.watchLocale = function watchLocale () {
  if (!this._sync || !this._root) { return null }
  var target = this._vm;
  this._watcher = this._root.vm.$watch('locale', function (val) {
    target.$set(target, 'locale', val);
  }, { immediate: true });
  return this._watcher
};

VueI18n.prototype.unwatchLocale = function unwatchLocale () {
  if (!this._sync || !this._watcher) { return false }
  if (this._watcher) {
    this._watcher();
    delete this._watcher;
  }
  return true
};

prototypeAccessors.vm.get = function () { return this._vm };

prototypeAccessors.messages.get = function () { return looseClone(this._vm.messages) };

prototypeAccessors.locale.get = function () { return this._vm.locale };
prototypeAccessors.locale.set = function (locale) {
  this._vm.$set(this._vm, 'locale', locale);
};

prototypeAccessors.fallbackLocale.get = function () { return this._vm.fallbackLocale };
prototypeAccessors.fallbackLocale.set = function (locale) {
  this._vm.$set(this._vm, 'fallbackLocale', locale);
};

prototypeAccessors.missing.get = function () { return this._missing };
prototypeAccessors.missing.set = function (handler) { this._missing = handler; };

prototypeAccessors.formatter.get = function () { return this._formatter };
prototypeAccessors.formatter.set = function (formatter) { this._formatter = formatter; };

VueI18n.prototype._warnDefault = function _warnDefault (locale, key, result, vm) {
  if (!isNull(result)) { return result }
  if (this.missing) {
    this.missing.apply(null, [locale, key, vm]);
  } else {
    if (process.env.NODE_ENV !== 'production') {
      warn(
        "Cannot translate the value of keypath '" + key + "'. " +
        'Use the value of keypath as default.'
      );
    }
  }
  return key
};

VueI18n.prototype._isFallbackRoot = function _isFallbackRoot (val) {
  return !val && !isNull(this._root) && this._fallbackRoot
};

VueI18n.prototype._interpolate = function _interpolate (message, key, values) {
    var this$1 = this;

  if (!message) { return null }

  var pathRet = getPathValue(message, key);
  if (Array.isArray(pathRet)) { return pathRet }

  var ret;
  if (isNull(pathRet)) {
    if (isPlainObject(message)) {
      ret = message[key];
      if (typeof ret !== 'string') {
        if (process.env.NODE_ENV !== 'production') {
          warn(("Value of key '" + key + "' is not a string!"));
        }
        return null
      }
    } else {
      return null
    }
  } else {
    if (typeof pathRet === 'string') {
      ret = pathRet;
    } else {
      if (process.env.NODE_ENV !== 'production') {
        warn(("Value of key '" + key + "' is not a string!"));
      }
      return null
    }
  }

  // Check for the existance of links within the translated string
  if (ret.indexOf('@:') >= 0) {
    // Match all the links within the local
    // We are going to replace each of
    // them with its translation
    var matches = ret.match(/(@:[\w|.]+)/g);
    for (var idx in matches) {
      var link = matches[idx];
      // Remove the leading @:
      var linkPlaceholder = link.substr(2);
      // Translate the link
      var translatedstring = this$1._interpolate(message, linkPlaceholder, values);
      // Replace the link with the translated string
      ret = ret.replace(link, translatedstring);
    }
  }

  return !values ? ret : this._format(ret, values)
};

VueI18n.prototype._format = function _format (message) {
    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

  return (ref = this._formatter).format.apply(ref, [ message ].concat( values ))
    var ref;
};

VueI18n.prototype._translate = function _translate (messages, locale, fallback, key, args) {
  var res = null;
  res = this._interpolate(messages[locale], key, args);
  if (!isNull(res)) { return res }

  res = this._interpolate(messages[fallback], key, args);
  if (!isNull(res)) {
    if (process.env.NODE_ENV !== 'production') {
      warn(("Fall back to translate the keypath '" + key + "' with '" + fallback + "' locale."));
    }
    return res
  } else {
    return null
  }
};

VueI18n.prototype._t = function _t (key, _locale, messages, host) {
    var values = [], len = arguments.length - 4;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 4 ];

  if (!key) { return '' }

  var parsedArgs = parseArgs.apply(void 0, values);
  var locale = parsedArgs.locale || _locale;

  var ret = this._translate(messages, locale, this.fallbackLocale, key, parsedArgs.params);
  if (this._isFallbackRoot(ret)) {
    if (process.env.NODE_ENV !== 'production') {
        warn(("Fall back to translate the keypath '" + key + "' with root locale."));
    }
    if (!this._root) { throw Error('unexpected error') }
    return (ref = this._root).t.apply(ref, [ key ].concat( values ))
  } else {
    return this._warnDefault(locale, key, ret, host)
  }
    var ref;
};

VueI18n.prototype.t = function t (key) {
    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

  return (ref = this)._t.apply(ref, [ key, this.locale, this.messages, null ].concat( values ))
    var ref;
};

VueI18n.prototype._tc = function _tc (key, _locale, messages, host, choice) {
    var values = [], len = arguments.length - 5;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 5 ];

  if (!key) { return '' }
  if (choice !== undefined) {
    return fetchChoice((ref = this)._t.apply(ref, [ key, _locale, messages, host ].concat( values )), choice)
  } else {
    return (ref$1 = this)._t.apply(ref$1, [ key, _locale, messages, host ].concat( values ))
  }
    var ref;
    var ref$1;
};

VueI18n.prototype.tc = function tc (key, choice) {
    var values = [], len = arguments.length - 2;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];

  return (ref = this)._tc.apply(ref, [ key, this.locale, this.messages, null, choice ].concat( values ))
    var ref;
};

VueI18n.prototype._te = function _te (key, _locale, messages) {
    var args = [], len = arguments.length - 3;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 3 ];

  var locale = parseArgs.apply(void 0, args).locale || _locale;
  return this._exist(messages[locale], key)
};

VueI18n.prototype.te = function te (key) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  return (ref = this)._te.apply(ref, [ key, this.locale, this.messages ].concat( args ))
    var ref;
};

VueI18n.prototype.getLocaleMessage = function getLocaleMessage (locale) {
  return looseClone(this._vm.messages[locale])
};

VueI18n.prototype.setLocaleMessage = function setLocaleMessage (locale, message) {
  this._vm.messages[locale] = message;
};

Object.defineProperties( VueI18n.prototype, prototypeAccessors );

VueI18n.install = install;
VueI18n.version = '__VERSION__';

if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(VueI18n);
}

module.exports = VueI18n;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)))

/***/ }),
/* 71 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(114);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(53);

var _keys2 = _interopRequireDefault(_keys);

__webpack_require__(99);

var _vue = __webpack_require__(178);

var _vue2 = _interopRequireDefault(_vue);

var _vueI18n = __webpack_require__(70);

var _vueI18n2 = _interopRequireDefault(_vueI18n);

var _vueRouter = __webpack_require__(177);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _vuex = __webpack_require__(179);

var _vuex2 = _interopRequireDefault(_vuex);

var _dovemaxsdk = __webpack_require__(12);

var _components = __webpack_require__(191);

var _components2 = _interopRequireDefault(_components);

var _App = __webpack_require__(74);

var _App2 = _interopRequireDefault(_App);

var _keenUi = __webpack_require__(9);

var _keenUi2 = _interopRequireDefault(_keenUi);

var _routes = __webpack_require__(52);

var _routes2 = _interopRequireDefault(_routes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.config.devtools = true;

_vue2.default.use(_components2.default);

_vue2.default.use(_vueI18n2.default, {});

window.Vue = _vue2.default;
window.VueI8n = _vueI18n2.default;

var $ = _dovemaxsdk.Util.util.getJQuery$();

var lang = 'zh-CN';
var langJsonFile = './locale/' + lang + '.json';

function ___useES6Fetch(lang, cb) {
  _vue2.default.locale(lang, function () {
    return fetch(langJsonFile, {
      method: 'get',
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json'
      }
    }).then(function (res) {
      return res.json();
    }).then(function (json) {
      if ((0, _keys2.default)(json).length === 0) {
        return _promise2.default.reject(new Error('locale empty !!'));
      }
      return _promise2.default.resolve(json);
    }).catch(function (err) {
      console.error(err);
      return _promise2.default.reject();
    });
  }, function () {
    console.log('set lang....');
    _vue2.default.config.lang = lang;
    cb();
  });
}

function ___useJQueryGet(lang, cb) {
  $.getJSON(langJsonFile, function (json) {
    console.log('set lang....');
    _vue2.default.config.lang = lang;
    var locales = {};
    locales[lang] = json;

    cb(new _vueI18n2.default({
      locale: lang,
      messages: locales
    }));
  }).fail(function (err) {
    console.error(err);
    cb(new _vueI18n2.default({
      locale: 'en-us',
      messages: {}
    }));
  });
}

function main() {
  var bUseES6Fetch = false;
  if (bUseES6Fetch) {
    ___useES6Fetch(lang, startApp);
  } else {
    ___useJQueryGet(lang, startApp);
  }
}

function startApp(i18nObj) {
  _vue2.default.use(_keenUi2.default);

  _vue2.default.use(_vueRouter2.default);
  var router = new _vueRouter2.default({
    routes: _routes2.default.routes,
    linkActiveClass: 'is-active'
  });

  var app = new _vue2.default({
    i18n: i18nObj,
    router: router,
    components: {
      App: _App2.default
    },
    render: function render(h) {
      console.log('start app render ....');
      return h(_App2.default);
    }
  });

  document.title = _routes2.default.SysConfig.appName;
  app.$mount('#app');
}

$(document).ready(function () {
  main();
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {


/* styles */
__webpack_require__(176)

var Component = __webpack_require__(8)(
  /* script */
  __webpack_require__(90),
  /* template */
  __webpack_require__(89),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(8)(
  /* script */
  __webpack_require__(91),
  /* template */
  __webpack_require__(87),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(8)(
  /* script */
  __webpack_require__(92),
  /* template */
  __webpack_require__(85),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(8)(
  /* script */
  __webpack_require__(93),
  /* template */
  __webpack_require__(84),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(8)(
  /* script */
  __webpack_require__(94),
  /* template */
  __webpack_require__(88),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(8)(
  /* script */
  __webpack_require__(95),
  /* template */
  __webpack_require__(82),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 80 */,
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(8)(
  /* script */
  __webpack_require__(97),
  /* template */
  __webpack_require__(83),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('section', {
    staticClass: "page page-app-doc"
  }, [_c('div', {
    staticClass: "page__toolbar page__toolbar-app-doc"
  }, _vm._l((_vm.actionList), function(item, index) {
    return (item.visiable) ? _c('ui-icon-button', {
      key: item.id,
      attrs: {
        "type": item.type,
        "size": item.size,
        "color": item.color
      },
      on: {
        "click": function($event) {
          _vm.onToolBtnClick(index, item)
        }
      }
    }, [_c('span', {
      class: item.icon,
      attrs: {
        "title": _vm.$t(item.tooltip)
      }
    })]) : _vm._e()
  })), _vm._v(" "), _c('div', {
    staticClass: "page__examples page__examples-app-doc"
  }, [_c('div', {
    staticClass: "page__app__welcome"
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.newsList.length <= 0),
      expression: "newsList.length <= 0"
    }],
    staticClass: "page__examples-app-doc__welcome"
  }), _vm._v(" "), _vm._l((_vm.newsList), function(item, index) {
    return _c('ui-alert', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.style.show),
        expression: "item.style.show"
      }],
      key: item,
      class: _vm.getItemStyleClass(item),
      attrs: {
        "dismissible": false,
        "type": item.style.type
      }
    }, [_c('div', {
      staticClass: "page__examples-app-doc__item"
    }, [_c('div', {
      staticClass: "ui-toolbar__top"
    }, [_c('div', {
      staticClass: "ui-toolbar__top__metainfo"
    }, [_c('img', {
      attrs: {
        "src": item.thumb,
        "width": "48",
        "height": "48",
        "viewBox": "0 0 48 48"
      }
    }), _vm._v(" "), _c('strong', {
      staticClass: "ui-toolbar__top__news__title"
    }, [_vm._v(" \n                          " + _vm._s(item.title) + " \n                          "), _c('sup', {
      staticClass: "ui-toolbar__top__news__date"
    }, [_vm._v("\n                          (" + _vm._s(item.date) + ")\n                          ")])])]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__top__metainfo__toolbar"
    }, [_c('ui-icon-button', {
      attrs: {
        "type": "secondary",
        "color": "black",
        "size": "small"
      },
      on: {
        "click": function($event) {
          _vm.onOpenLink(item.link)
        }
      }
    }, [_c('span', {
      staticClass: "fa fa-link fa-lg fa-fw",
      attrs: {
        "title": _vm.$t('pages.welcome.task-item.onOpenLink')
      }
    })])], 1)]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__body"
    }, [_c('p', {
      staticClass: "ui-toolbar__body__news__description"
    }, [_vm._v(_vm._s(item.description))])]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__bottom"
    })])])
  })], 2)])])
},staticRenderFns: []}

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('aside', {
    staticClass: "dove-docs-sidebar"
  }, [_c('div', {
    staticClass: "dove-docs-sidebar__header"
  }, [_c('div', {
    staticClass: "dove-docs-sidebar__header__info"
  }, [_c('span', {
    staticClass: "dove-docs-sidebar__header-product-name"
  }, [_vm._v(_vm._s(_vm.appName))]), _vm._v(" "), _c('a', {
    staticClass: "dove-docs-sidebar__header-version",
    attrs: {
      "href": _vm.homepage,
      "rel": "noopener",
      "target": "_blank",
      "title": "View release notes"
    }
  }, [_vm._v(_vm._s(_vm.version))]), _vm._v(" "), _c('a', {
    staticClass: "dove-docs-sidebar__header-github-link",
    attrs: {
      "href": _vm.homepage,
      "rel": "noopener",
      "target": "_blank",
      "title": "View on HomePage"
    }
  }, [_c('ui-icon', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (false),
      expression: "false"
    }]
  }, [_c('img', {
    attrs: {
      "src": "images/plier.svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  })])], 1)])]), _vm._v(" "), _c('div', {
    staticClass: "dove-docs-sidebar__scrollable"
  }, [_c('ul', {
    staticClass: "dove-docs-sidebar__menu"
  }, _vm._l((_vm.menu), function(section) {
    return _c('li', {
      staticClass: "dove-docs-sidebar__menu-section"
    }, [(section.visible) ? _c('ui-collapsible', {
      staticClass: "dove-docs-sidebar__menu-section-header",
      attrs: {
        "title": _vm.$t(section.title),
        "open": section.isExpand,
        "removeIcon": !section.enableExpand,
        "disabled": !section.enableExpand
      }
    }, [_c('ul', {
      staticClass: "dove-docs-sidebar__menu-section-links"
    }, _vm._l((section.menu), function(item) {
      return _c('li', {
        staticClass: "dove-docs-sidebar__menu-li",
        attrs: {
          "exact": ""
        }
      }, [(item.show) ? _c('router-link', {
        staticClass: "dove-docs-sidebar__menu-item",
        attrs: {
          "exact": "",
          "to": item.path,
          "title": _vm.$t(item.tip)
        }
      }, [_c('ui-icon', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: (false),
          expression: "false"
        }]
      }, [_c('img', {
        attrs: {
          "src": item.icon,
          "width": "16",
          "height": "16",
          "viewBox": "0 0 16 16"
        }
      })]), _vm._v(" "), _c('span', {
        staticClass: "dove-docs-sidebar__menu-item__caption"
      }, [_vm._v(_vm._s(_vm.$t(item.title)))])], 1) : _vm._e()], 1)
    }))]) : _vm._e()], 1)
  }))])])
},staticRenderFns: []}

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('section', {
    staticClass: "page page-app-doc"
  }, [_c('div', {
    staticClass: "page__toolbar page__toolbar-app-doc"
  }, [_vm._l((_vm.actionList), function(item, index) {
    return (item.visiable) ? _c('ui-icon-button', {
      key: item.id,
      attrs: {
        "type": item.type,
        "size": item.size,
        "color": item.color
      },
      on: {
        "click": function($event) {
          _vm.onToolBtnClick(index, item)
        }
      }
    }, [_c('span', {
      class: item.icon,
      attrs: {
        "title": _vm.$t(item.tooltip)
      }
    })]) : _vm._e()
  }), _vm._v(" "), _c('ui-confirm', {
    ref: _vm.confirmDialog.ref,
    attrs: {
      "autofocus": _vm.confirmDialog.autofocus,
      "confirm-button-text": _vm.confirmDialog.confirmButtonText,
      "deny-button-text": _vm.confirmDialog.denyButtonText,
      "title": _vm.confirmDialog.title
    },
    on: {
      "confirm": _vm.onConfirmDialogConfirm,
      "deny": _vm.onConfirmDialogDeny
    }
  }, [_vm._v("\n            " + _vm._s(_vm.confirmDialog.content) + "\n        ")])], 2), _vm._v(" "), _c('div', {
    staticClass: "page__examples page__examples-app-doc"
  }, [_c('svg', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.taskList.length <= 0),
      expression: "taskList.length <= 0"
    }],
    staticClass: "page__examples-app-doc__welcome",
    attrs: {
      "id": _vm.welcomeContentID
    }
  }), _vm._v(" "), _vm._l((_vm.taskList), function(item, index) {
    return _c('ui-alert', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.style.show),
        expression: "item.style.show"
      }],
      key: item,
      class: _vm.getItemStyleClass(item),
      attrs: {
        "removeIcon": "",
        "type": item.style.type
      },
      on: {
        "dismiss": function($event) {
          _vm.onRemoveTaskItem(item, index)
        }
      }
    }, [_c('div', {
      staticClass: "page__examples-app-doc__item"
    }, [_c('div', {
      staticClass: "ui-toolbar__top"
    }, [_c('div', {
      staticClass: "ui-toolbar__top__metainfo"
    }, [_c('img', {
      attrs: {
        "src": item.thumb,
        "width": "48",
        "height": "48",
        "viewBox": "0 0 48 48"
      }
    }), _vm._v(" "), _c('strong', {
      staticClass: "ui-toolbar__top__fileName",
      attrs: {
        "title": _vm.$t('pages.remove.task-item.file-name') + item.name
      }
    }, [_vm._v(" \n                            " + _vm._s(item.name) + " \n                            "), _c('sup', {
      staticClass: "ui-toolbar__top__fileSize",
      attrs: {
        "title": _vm.$t('pages.remove.task-item.file-size') + item.size
      }
    }, [_vm._v("\n                            (" + _vm._s(item.size) + ")\n                            ")])])]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__top__metainfo__toolbar"
    }, [(item.stateInfo.state > 0) ? _c('ui-icon-button', {
      attrs: {
        "type": "secondary",
        "color": "white",
        "size": "small"
      },
      on: {
        "click": function($event) {
          _vm.onOpenParentDir(item.fixOutDir)
        }
      }
    }, [_c('span', {
      staticClass: "fa fa-folder-open-o fa-lg fa-fw",
      attrs: {
        "title": _vm.$t('pages.remove.task-item.open-parent-dir')
      }
    })]) : _vm._e(), _vm._v(" "), (item.stateInfo.state > 0) ? _c('ui-icon-button', {
      attrs: {
        "type": "secondary",
        "color": "white",
        "size": "small"
      },
      on: {
        "click": function($event) {
          _vm.onPreviewFile(item.fixpath)
        }
      }
    }, [_c('span', {
      staticClass: "fa fa-eye fa-lg fa-fw",
      attrs: {
        "title": _vm.$t('pages.remove.task-item.review-in-file')
      }
    })]) : _vm._e()], 1)]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__body"
    }, [_c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.stateInfo.state < 0),
        expression: "item.stateInfo.state < 0"
      }],
      class: ['ui-toolbar__top__taskMessage', item.stateInfo.state < 0 ? 'task-item-has-error' : ''],
      attrs: {
        "title": item.stateInfo.message
      }
    }, [_vm._v("\n                        " + _vm._s(item.stateInfo.message) + "\n                    ")]), _vm._v(" "), _c('span', {
      staticClass: "ui-toolbar__body__filePath",
      attrs: {
        "title": _vm.$t('pages.remove.task-item.file-path') + item.path
      }
    }, [_vm._v(_vm._s(item.path))])]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__bottom"
    }, [_c('ui-progress-linear', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (_vm.getImageProgressShow(item)),
        expression: "getImageProgressShow(item)"
      }],
      attrs: {
        "color": _vm.getItemProgressStyle(item),
        "type": "determinate",
        "progress": item.progress,
        "title": _vm.$t('pages.remove.task-item.progress') + item.progress
      }
    })], 1)])])
  })], 2), _vm._v(" "), (_vm.taskList.length >= 0) ? _c('div', {
    class: ['page__footbar page__footbar-app-doc', {
      transferNormal: _vm.transferIsNormal
    }, {
      working: _vm.isRemoveWorking
    }]
  }, [_c('span', [_vm._v(_vm._s(_vm.$t('pages.remove.footbar.fileCount')) + " : " + _vm._s(_vm.taskList.length) + " ")]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.$t('pages.remove.footbar.state')) + " : " + _vm._s(_vm.isRemoveWorking ? _vm.$t('pages.remove.footbar.isRemoveWorking') : _vm.$t('pages.remove.footbar.isWaiting')) + " ")]), _vm._v(" "), _c('i', {
    class: [_vm.isRemoveWorking ? 'fa fa-spinner fa-spin fa-lg fa-fw' : 'fa fa-lg fa-fw']
  }), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.$t('pages.remove.footbar.transferState')) + " : " + _vm._s(_vm.transferIsNormal ? _vm.$t('pages.remove.footbar.transferIsNormal') : _vm.$t('pages.remove.footbar.transferIsFault')) + " ")])]) : _vm._e()])
},staticRenderFns: []}

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('section', {
    staticClass: "page page-app-doc"
  }, [_c('div', {
    staticClass: "page__toolbar page__toolbar-app-doc"
  }, [_vm._l((_vm.actionList), function(item, index) {
    return (item.visiable) ? _c('ui-icon-button', {
      key: item.id,
      attrs: {
        "type": item.type,
        "size": item.size,
        "color": item.color
      },
      on: {
        "click": function($event) {
          _vm.onToolBtnClick(index, item)
        }
      }
    }, [_c('span', {
      class: item.icon,
      attrs: {
        "title": _vm.$t(item.tooltip)
      }
    })]) : _vm._e()
  }), _vm._v(" "), _c('ui-confirm', {
    ref: _vm.confirmDialog.ref,
    attrs: {
      "autofocus": _vm.confirmDialog.autofocus,
      "confirm-button-text": _vm.confirmDialog.confirmButtonText,
      "deny-button-text": _vm.confirmDialog.denyButtonText,
      "title": _vm.confirmDialog.title
    },
    on: {
      "confirm": _vm.onConfirmDialogConfirm,
      "deny": _vm.onConfirmDialogDeny
    }
  }, [_vm._v("\n            " + _vm._s(_vm.confirmDialog.content) + "\n        ")]), _vm._v(" "), _c('ui-confirm', {
    ref: _vm.exifConfigDialog.ref,
    attrs: {
      "autofocus": _vm.exifConfigDialog.autofocus,
      "confirm-button-text": _vm.exifConfigDialog.confirmButtonText,
      "deny-button-text": _vm.exifConfigDialog.denyButtonText,
      "title": _vm.exifConfigDialog.title
    },
    on: {
      "confirm": _vm.onExifConfigDialogConfirm,
      "deny": _vm.onExifConfigDialogDeny
    }
  }, [_vm._v("\n            " + _vm._s(_vm.exifConfigDialog.content) + "\n            "), _c('dovemxui-exif-info', {
    attrs: {
      "exif": _vm.exifConfigDialog.exifInfo
    }
  })], 1)], 2), _vm._v(" "), _c('div', {
    staticClass: "page__examples page__examples-app-doc"
  }, [_c('svg', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.taskList.length <= 0),
      expression: "taskList.length <= 0"
    }],
    staticClass: "page__examples-app-doc__welcome",
    attrs: {
      "id": _vm.welcomeContentID
    }
  }), _vm._v(" "), _vm._l((_vm.taskList), function(item, index) {
    return _c('ui-alert', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.style.show),
        expression: "item.style.show"
      }],
      key: item,
      class: _vm.getItemStyleClass(item),
      attrs: {
        "removeIcon": "",
        "type": item.style.type
      },
      on: {
        "dismiss": function($event) {
          _vm.onRemoveTaskItem(item, index)
        }
      }
    }, [_c('div', {
      staticClass: "page__examples-app-doc__item"
    }, [_c('div', {
      staticClass: "ui-toolbar__top"
    }, [_c('div', {
      staticClass: "ui-toolbar__top__metainfo"
    }, [_c('img', {
      attrs: {
        "src": item.thumb,
        "width": "48",
        "height": "48",
        "viewBox": "0 0 48 48"
      }
    }), _vm._v(" "), _c('strong', {
      staticClass: "ui-toolbar__top__fileName",
      attrs: {
        "title": _vm.$t('pages.modify.task-item.file-name') + item.name
      }
    }, [_vm._v(" \n                            " + _vm._s(item.name) + " \n                            "), _c('sup', {
      staticClass: "ui-toolbar__top__fileSize",
      attrs: {
        "title": _vm.$t('pages.modify.task-item.file-size') + item.size
      }
    }, [_vm._v("\n                            (" + _vm._s(item.size) + ")\n                            ")])])]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__top__metainfo__toolbar"
    }, [_c('ui-select', {
      attrs: {
        "placeholder": _vm.planPlaceHolder,
        "options": _vm.planList,
        "hasSearch": ""
      },
      model: {
        value: (item.selectPlanModel),
        callback: function($$v) {
          item.selectPlanModel = $$v
        }
      }
    }), _vm._v(" "), _c('ui-icon-button', {
      attrs: {
        "type": "secondary",
        "color": "black",
        "size": "small"
      },
      on: {
        "click": function($event) {
          _vm.onSettingPlan(item)
        }
      }
    }, [_c('span', {
      staticClass: "fa fa-pencil fa-lg fa-fw",
      attrs: {
        "title": _vm.$t('pages.modify.task-item.setting-plan')
      }
    })]), _vm._v(" "), (item.stateInfo.state > 0) ? _c('ui-icon-button', {
      attrs: {
        "type": "secondary",
        "color": "white",
        "size": "small"
      },
      on: {
        "click": function($event) {
          _vm.onOpenParentDir(item.fixOutDir)
        }
      }
    }, [_c('span', {
      staticClass: "fa fa-folder-open-o fa-lg fa-fw",
      attrs: {
        "title": _vm.$t('pages.modify.task-item.open-parent-dir')
      }
    })]) : _vm._e(), _vm._v(" "), (item.stateInfo.state > 0) ? _c('ui-icon-button', {
      attrs: {
        "type": "secondary",
        "color": "white",
        "size": "small"
      },
      on: {
        "click": function($event) {
          _vm.onPreviewFile(item.fixpath)
        }
      }
    }, [_c('span', {
      staticClass: "fa fa-eye fa-lg fa-fw",
      attrs: {
        "title": _vm.$t('pages.modify.task-item.review-in-file')
      }
    })]) : _vm._e()], 1)]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__body"
    }, [_c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.stateInfo.state < 0),
        expression: "item.stateInfo.state < 0"
      }],
      class: ['ui-toolbar__top__taskMessage', item.stateInfo.state < 0 ? 'task-item-has-error' : ''],
      attrs: {
        "title": item.stateInfo.message
      }
    }, [_vm._v("\n                        " + _vm._s(item.stateInfo.message) + "\n                    ")]), _vm._v(" "), _c('span', {
      staticClass: "ui-toolbar__body__filePath",
      attrs: {
        "title": _vm.$t('pages.modify.task-item.file-path') + item.path
      }
    }, [_vm._v(_vm._s(item.path))])]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__bottom"
    }, [_c('ui-progress-linear', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (_vm.getImageProgressShow(item)),
        expression: "getImageProgressShow(item)"
      }],
      attrs: {
        "color": _vm.getItemProgressStyle(item),
        "type": "determinate",
        "progress": item.progress,
        "title": _vm.$t('pages.modify.task-item.progress') + item.progress
      }
    })], 1)])])
  })], 2), _vm._v(" "), (_vm.taskList.length >= 0) ? _c('div', {
    class: ['page__footbar page__footbar-app-doc', {
      transferNormal: _vm.transferIsNormal
    }, {
      working: _vm.isModifyWorking
    }]
  }, [_c('span', [_vm._v(_vm._s(_vm.$t('pages.modify.footbar.fileCount')) + " : " + _vm._s(_vm.taskList.length) + " ")]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.$t('pages.modify.footbar.state')) + " : " + _vm._s(_vm.isModifyWorking ? _vm.$t('pages.modify.footbar.isModifyWorking') : _vm.$t('pages.modify.footbar.isWaiting')) + " ")]), _vm._v(" "), _c('i', {
    class: [_vm.isModifyWorking ? 'fa fa-spinner fa-spin fa-lg fa-fw' : 'fa fa-lg fa-fw']
  }), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.$t('pages.modify.footbar.transferState')) + " : " + _vm._s(_vm.transferIsNormal ? _vm.$t('pages.modify.footbar.transferIsNormal') : _vm.$t('pages.modify.footbar.transferIsFault')) + " ")])]) : _vm._e()])
},staticRenderFns: []}

/***/ }),
/* 86 */,
/* 87 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c("div")
},staticRenderFns: []}

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('section', {
    staticClass: "page page-app-doc"
  }, [_c('div', {
    staticClass: "page__toolbar page__toolbar-app-doc"
  }, [_vm._l((_vm.actionList), function(item, index) {
    return (item.visiable) ? _c('ui-icon-button', {
      key: item.id,
      attrs: {
        "type": item.type,
        "size": item.size,
        "color": item.color
      },
      on: {
        "click": function($event) {
          _vm.onToolBtnClick(index, item)
        }
      }
    }, [_c('span', {
      class: item.icon,
      attrs: {
        "title": _vm.$t(item.tooltip)
      }
    })]) : _vm._e()
  }), _vm._v(" "), _c('ui-confirm', {
    ref: _vm.confirmDialog.ref,
    attrs: {
      "autofocus": _vm.confirmDialog.autofocus,
      "confirm-button-text": _vm.confirmDialog.confirmButtonText,
      "deny-button-text": _vm.confirmDialog.denyButtonText,
      "title": _vm.confirmDialog.title
    },
    on: {
      "confirm": _vm.onConfirmDialogConfirm,
      "deny": _vm.onConfirmDialogDeny
    }
  }, [_vm._v("\n            " + _vm._s(_vm.confirmDialog.content) + "\n        ")])], 2), _vm._v(" "), _c('div', {
    staticClass: "page__examples page__examples-app-doc"
  }, [_c('svg', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.taskList.length <= 0),
      expression: "taskList.length <= 0"
    }],
    staticClass: "page__examples-app-doc__welcome",
    attrs: {
      "id": _vm.welcomeContentID
    }
  }), _vm._v(" "), _vm._l((_vm.taskList), function(item, index) {
    return _c('ui-alert', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.style.show),
        expression: "item.style.show"
      }],
      key: item,
      class: _vm.getItemStyleClass(item),
      attrs: {
        "removeIcon": "",
        "type": item.style.type
      },
      on: {
        "dismiss": function($event) {
          _vm.onRemoveTaskItem(item, index)
        }
      }
    }, [_c('div', {
      staticClass: "page__examples-app-doc__item"
    }, [_c('div', {
      staticClass: "ui-toolbar__top"
    }, [_c('div', {
      staticClass: "ui-toolbar__top__metainfo"
    }, [_c('img', {
      attrs: {
        "src": item.thumb,
        "width": "48",
        "height": "48",
        "viewBox": "0 0 48 48"
      }
    }), _vm._v(" "), _c('strong', {
      staticClass: "ui-toolbar__top__fileName",
      attrs: {
        "title": _vm.$t('pages.repair.task-item.file-name') + item.name
      }
    }, [_vm._v(" \n                            " + _vm._s(item.name) + " \n                            "), _c('sup', {
      staticClass: "ui-toolbar__top__fileSize",
      attrs: {
        "title": _vm.$t('pages.repair.task-item.file-size') + item.size
      }
    }, [_vm._v("\n                            (" + _vm._s(item.size) + ")\n                            ")])])]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__top__metainfo__toolbar"
    }, [(item.stateInfo.state > 0) ? _c('ui-icon-button', {
      attrs: {
        "type": "secondary",
        "color": "white",
        "size": "small"
      },
      on: {
        "click": function($event) {
          _vm.onOpenParentDir(item.fixOutDir)
        }
      }
    }, [_c('span', {
      staticClass: "fa fa-folder-open-o fa-lg fa-fw",
      attrs: {
        "title": _vm.$t('pages.repair.task-item.open-parent-dir')
      }
    })]) : _vm._e(), _vm._v(" "), (item.stateInfo.state > 0) ? _c('ui-icon-button', {
      attrs: {
        "type": "secondary",
        "color": "white",
        "size": "small"
      },
      on: {
        "click": function($event) {
          _vm.onPreviewFile(item.fixpath)
        }
      }
    }, [_c('span', {
      staticClass: "fa fa-eye fa-lg fa-fw",
      attrs: {
        "title": _vm.$t('pages.repair.task-item.review-in-file')
      }
    })]) : _vm._e()], 1)]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__body"
    }, [_c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.stateInfo.state < 0),
        expression: "item.stateInfo.state < 0"
      }],
      class: ['ui-toolbar__top__taskMessage', item.stateInfo.state < 0 ? 'task-item-has-error' : ''],
      attrs: {
        "title": item.stateInfo.message
      }
    }, [_vm._v("\n                        " + _vm._s(item.stateInfo.message) + "\n                    ")]), _vm._v(" "), _c('span', {
      staticClass: "ui-toolbar__body__filePath",
      attrs: {
        "title": _vm.$t('pages.repair.task-item.file-path') + item.path
      }
    }, [_vm._v(_vm._s(item.path))])]), _vm._v(" "), _c('div', {
      staticClass: "ui-toolbar__bottom"
    }, [_c('ui-progress-linear', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (_vm.getImageProgressShow(item)),
        expression: "getImageProgressShow(item)"
      }],
      attrs: {
        "color": _vm.getItemProgressStyle(item),
        "type": "determinate",
        "progress": item.progress,
        "title": _vm.$t('pages.repair.task-item.progress') + item.progress
      }
    })], 1)])])
  })], 2), _vm._v(" "), (_vm.taskList.length >= 0) ? _c('div', {
    class: ['page__footbar page__footbar-app-doc', {
      transferNormal: _vm.transferIsNormal
    }, {
      working: _vm.isFixworking
    }]
  }, [_c('span', [_vm._v(_vm._s(_vm.$t('pages.repair.footbar.fileCount')) + " : " + _vm._s(_vm.taskList.length) + " ")]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.$t('pages.repair.footbar.state')) + " : " + _vm._s(_vm.isFixworking ? _vm.$t('pages.repair.footbar.isFixWorking') : _vm.$t('pages.repair.footbar.isWaiting')) + " ")]), _vm._v(" "), _c('i', {
    class: [_vm.isFixworking ? 'fa fa-spinner fa-spin fa-lg fa-fw' : 'fa fa-lg fa-fw']
  }), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.$t('pages.repair.footbar.transferState')) + " : " + _vm._s(_vm.transferIsNormal ? _vm.$t('pages.repair.footbar.transferIsNormal') : _vm.$t('pages.repair.footbar.transferIsFault')) + " ")])]) : _vm._e()])
},staticRenderFns: []}

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dove-docs",
    attrs: {
      "id": "app"
    }
  }, [_c('Sidebar', {
    staticClass: "is-desktop"
  }), _vm._v(" "), _c('transition', {
    attrs: {
      "name": "transition-fade"
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showSidebar),
      expression: "showSidebar"
    }],
    staticClass: "dove-docs-mobile-sidebar__backdrop",
    on: {
      "click": function($event) {
        _vm.showSidebar = false
      }
    }
  })]), _vm._v(" "), _c('transition', {
    attrs: {
      "name": "transition-slide"
    }
  }, [_c('sidebar', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showSidebar),
      expression: "showSidebar"
    }],
    staticClass: "is-mobile"
  })], 1), _vm._v(" "), _c('section', {
    staticClass: "dove-docs-content"
  }, [_c('div', {
    staticClass: "dove-docs-content__toolbar"
  }, [_c('div', {
    staticClass: "dove-docs-content__toolbar-content"
  }, [_c('ui-icon-button', {
    staticClass: "dove-docs-content__toolbar-menu-button",
    attrs: {
      "color": "white",
      "icon": "",
      "type": "clear"
    },
    on: {
      "click": function($event) {
        _vm.showSidebar = true
      }
    }
  }), _vm._v(" "), _c('h1', {
    staticClass: "dove-docs-content__toolbar-title"
  }, [_vm._v(_vm._s(_vm.$t(_vm.$route.meta.title)))]), _vm._v(" "), _c('p', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.$route.meta.tipAsSubTitle),
      expression: "$route.meta.tipAsSubTitle"
    }],
    staticClass: "dove-docs-content__toolbar-title__sub"
  }, [_vm._v(" >> " + _vm._s(_vm.$t(_vm.$route.meta.tip)))]), _vm._v(" "), (_vm.$route.meta.sourceUrl) ? _c('a', {
    staticClass: "dove-docs-content__toolbar-action",
    attrs: {
      "rel": "noopener",
      "target": "_blank",
      "href": 'https://github.com/JosephusPaye/Keen-UI/blob/master/' + _vm.$route.meta.sourceUrl
    }
  }, [_vm._v("View Source")]) : _vm._e()], 1)]), _vm._v(" "), _c('div', {
    ref: "pageContent",
    staticClass: "dove-docs-content__page-content"
  }, [_c('router-view')], 1)])], 1)
},staticRenderFns: []}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _vueI18n = __webpack_require__(70);

var _vueI18n2 = _interopRequireDefault(_vueI18n);

var _keenUi = __webpack_require__(9);

var _Sidebar = __webpack_require__(81);

var _Sidebar2 = _interopRequireDefault(_Sidebar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    data: function data() {
        return {
            showSidebar: false
        };
    },


    components: {
        VueI18n: _vueI18n2.default,
        UiIcon: _keenUi.UiIcon,
        Sidebar: _Sidebar2.default
    },

    beforeCreate: function beforeCreate() {
        console.log('App.Vue');
    }
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(24);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _dovemaxsdk = __webpack_require__(12);

var _keenUi = __webpack_require__(9);

var _components = __webpack_require__(191);

var _components2 = _interopRequireDefault(_components);

var _transfer = __webpack_require__(23);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var baseID = "__page__modify__action__";
var baseIDIndex = -1;

var taskList = [];
var taskPrefix = 'modify-page-image-id-' + _dovemaxsdk._.now();

var Task = function Task(thumb, name, path, size) {
    (0, _classCallCheck3.default)(this, Task);

    this.id = _dovemaxsdk._.uniqueId(taskPrefix);
    this.thumb = thumb;
    this.name = name;
    this.path = path;
    this.size = size;
    this.style = {
        show: true,
        type: "success"
    };

    this.selectPlanModel = '';
    this.exifConfig = {};
    this.isworking = false;
    this.progress = 0;
    this.fixOutDir = "";
    this.fixpath = "";
    this.stateInfo = {
        state: 0,
        message: "" };
};

exports.default = {
    data: function data() {
        console.log("Modify.vue call data()");
        return {
            welcomeContentID: 'page__modify__welcome__id',
            planSelectModel: '',
            taskList: taskList,
            taskID2taskObj: {},
            isModifyWorking: false,
            transferIsNormal: _transfer.Transfer.isRunning,
            progressInterval: null,
            confirmDialog: {
                ref: 'default',
                autofocus: 'none',
                confirmButtonText: 'Confirm',
                denyButtonText: 'Deny',
                title: '',
                content: '',
                callbackConfirm: function callbackConfirm() {},
                callbackDeny: function callbackDeny() {}
            },
            exifConfigDialog: {
                ref: 'exifConfigDialog',
                autofocus: 'none',
                confirmButtonText: 'Confirm',
                denyButtonText: 'Deny',
                title: '',
                content: '',
                exifInfo: {},
                callbackConfirm: function callbackConfirm() {},
                callbackDeny: function callbackDeny() {}
            },
            curFixTaskID: null };
    },
    beforeCreate: function beforeCreate() {
        var that = this;
        console.log('Modify.vue beforeCreate');

        _transfer.Transfer.frontAgent.registerOnChannelFault(function () {
            that.onTransferIsFault();
        });

        _transfer.Transfer.frontAgent.registerOnFinishBuildChannel(function () {
            that.onTransferIsNoraml();
        });
    },
    mounted: function mounted() {
        this.drawWelcome();
    },
    beforeDestroy: function beforeDestroy() {
        clearInterval(this.progressInterval);
    },


    computed: {
        actionList: function actionList() {
            var that = this;
            return [{ id: 'action-import', visiable: true, color: "black", icon: "fa fa-file-image-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.modify.toolbar.import" }, { id: 'action-importDir', visiable: true, color: "black", icon: "fa fa-folder-open-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.modify.toolbar.importDir" }, { id: 'action-remove', visiable: true, color: "black", icon: "fa fa-trash-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.modify.toolbar.remove" }, { id: 'action-choicePlan', visiable: true, color: "primary", icon: "fa fa-database fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.modify.toolbar.choicePlan" }, { id: 'action-do', visiable: !that.isModifyWorking, color: "green", icon: "fa fa-legal fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.modify.toolbar.fix" }, { id: 'action-stop', visiable: that.isModifyWorking, color: "red", icon: "fa fa-hand-paper-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.modify.toolbar.chancel" }];
        },
        planPlaceHolder: function planPlaceHolder() {
            var that = this;
            return that.$t('pages.modify.plans.default');
        },
        planList: function planList() {
            var that = this;

            var list = [];
            list.push({
                label: that.$t('pages.modify.plans.default'),
                value: 0
            });

            for (var i = 0; i < 20; ++i) {
                list.push({
                    label: i + '-Exif',
                    value: i + 1
                });
            }

            return list;
        }
    },

    methods: {
        onTransferIsNoraml: function onTransferIsNoraml() {
            var that = this;
            that.transferIsNormal = true;
        },
        onTransferIsFault: function onTransferIsFault() {
            var that = this;
            that.transferIsNormal = false;
            that.isModifyWorking = false;

            that.stopDo();
        },
        drawWelcome: function drawWelcome() {
            var that = this;
            var SnapRef = _dovemaxsdk.Util.util.getSnapSVG$();
            if (SnapRef) {
                var s = SnapRef('#' + that.welcomeContentID);

                var rect = s.rect('8%', '8%', '84%', '84%', 16);
                rect.attr({
                    fill: "none",
                    "fill-opacity": 0.5,
                    "stroke-linecap": "round",
                    "stroke-linejoin": "bevel",
                    "stroke-dasharray": "5,5",
                    stroke: "#adadad",
                    strokeWidth: 1
                });

                var description = s.text('12%', '16%', that.$t('pages.modify.welcome.description'));
                var step1 = s.text('15%', '26%', that.$t('pages.modify.welcome.step1'));
                var step2 = s.text('15%', '36%', that.$t('pages.modify.welcome.step2'));
                var step3 = s.text('15%', '46%', that.$t('pages.modify.welcome.step3'));
                var step4 = s.text('15%', '56%', that.$t('pages.modify.welcome.step4'));

                description.attr({
                    "font-weight": "bold"
                });
            }
        },
        getItemStyleClass: function getItemStyleClass(item) {
            var _styleClass = ['page__modify__task__item'];
            if (item.stateInfo) {

                if (item.stateInfo.state < 0) {
                    _styleClass.push('isFixFailed');
                }
                if (item.stateInfo.state > 0) {
                    _styleClass.push('isFixedSuccess');
                }
            }

            return _styleClass;
        },
        getItemProgressStyle: function getItemProgressStyle(item) {
            var that = this;
            var progressStyle = 'black';
            if (item.stateInfo) {
                if (item.stateInfo.state < 0) progressStyle = 'accent';
                if (item.stateInfo.state > 0) progressStyle = 'primary';
            }

            return progressStyle;
        },
        getImageProgressShow: function getImageProgressShow(item) {
            return item.isworking;
        },
        onConfirmDialogConfirm: function onConfirmDialogConfirm() {
            var that = this;
            var fn = that.confirmDialog.callbackConfirm;
            fn && fn();
        },
        onConfirmDialogDeny: function onConfirmDialogDeny() {
            var that = this;
            var fn = that.confirmDialog.callbackDeny;
            fn && fn();
        },
        onExifConfigDialogConfirm: function onExifConfigDialogConfirm() {
            var that = this;
            var fn = that.exifConfigDialog.callbackConfirm;
            fn && fn();
        },
        onExifConfigDialogDeny: function onExifConfigDialogDeny() {
            var that = this;
            var fn = that.exifConfigDialog.callbackDeny;
            fn && fn();
        },
        onToolBtnClick: function onToolBtnClick(index, item) {
            console.log('onToolBtnClick', index);

            if (item.id === 'action-import') {
                this.onBtnImportFilesClick();
            } else if (item.id === 'action-importDir') {
                this.onBtnImportDirClick();
            } else if (item.id === 'action-remove') {
                this.onBtnRemoveAllClick();
            } else if (item.id === 'action-do') {
                this.onBtnDoClick();
            } else if (item.id === 'action-stop') {
                this.onBtnStopDoClick();
            }
        },
        onBtnImportFilesClick: function onBtnImportFilesClick() {
            var that = this;

            console.log("-------------------- call import files");

            _dovemaxsdk.BS.b$.importFiles({
                title: this.$t('pages.modify.dialog-import-images.title'),
                prompt: this.$t('pages.modify.dialog-import-images.prompt'),
                allowMulSelection: true,
                types: [] }, function () {
                _dovemaxsdk._.each([{ fileName: 'RAW_NIKON_D7100.NEF', filePath: 'D:\\TestResource\\exif_sample_images\\Nikon\\corrupted\\RAW_NIKON_D7100.NEF', fileSize: '27.5MB' }, { fileName: 'YDSC_0021.NEF', filePath: 'D:\\TestResource\\exif_sample_images\\Nikon\\corrupted\\YDSC_0021.NEF', fileSize: '10.7MB' }], function (ele) {
                    var taskObj = new Task("images/picture.svg", ele.fileName, ele.filePath, ele.fileSize);
                    that.taskList.push(taskObj);
                    that.taskID2taskObj[taskObj.id] = taskObj;
                });

                return;

                for (var i = 0; i < 50; ++i) {
                    var taskObj = new Task("images/picture.svg", "Images" + i, "/url/image" + i, i + '.2MB');
                    that.taskList.push(taskObj);
                    that.taskID2taskObj[taskObj.id] = taskObj;
                }
            }, function (data) {
                if (data.success) {
                    var imageFiles = data.filesArray;
                    imageFiles.forEach(function (fileObj, dinx) {
                        var taskObj = new Task("images/picture.svg", fileObj.fileName, fileObj.filePath, fileObj.fileSizeStr);
                        that.taskList.push(taskObj);
                        that.taskID2taskObj[taskObj.id] = taskObj;
                    });
                }
            });
        },
        onBtnImportDirClick: function onBtnImportDirClick() {
            var that = this;

            console.log("-------------------- call import dir");

            _dovemaxsdk.BS.b$.selectDir({
                title: this.$t('pages.modify.dialog-import-dir-images.title'),
                prompt: this.$t('pages.modify.dialog-import-dir-images.prompt'),
                allowMulSelection: true
            }, function () {
                for (var i = 0; i < 5; ++i) {
                    var taskObj = new Task("images/folder.svg", "ImagesDir" + i, "/url/imageDir" + i, i + '22.2MB');
                    that.taskList.push(taskObj);
                    that.taskID2taskObj[taskObj.id] = taskObj;
                }
            }, function (data) {
                if (data.success) {
                    var imageFiles = data.filesArray;
                    imageFiles.forEach(function (fileObj, dinx) {
                        var taskObj = new Task("images/picture.svg", fileObj.fileName, fileObj.filePath, fileObj.fileSizeStr);
                        that.taskList.push(taskObj);
                        that.taskID2taskObj[taskObj.id] = taskObj;
                    });
                }
            });
        },
        onBtnRemoveAllClick: function onBtnRemoveAllClick() {
            var that = this;

            if (that.taskList.length > 0) {
                var cdg = that.confirmDialog;
                cdg.title = that.$t('pages.modify.dialog-confirm-remove-all.title');
                cdg.content = that.$t('pages.modify.dialog-confirm-remove-all.message');
                cdg.confirmButtonText = that.$t('pages.modify.dialog-confirm-remove-all.btnConfirm');
                cdg.denyButtonText = that.$t('pages.modify.dialog-confirm-remove-all.btnDeny');

                var dialog = that.$refs[cdg.ref];
                cdg.callbackConfirm = function () {
                    that.stopDo();
                    that.taskList.splice(0, that.taskList.length);
                };
                dialog.open();
            }
        },
        onBtnDoClick: function onBtnDoClick() {
            var that = this;

            if (that.taskList.length === 0) {
                return _dovemaxsdk.BS.b$.Notice.alert({
                    message: that.$t('pages.modify.notice-no-items.message')
                });
            }

            console.log("---------------------- call export dir");
            _dovemaxsdk.BS.b$.selectOutDir({
                title: that.$t('pages.modify.dialog-select-outdir.title'),
                prompt: that.$t('pages.modify.dialog-select-outdir.prompt'),
                canCreateDir: true
            }, function () {
                that.startDo('D:\\TestResource\\exif_sample_images\\Nikon\\corrupted_output');
            }, function (data) {
                if (data.success) {
                    var outDir = data.filePath;
                    that.startDo(outDir);
                }
            });
        },
        onBtnStopDoClick: function onBtnStopDoClick() {
            var that = this;

            if (that.isModifyWorking) {
                var cdg = that.confirmDialog;
                cdg.title = that.$t('pages.modify.dialog-confirm-stop-fix.title');
                cdg.content = that.$t('pages.modify.dialog-confirm-stop-fix.message');
                cdg.confirmButtonText = that.$t('pages.modify.dialog-confirm-stop-fix.btnConfirm');
                cdg.denyButtonText = that.$t('pages.modify.dialog-confirm-stop-fix.btnDeny');

                var dialog = that.$refs[cdg.ref];
                cdg.callbackConfirm = function () {
                    that.stopDo();
                };
                dialog.open();
            }
        },
        startDo: function startDo(outDir) {
            var that = this;

            var srcImagesMap = {};
            _dovemaxsdk._.each(that.taskList, function (taskObj, index) {
                srcImagesMap[taskObj.id] = taskObj.path;
            });

            that.curFixTaskID = _dovemaxsdk._.uniqueId(taskPrefix + 'task-');
            _transfer.Transfer.Tools.RemoveExifInfo.run({
                taskID: that.curFixTaskID,
                data: {
                    src: srcImagesMap,
                    outputDir: outDir || _dovemaxsdk.BS.b$.App.getTempDir()
                },
                lang: Vue.config.lang
            }, function (data) {
                if (data.msg_type === 's_task_exec_running') {
                    that.isModifyWorking = true;
                } else if (data.msg_type === 's_task_exec_feedback') {
                    var dataList = data.content;
                    that.isModifyWorking = dataList.length > 0;
                    _dovemaxsdk._.each(dataList, function (ele) {
                        var curImageTaskObj = that.taskID2taskObj[ele.id];
                        if (curImageTaskObj) {
                            curImageTaskObj.isworking = ele.progress >= 100 ? false : true;
                            curImageTaskObj.progress = ele.progress >= 100 ? 100 : ele.progress;
                            curImageTaskObj.stateInfo.state = ele.state;
                            curImageTaskObj.stateInfo.message = ele.message || '';
                        }
                    });
                } else if (data.msg_type === 's_task_exec_result') {}
            });
        },
        stopDo: function stopDo() {
            var notice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            var that = this;

            var srcImagesMap = {};
            _dovemaxsdk._.each(that.taskList, function (taskObj, index) {
                taskObj.isworking = false;

                srcImagesMap[taskObj.id] = taskObj.path;
            });

            if (!notice) return;
            if (_dovemaxsdk._.keys(srcImagesMap).length > 0 && that.isModifyWorking) {
                _transfer.Transfer.Tools.RemoveExifInfo.stop({
                    taskID: that.curFixTaskID,
                    data: {
                        src: srcImagesMap
                    }
                });
            }
        },
        __removeTaskItem: function __removeTaskItem(item, index) {
            var that = this;
            item.isworking = false;

            item.progress = 0;
            item.stateInfo = 0;
            that.taskID2taskObj[item.id] = null;

            that.taskList.splice(index, 1);
        },
        onRemoveTaskItem: function onRemoveTaskItem(item, index) {
            console.log('item: ', item, 'index: ', index);
            var that = this;

            if (item.isworking) {
                var srcImagesMap = {};
                srcImagesMap[item.id] = item.path;
                _transfer.Transfer.Tools.RemoveExifInfo.stop({
                    taskID: that.curFixTaskID,
                    data: {
                        src: srcImagesMap
                    }
                });
                that.__removeTaskItem(item, index);
            } else {
                that.__removeTaskItem(item, index);
            }
        },
        onSettingPlan: function onSettingPlan(item) {
            var that = this;
            var cdg = that.exifConfigDialog;
            cdg.title = that.$t('pages.modify.dialog-exif-confirm-edit.title');
            cdg.confirmButtonText = that.$t('pages.modify.dialog-exif-confirm-edit.btnConfirm');
            cdg.denyButtonText = that.$t('pages.modify.dialog-exif-confirm-edit.btnDeny');
            cdg.exifInfo = item.exif;
            var dialog = that.$refs[cdg.ref];
            cdg.callbackConfirm = function () {};
            dialog.open();
        },
        onOpenParentDir: function onOpenParentDir(dir) {
            var that = this;
            _dovemaxsdk.BS.b$.revealInFinder(dir);
        },
        onPreviewFile: function onPreviewFile(file) {
            _dovemaxsdk.BS.b$.previewFile(dir);
        }
    },

    components: {
        UiIcon: _keenUi.UiIcon,
        UiTabs: _keenUi.UiTabs,
        UiTab: _keenUi.UiTab,
        UiButton: _keenUi.UiButton,
        UiIconButton: _keenUi.UiIconButton,
        UiAlert: _keenUi.UiAlert,
        UiToolbar: _keenUi.UiToolbar,
        UiSelect: _keenUi.UiSelect,
        UiConfirm: _keenUi.UiConfirm,
        UiProgressLinear: _keenUi.UiProgressLinear,
        DoveMXComponents: _components2.default
    }
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(24);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _dovemaxsdk = __webpack_require__(12);

var _keenUi = __webpack_require__(9);

var _transfer = __webpack_require__(23);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var baseID = "__page__remove__action__";
var baseIDIndex = -1;

var taskList = [];
var taskPrefix = 'remove-page-image-id-' + _dovemaxsdk._.now();

var Task = function Task(thumb, name, path, size) {
    (0, _classCallCheck3.default)(this, Task);

    this.id = _dovemaxsdk._.uniqueId(taskPrefix);
    this.thumb = thumb;
    this.name = name;
    this.path = path;
    this.size = size;
    this.style = {
        show: true,
        type: "success"
    };

    this.isworking = false;
    this.progress = 0;
    this.fixOutDir = "";
    this.fixpath = "";
    this.stateInfo = {
        state: 0,
        message: "" };
};

exports.default = {
    data: function data() {
        console.log("Remove.vue call data()");
        return {
            welcomeContentID: 'page__remove__welcome__id',
            taskList: taskList,
            taskID2taskObj: {},
            isRemoveWorking: false,
            transferIsNormal: _transfer.Transfer.isRunning,
            progressInterval: null,
            confirmDialog: {
                ref: 'default',
                autofocus: 'none',
                confirmButtonText: 'Confirm',
                denyButtonText: 'Deny',
                title: '',
                content: '',
                callbackConfirm: function callbackConfirm() {},
                callbackDeny: function callbackDeny() {}
            },
            curFixTaskID: null };
    },
    beforeCreate: function beforeCreate() {
        var that = this;
        console.log('Remove.vue beforeCreate');

        _transfer.Transfer.frontAgent.registerOnChannelFault(function () {
            that.onTransferIsFault();
        });

        _transfer.Transfer.frontAgent.registerOnFinishBuildChannel(function () {
            that.onTransferIsNoraml();
        });
    },
    mounted: function mounted() {
        this.drawWelcome();
    },
    beforeDestroy: function beforeDestroy() {
        clearInterval(this.progressInterval);
    },


    computed: {
        actionList: function actionList() {
            var that = this;
            return [{ id: 'action-import', visiable: true, color: "black", icon: "fa fa-file-image-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.remove.toolbar.import" }, { id: 'action-importDir', visiable: true, color: "black", icon: "fa fa-folder-open-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.remove.toolbar.importDir" }, { id: 'action-remove', visiable: true, color: "black", icon: "fa fa-trash-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.remove.toolbar.remove" }, { id: 'action-do', visiable: !that.isRemoveWorking, color: "green", icon: "fa fa-eraser fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.remove.toolbar.fix" }, { id: 'action-stop', visiable: that.isRemoveWorking, color: "red", icon: "fa fa-hand-paper-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.remove.toolbar.chancel" }];
        }
    },

    methods: {
        onTransferIsNoraml: function onTransferIsNoraml() {
            var that = this;
            that.transferIsNormal = true;
        },
        onTransferIsFault: function onTransferIsFault() {
            var that = this;
            that.transferIsNormal = false;
            that.isRemoveWorking = false;

            that.stopDo();
        },
        drawWelcome: function drawWelcome() {
            var that = this;
            var SnapRef = _dovemaxsdk.Util.util.getSnapSVG$();
            if (SnapRef) {
                var s = SnapRef('#' + that.welcomeContentID);

                var rect = s.rect('8%', '8%', '84%', '84%', 16);
                rect.attr({
                    fill: "none",
                    "fill-opacity": 0.5,
                    "stroke-linecap": "round",
                    "stroke-linejoin": "bevel",
                    "stroke-dasharray": "5,5",
                    stroke: "#adadad",
                    strokeWidth: 1
                });

                var description = s.text('12%', '16%', that.$t('pages.remove.welcome.description'));
                var step1 = s.text('15%', '26%', that.$t('pages.remove.welcome.step1'));
                var step2 = s.text('15%', '36%', that.$t('pages.remove.welcome.step2'));
                var step3 = s.text('15%', '46%', that.$t('pages.remove.welcome.step3'));

                description.attr({
                    "font-weight": "bold"
                });
            }
        },
        getItemStyleClass: function getItemStyleClass(item) {
            var _styleClass = [''];
            if (item.stateInfo) {

                if (item.stateInfo.state < 0) {
                    _styleClass = ['isFixFailed'];
                }
                if (item.stateInfo.state > 0) {
                    _styleClass = ['isFixedSuccess'];
                }
            }

            return _styleClass;
        },
        getItemProgressStyle: function getItemProgressStyle(item) {
            var that = this;
            var progressStyle = 'black';
            if (item.stateInfo) {
                if (item.stateInfo.state < 0) progressStyle = 'accent';
                if (item.stateInfo.state > 0) progressStyle = 'primary';
            }

            return progressStyle;
        },
        getImageProgressShow: function getImageProgressShow(item) {
            return item.isworking;
        },
        onConfirmDialogConfirm: function onConfirmDialogConfirm() {
            var that = this;
            var fn = that.confirmDialog.callbackConfirm;
            fn && fn();
        },
        onConfirmDialogDeny: function onConfirmDialogDeny() {
            var that = this;
            var fn = that.confirmDialog.callbackDeny;
            fn && fn();
        },
        onToolBtnClick: function onToolBtnClick(index, item) {
            console.log('onToolBtnClick', index);

            if (item.id === 'action-import') {
                this.onBtnImportFilesClick();
            } else if (item.id === 'action-importDir') {
                this.onBtnImportDirClick();
            } else if (item.id === 'action-remove') {
                this.onBtnRemoveAllClick();
            } else if (item.id === 'action-do') {
                this.onBtnDoClick();
            } else if (item.id === 'action-stop') {
                this.onBtnStopDoClick();
            }
        },
        onBtnImportFilesClick: function onBtnImportFilesClick() {
            var that = this;

            console.log("-------------------- call import files");

            _dovemaxsdk.BS.b$.importFiles({
                title: this.$t('pages.remove.dialog-import-images.title'),
                prompt: this.$t('pages.remove.dialog-import-images.prompt'),
                allowMulSelection: true,
                types: [] }, function () {
                _dovemaxsdk._.each([{ fileName: 'RAW_NIKON_D7100.NEF', filePath: 'D:\\TestResource\\exif_sample_images\\Nikon\\corrupted\\RAW_NIKON_D7100.NEF', fileSize: '27.5MB' }, { fileName: 'YDSC_0021.NEF', filePath: 'D:\\TestResource\\exif_sample_images\\Nikon\\corrupted\\YDSC_0021.NEF', fileSize: '10.7MB' }], function (ele) {
                    var taskObj = new Task("images/picture.svg", ele.fileName, ele.filePath, ele.fileSize);
                    that.taskList.push(taskObj);
                    that.taskID2taskObj[taskObj.id] = taskObj;
                });

                return;

                for (var i = 0; i < 50; ++i) {
                    var taskObj = new Task("images/picture.svg", "Images" + i, "/url/image" + i, i + '.2MB');
                    that.taskList.push(taskObj);
                    that.taskID2taskObj[taskObj.id] = taskObj;
                }
            }, function (data) {
                if (data.success) {
                    var imageFiles = data.filesArray;
                    imageFiles.forEach(function (fileObj, dinx) {
                        var taskObj = new Task("images/picture.svg", fileObj.fileName, fileObj.filePath, fileObj.fileSizeStr);
                        that.taskList.push(taskObj);
                        that.taskID2taskObj[taskObj.id] = taskObj;
                    });
                }
            });
        },
        onBtnImportDirClick: function onBtnImportDirClick() {
            var that = this;

            console.log("-------------------- call import dir");

            _dovemaxsdk.BS.b$.selectDir({
                title: this.$t('pages.remove.dialog-import-dir-images.title'),
                prompt: this.$t('pages.remove.dialog-import-dir-images.prompt'),
                allowMulSelection: true
            }, function () {
                for (var i = 0; i < 5; ++i) {
                    var taskObj = new Task("images/folder.svg", "ImagesDir" + i, "/url/imageDir" + i, i + '22.2MB');
                    that.taskList.push(taskObj);
                    that.taskID2taskObj[taskObj.id] = taskObj;
                }
            }, function (data) {
                if (data.success) {
                    var imageFiles = data.filesArray;
                    imageFiles.forEach(function (fileObj, dinx) {
                        var taskObj = new Task("images/picture.svg", fileObj.fileName, fileObj.filePath, fileObj.fileSizeStr);
                        that.taskList.push(taskObj);
                        that.taskID2taskObj[taskObj.id] = taskObj;
                    });
                }
            });
        },
        onBtnRemoveAllClick: function onBtnRemoveAllClick() {
            var that = this;

            if (that.taskList.length > 0) {
                var cdg = that.confirmDialog;
                cdg.title = that.$t('pages.remove.dialog-confirm-remove-all.title');
                cdg.content = that.$t('pages.remove.dialog-confirm-remove-all.message');
                cdg.confirmButtonText = that.$t('pages.remove.dialog-confirm-remove-all.btnConfirm');
                cdg.denyButtonText = that.$t('pages.remove.dialog-confirm-remove-all.btnDeny');

                var dialog = that.$refs[cdg.ref];
                cdg.callbackConfirm = function () {
                    that.stopDo();
                    that.taskList.splice(0, that.taskList.length);
                };
                dialog.open();
            }
        },
        onBtnDoClick: function onBtnDoClick() {
            var that = this;

            if (that.taskList.length === 0) {
                return _dovemaxsdk.BS.b$.Notice.alert({
                    message: that.$t('pages.remove.notice-no-items.message')
                });
            }

            console.log("---------------------- call export dir");
            _dovemaxsdk.BS.b$.selectOutDir({
                title: that.$t('pages.remove.dialog-select-outdir.title'),
                prompt: that.$t('pages.remove.dialog-select-outdir.prompt'),
                canCreateDir: true
            }, function () {
                that.startDo('D:\\TestResource\\exif_sample_images\\Nikon\\corrupted_output');
            }, function (data) {
                if (data.success) {
                    var outDir = data.filePath;
                    that.startDo(outDir);
                }
            });
        },
        onBtnStopDoClick: function onBtnStopDoClick() {
            var that = this;

            if (that.isRemoveWorking) {
                var cdg = that.confirmDialog;
                cdg.title = that.$t('pages.remove.dialog-confirm-stop-fix.title');
                cdg.content = that.$t('pages.remove.dialog-confirm-stop-fix.message');
                cdg.confirmButtonText = that.$t('pages.remove.dialog-confirm-stop-fix.btnConfirm');
                cdg.denyButtonText = that.$t('pages.remove.dialog-confirm-stop-fix.btnDeny');

                var dialog = that.$refs[cdg.ref];
                cdg.callbackConfirm = function () {
                    that.stopDo();
                };
                dialog.open();
            }
        },
        startDo: function startDo(outDir) {
            var that = this;

            var srcImagesMap = {};
            _dovemaxsdk._.each(that.taskList, function (taskObj, index) {
                srcImagesMap[taskObj.id] = taskObj.path;
            });

            that.curFixTaskID = _dovemaxsdk._.uniqueId(taskPrefix + 'task-');
            _transfer.Transfer.Tools.RemoveExifInfo.run({
                taskID: that.curFixTaskID,
                data: {
                    src: srcImagesMap,
                    outputDir: outDir || _dovemaxsdk.BS.b$.App.getTempDir()
                },
                lang: Vue.config.lang
            }, function (data) {
                if (data.msg_type === 's_task_exec_running') {
                    that.isRemoveWorking = true;
                } else if (data.msg_type === 's_task_exec_feedback') {
                    var dataList = data.content;
                    that.isRemoveWorking = dataList.length > 0;
                    _dovemaxsdk._.each(dataList, function (ele) {
                        var curImageTaskObj = that.taskID2taskObj[ele.id];
                        if (curImageTaskObj) {
                            curImageTaskObj.isworking = ele.progress >= 100 ? false : true;
                            curImageTaskObj.progress = ele.progress >= 100 ? 100 : ele.progress;
                            curImageTaskObj.stateInfo.state = ele.state;
                            curImageTaskObj.stateInfo.message = ele.message || '';
                        }
                    });
                } else if (data.msg_type === 's_task_exec_result') {}
            });
        },
        stopDo: function stopDo() {
            var notice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            var that = this;

            var srcImagesMap = {};
            _dovemaxsdk._.each(that.taskList, function (taskObj, index) {
                taskObj.isworking = false;

                srcImagesMap[taskObj.id] = taskObj.path;
            });

            if (!notice) return;
            if (_dovemaxsdk._.keys(srcImagesMap).length > 0 && that.isRemoveWorking) {
                _transfer.Transfer.Tools.RemoveExifInfo.stop({
                    taskID: that.curFixTaskID,
                    data: {
                        src: srcImagesMap
                    }
                });
            }
        },
        __removeTaskItem: function __removeTaskItem(item, index) {
            var that = this;
            item.isworking = false;

            item.progress = 0;
            item.stateInfo = 0;
            that.taskID2taskObj[item.id] = null;

            that.taskList.splice(index, 1);
        },
        onRemoveTaskItem: function onRemoveTaskItem(item, index) {
            console.log('item: ', item, 'index: ', index);
            var that = this;

            if (item.isworking) {
                var srcImagesMap = {};
                srcImagesMap[item.id] = item.path;
                _transfer.Transfer.Tools.RemoveExifInfo.stop({
                    taskID: that.curFixTaskID,
                    data: {
                        src: srcImagesMap
                    }
                });
                that.__removeTaskItem(item, index);
            } else {
                that.__removeTaskItem(item, index);
            }
        },
        onOpenParentDir: function onOpenParentDir(dir) {
            var that = this;
            _dovemaxsdk.BS.b$.revealInFinder(dir);
        },
        onPreviewFile: function onPreviewFile(file) {
            _dovemaxsdk.BS.b$.previewFile(dir);
        }
    },

    components: {
        UiIcon: _keenUi.UiIcon,
        UiTabs: _keenUi.UiTabs,
        UiTab: _keenUi.UiTab,
        UiButton: _keenUi.UiButton,
        UiIconButton: _keenUi.UiIconButton,
        UiAlert: _keenUi.UiAlert,
        UiToolbar: _keenUi.UiToolbar,
        UiConfirm: _keenUi.UiConfirm,
        UiProgressLinear: _keenUi.UiProgressLinear
    }
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(24);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _dovemaxsdk = __webpack_require__(12);

var _keenUi = __webpack_require__(9);

var _transfer = __webpack_require__(23);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var baseID = "__page__repair__action__";
var baseIDIndex = -1;

var taskList = [];
var taskPrefix = 'fixpage-image-id-' + _dovemaxsdk._.now();

var Task = function Task(thumb, name, path, size) {
    (0, _classCallCheck3.default)(this, Task);

    this.id = _dovemaxsdk._.uniqueId(taskPrefix);
    this.thumb = thumb;
    this.name = name;
    this.path = path;
    this.size = size;
    this.style = {
        show: true,
        type: "success"
    };

    this.isworking = false;
    this.progress = 0;
    this.fixOutDir = "";
    this.fixpath = "";
    this.stateInfo = {
        state: 0,
        message: "" };
};

exports.default = {
    data: function data() {
        console.log("Repair.vue call data()");
        return {
            welcomeContentID: 'page__repair__welcome__id',
            taskList: taskList,
            taskID2taskObj: {},
            isFixworking: false,
            transferIsNormal: _transfer.Transfer.isRunning,
            progressInterval: null,
            confirmDialog: {
                ref: 'default',
                autofocus: 'none',
                confirmButtonText: 'Confirm',
                denyButtonText: 'Deny',
                title: '',
                content: '',
                callbackConfirm: function callbackConfirm() {},
                callbackDeny: function callbackDeny() {}
            },
            curFixTaskID: null };
    },
    beforeCreate: function beforeCreate() {
        var that = this;
        console.log('Repair.vue beforeCreate');

        _transfer.Transfer.frontAgent.registerOnChannelFault(function () {
            that.onTransferIsFault();
        });

        _transfer.Transfer.frontAgent.registerOnFinishBuildChannel(function () {
            that.onTransferIsNoraml();
        });
    },
    mounted: function mounted() {
        this.drawWelcome();
    },
    beforeDestroy: function beforeDestroy() {
        clearInterval(this.progressInterval);
    },


    computed: {
        actionList: function actionList() {
            var that = this;
            return [{ id: 'action-import', visiable: true, color: "black", icon: "fa fa-file-image-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.repair.toolbar.import" }, { id: 'action-importDir', visiable: true, color: "black", icon: "fa fa-folder-open-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.repair.toolbar.importDir" }, { id: 'action-remove', visiable: true, color: "black", icon: "fa fa-trash-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.repair.toolbar.remove" }, { id: 'action-do', visiable: !that.isFixworking, color: "green", icon: "fa fa-legal fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.repair.toolbar.fix" }, { id: 'action-stop', visiable: that.isFixworking, color: "red", icon: "fa fa-hand-paper-o fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.repair.toolbar.chancel" }];
        }
    },

    methods: {
        onTransferIsNoraml: function onTransferIsNoraml() {
            var that = this;
            that.transferIsNormal = true;
        },
        onTransferIsFault: function onTransferIsFault() {
            var that = this;
            that.transferIsNormal = false;
            that.isFixworking = false;

            that.stopFix();
        },
        drawWelcome: function drawWelcome() {
            var that = this;
            var SnapRef = _dovemaxsdk.Util.util.getSnapSVG$();
            if (SnapRef) {
                var s = SnapRef('#' + that.welcomeContentID);

                var rect = s.rect('8%', '8%', '84%', '84%', 16);
                rect.attr({
                    fill: "none",
                    "fill-opacity": 0.5,
                    "stroke-linecap": "round",
                    "stroke-linejoin": "bevel",
                    "stroke-dasharray": "5,5",
                    stroke: "#adadad",
                    strokeWidth: 1
                });

                var description = s.text('12%', '16%', that.$t('pages.repair.welcome.description'));
                var step1 = s.text('15%', '26%', that.$t('pages.repair.welcome.step1'));
                var step2 = s.text('15%', '36%', that.$t('pages.repair.welcome.step2'));
                var step3 = s.text('15%', '46%', that.$t('pages.repair.welcome.step3'));

                description.attr({
                    "font-weight": "bold"
                });
            }
        },
        getItemStyleClass: function getItemStyleClass(item) {
            var _styleClass = [''];
            if (item.stateInfo) {

                if (item.stateInfo.state < 0) {
                    _styleClass = ['isFixFailed'];
                }
                if (item.stateInfo.state > 0) {
                    _styleClass = ['isFixedSuccess'];
                }
            }

            return _styleClass;
        },
        getItemProgressStyle: function getItemProgressStyle(item) {
            var that = this;
            var progressStyle = 'black';
            if (item.stateInfo) {
                if (item.stateInfo.state < 0) progressStyle = 'accent';
                if (item.stateInfo.state > 0) progressStyle = 'primary';
            }

            return progressStyle;
        },
        getImageProgressShow: function getImageProgressShow(item) {
            return item.isworking;
        },
        onConfirmDialogConfirm: function onConfirmDialogConfirm() {
            var that = this;
            var fn = that.confirmDialog.callbackConfirm;
            fn && fn();
        },
        onConfirmDialogDeny: function onConfirmDialogDeny() {
            var that = this;
            var fn = that.confirmDialog.callbackDeny;
            fn && fn();
        },
        onToolBtnClick: function onToolBtnClick(index, item) {
            console.log('onToolBtnClick', index);

            if (item.id === 'action-import') {
                this.onBtnImportFilesClick();
            } else if (item.id === 'action-importDir') {
                this.onBtnImportDirClick();
            } else if (item.id === 'action-remove') {
                this.onBtnRemoveAllClick();
            } else if (item.id === 'action-do') {
                this.onBtnFixClick();
            } else if (item.id === 'action-stop') {
                this.onBtnStopFixClick();
            }
        },
        onBtnImportFilesClick: function onBtnImportFilesClick() {
            var that = this;

            console.log("-------------------- call import files");

            _dovemaxsdk.BS.b$.importFiles({
                title: this.$t('pages.repair.dialog-import-images.title'),
                prompt: this.$t('pages.repair.dialog-import-images.prompt'),
                allowMulSelection: true,
                types: [] }, function () {
                _dovemaxsdk._.each([{ fileName: 'RAW_NIKON_D7100.NEF', filePath: 'D:\\TestResource\\exif_sample_images\\Nikon\\corrupted\\RAW_NIKON_D7100.NEF', fileSize: '27.5MB' }, { fileName: 'YDSC_0021.NEF', filePath: 'D:\\TestResource\\exif_sample_images\\Nikon\\corrupted\\YDSC_0021.NEF', fileSize: '10.7MB' }], function (ele) {
                    var taskObj = new Task("images/picture.svg", ele.fileName, ele.filePath, ele.fileSize);
                    that.taskList.push(taskObj);
                    that.taskID2taskObj[taskObj.id] = taskObj;
                });

                return;

                for (var i = 0; i < 50; ++i) {
                    var taskObj = new Task("images/picture.svg", "Images" + i, "/url/image" + i, i + '.2MB');
                    that.taskList.push(taskObj);
                    that.taskID2taskObj[taskObj.id] = taskObj;
                }
            }, function (data) {
                if (data.success) {
                    var imageFiles = data.filesArray;
                    imageFiles.forEach(function (fileObj, dinx) {
                        var taskObj = new Task("images/picture.svg", fileObj.fileName, fileObj.filePath, fileObj.fileSizeStr);
                        that.taskList.push(taskObj);
                        that.taskID2taskObj[taskObj.id] = taskObj;
                    });
                }
            });
        },
        onBtnImportDirClick: function onBtnImportDirClick() {
            var that = this;

            console.log("-------------------- call import dir");

            _dovemaxsdk.BS.b$.selectDir({
                title: this.$t('pages.repair.dialog-import-dir-images.title'),
                prompt: this.$t('pages.repair.dialog-import-dir-images.prompt'),
                allowMulSelection: true
            }, function () {
                for (var i = 0; i < 5; ++i) {
                    var taskObj = new Task("images/folder.svg", "ImagesDir" + i, "/url/imageDir" + i, i + '22.2MB');
                    that.taskList.push(taskObj);
                    that.taskID2taskObj[taskObj.id] = taskObj;
                }
            }, function (data) {
                if (data.success) {
                    var imageFiles = data.filesArray;
                    imageFiles.forEach(function (fileObj, dinx) {
                        var taskObj = new Task("images/picture.svg", fileObj.fileName, fileObj.filePath, fileObj.fileSizeStr);
                        that.taskList.push(taskObj);
                        that.taskID2taskObj[taskObj.id] = taskObj;
                    });
                }
            });
        },
        onBtnRemoveAllClick: function onBtnRemoveAllClick() {
            var that = this;

            if (that.taskList.length > 0) {
                var cdg = that.confirmDialog;
                cdg.title = that.$t('pages.repair.dialog-confirm-remove-all.title');
                cdg.content = that.$t('pages.repair.dialog-confirm-remove-all.message');
                cdg.confirmButtonText = that.$t('pages.repair.dialog-confirm-remove-all.btnConfirm');
                cdg.denyButtonText = that.$t('pages.repair.dialog-confirm-remove-all.btnDeny');

                var dialog = that.$refs[cdg.ref];
                cdg.callbackConfirm = function () {
                    that.stopFix();
                    that.taskList.splice(0, that.taskList.length);
                };
                dialog.open();
            }
        },
        onBtnFixClick: function onBtnFixClick() {
            var that = this;

            if (that.taskList.length === 0) {
                return _dovemaxsdk.BS.b$.Notice.alert({
                    message: that.$t('pages.repair.notice-no-items.message')
                });
            }

            console.log("---------------------- call export dir");
            _dovemaxsdk.BS.b$.selectOutDir({
                title: that.$t('pages.repair.dialog-select-outdir.title'),
                prompt: that.$t('pages.repair.dialog-select-outdir.prompt'),
                canCreateDir: true
            }, function () {
                that.startFix('D:\\TestResource\\exif_sample_images\\Nikon\\corrupted_output');
            }, function (data) {
                if (data.success) {
                    var outDir = data.filePath;
                    that.startFix(outDir);
                }
            });
        },
        onBtnStopFixClick: function onBtnStopFixClick() {
            var that = this;

            if (that.isFixworking) {
                var cdg = that.confirmDialog;
                cdg.title = that.$t('pages.repair.dialog-confirm-stop-fix.title');
                cdg.content = that.$t('pages.repair.dialog-confirm-stop-fix.message');
                cdg.confirmButtonText = that.$t('pages.repair.dialog-confirm-stop-fix.btnConfirm');
                cdg.denyButtonText = that.$t('pages.repair.dialog-confirm-stop-fix.btnDeny');

                var dialog = that.$refs[cdg.ref];
                cdg.callbackConfirm = function () {
                    that.stopFix();
                };
                dialog.open();
            }
        },
        startFix: function startFix(outDir) {
            var that = this;

            var srcImagesMap = {};
            _dovemaxsdk._.each(that.taskList, function (taskObj, index) {
                srcImagesMap[taskObj.id] = taskObj.path;
            });

            that.curFixTaskID = _dovemaxsdk._.uniqueId(taskPrefix + 'task-');
            _transfer.Transfer.Tools.Fix.Image.run({
                taskID: that.curFixTaskID,
                data: {
                    src: srcImagesMap,
                    outputDir: outDir || _dovemaxsdk.BS.b$.App.getTempDir()
                },
                lang: Vue.config.lang
            }, function (data) {
                if (data.msg_type === 's_task_exec_running') {
                    that.isFixworking = true;
                } else if (data.msg_type === 's_task_exec_feedback') {
                    var dataList = data.content;
                    that.isFixworking = dataList.length > 0;
                    _dovemaxsdk._.each(dataList, function (ele) {
                        var curImageTaskObj = that.taskID2taskObj[ele.id];
                        if (curImageTaskObj) {
                            curImageTaskObj.isworking = ele.progress >= 100 ? false : true;
                            curImageTaskObj.progress = ele.progress >= 100 ? 100 : ele.progress;
                            curImageTaskObj.stateInfo.state = ele.state;
                            curImageTaskObj.stateInfo.message = ele.message || '';
                        }
                    });
                } else if (data.msg_type === 's_task_exec_result') {}
            });
        },
        stopFix: function stopFix() {
            var notice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            var that = this;

            var srcImagesMap = {};
            _dovemaxsdk._.each(that.taskList, function (taskObj, index) {
                taskObj.isworking = false;

                srcImagesMap[taskObj.id] = taskObj.path;
            });

            if (!notice) return;
            if (_dovemaxsdk._.keys(srcImagesMap).length > 0 && that.isFixworking) {
                _transfer.Transfer.Tools.Fix.Image.stop({
                    taskID: that.curFixTaskID,
                    data: {
                        src: srcImagesMap
                    }
                });
            }
        },
        __removeTaskItem: function __removeTaskItem(item, index) {
            var that = this;
            item.isworking = false;

            item.progress = 0;
            item.stateInfo = 0;
            that.taskID2taskObj[item.id] = null;

            that.taskList.splice(index, 1);
        },
        onRemoveTaskItem: function onRemoveTaskItem(item, index) {
            console.log('item: ', item, 'index: ', index);
            var that = this;

            if (item.isworking) {
                var srcImagesMap = {};
                srcImagesMap[item.id] = item.path;
                _transfer.Transfer.Tools.Fix.Image.stop({
                    taskID: that.curFixTaskID,
                    data: {
                        src: srcImagesMap
                    }
                });
                that.__removeTaskItem(item, index);
            } else {
                that.__removeTaskItem(item, index);
            }
        },
        onOpenParentDir: function onOpenParentDir(dir) {
            var that = this;
            _dovemaxsdk.BS.b$.revealInFinder(dir);
        },
        onPreviewFile: function onPreviewFile(file) {
            _dovemaxsdk.BS.b$.previewFile(dir);
        }
    },

    components: {
        UiIcon: _keenUi.UiIcon,
        UiTabs: _keenUi.UiTabs,
        UiTab: _keenUi.UiTab,
        UiButton: _keenUi.UiButton,
        UiIconButton: _keenUi.UiIconButton,
        UiAlert: _keenUi.UiAlert,
        UiToolbar: _keenUi.UiToolbar,
        UiConfirm: _keenUi.UiConfirm,
        UiProgressLinear: _keenUi.UiProgressLinear
    }
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(24);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _dovemaxsdk = __webpack_require__(12);

var _keenUi = __webpack_require__(9);

var _transfer = __webpack_require__(23);

var _sysConfig = __webpack_require__(51);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var News = function News(thumb, title, date, description, link) {
  (0, _classCallCheck3.default)(this, News);

  this.id = _dovemaxsdk._.uniqueId('welcome-news-id-');
  this.thumb = thumb;
  this.title = title;
  this.date = date;
  this.description = description;
  this.link = link;
  this.style = {
    show: true,
    type: "success"
  };
};

exports.default = {
  data: function data() {
    return {
      newsList: []
    };
  },
  beforeCreate: function beforeCreate() {},
  mounted: function mounted() {
    this.testNewList();
  },

  computed: {
    actionList: function actionList() {
      var that = this;
      return [{ id: 'action-setting', visiable: true, color: "black", icon: "fa fa-cog fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.welcome.toolbar.setting" }, { id: 'action-online-doc', visiable: true, color: "black", icon: "fa fa-book fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.welcome.toolbar.onlineDoc" }, { id: 'action-online-room', visiable: true, color: "black", icon: "fa fa-users fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.welcome.toolbar.onlineRoom" }, { id: 'action-update-news', visiable: true, color: "black", icon: "fa fa-rss fa-lg fa-fw", size: "small", type: "secondary", tooltip: "pages.welcome.toolbar.updateNews" }];
    }
  },
  methods: {
    testNewList: function testNewList() {
      var that = this;
      var list = [];

      for (var i = 0; i < 20; ++i) {
        list.push({
          title: 'AiExifCool Ver 1.0.0 publish...',
          date: '2017323',
          description: '\n            AiExifCool \u65B0\u4EA7\u54C1\u53D1\u5E03\uFF0C\u6D89\u53CA\u5982\u4E0B\u529F\u80FD\uFF1A\n            1. \u7528\u6237\u754C\u9762\u6539\u8FDB\n            2. \u7528\u6237\u4EA7\u54C1\u529F\u80FD\u66F4\u65B0\n            3. \u4FEE\u590D\u4E00\u4E9B\u5F71\u54CD\u5904\u7406\u901F\u5EA6\u7684\u95EE\u9898\n            ',
          link: 'https://www.baidu.com'
        });
      }

      _dovemaxsdk._.each(list, function (ele) {
        var newsObj = new News("images/picture.svg", ele.title, ele.date, ele.description, ele.link);
        that.newsList.push(newsObj);
      });
    },
    getItemStyleClass: function getItemStyleClass(item) {
      var _styleClass = [''];
      return _styleClass;
    },
    onOpenLink: function onOpenLink(link) {
      _dovemaxsdk.BS.b$.App.open(link);
    },
    onToolBtnClick: function onToolBtnClick(index, item) {
      console.log('onToolBtnClick', index);

      if (item.id === 'action-setting') {
        this.onBtnSettingClick();
      } else if (item.id === 'action-online-doc') {
        this.onBtnOnlineDocClick();
      }
    },
    onBtnSettingClick: function onBtnSettingClick() {},
    onBtnOnlineDocClick: function onBtnOnlineDocClick() {
      console.log(_sysConfig.SysConfig.docPage);
      _dovemaxsdk.BS.b$.App.open(_sysConfig.SysConfig.docPage);
    },
    onPageBtnClick: function onPageBtnClick(index, item) {
      console.log('onPageBtnClick', index);
    }
  },
  components: {
    UiIcon: _keenUi.UiIcon,
    UiTabs: _keenUi.UiTabs,
    UiTab: _keenUi.UiTab,
    UiButton: _keenUi.UiButton,
    UiIconButton: _keenUi.UiIconButton,
    UiAlert: _keenUi.UiAlert,
    UiToolbar: _keenUi.UiToolbar,
    UiConfirm: _keenUi.UiConfirm,
    UiProgressLinear: _keenUi.UiProgressLinear
  }
};

/***/ }),
/* 96 */,
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _dovemaxsdk = __webpack_require__(12);

var _keenUi = __webpack_require__(9);

var _routes = __webpack_require__(52);

var _routes2 = _interopRequireDefault(_routes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    data: function data() {
        return {
            appName: _routes2.default.SysConfig.appName,
            version: _routes2.default.SysConfig.version,
            homepage: _routes2.default.SysConfig.homepage,

            menu: _routes2.default.menu
        };
    },


    components: {
        UiIcon: _keenUi.UiIcon,
        UiCollapsible: _keenUi.UiCollapsible
    }
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var iconSet = {
  discover: 'images/plier.svg',
  repair: 'images/plier.svg',
  adjust: 'images/controls.svg',
  remove: 'images/eraser.svg',
  compare: 'images/compare.svg',
  report: 'images/report.svg'

};

exports.default = {
  iconSet: iconSet
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(175);

var obj = {};
exports.default = {
  obj: obj
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(118), __esModule: true };

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(119), __esModule: true };

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(120), __esModule: true };

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(121), __esModule: true };

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(122), __esModule: true };

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(123), __esModule: true };

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(124), __esModule: true };

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(125), __esModule: true };

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(126), __esModule: true };

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(127), __esModule: true };

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(128), __esModule: true };

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(129), __esModule: true };

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(131), __esModule: true };

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(132), __esModule: true };

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(133), __esModule: true };

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(134), __esModule: true };

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(135), __esModule: true };

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(116);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(115);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(22);
__webpack_require__(21);
module.exports = __webpack_require__(157);

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(22);
__webpack_require__(21);
module.exports = __webpack_require__(158);

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var core  = __webpack_require__(0)
  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(50);
__webpack_require__(21);
__webpack_require__(22);
__webpack_require__(160);
__webpack_require__(172);
module.exports = __webpack_require__(0).Map;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(161);
var $Object = __webpack_require__(0).Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(162);
var $Object = __webpack_require__(0).Object;
module.exports = function defineProperties(T, D){
  return $Object.defineProperties(T, D);
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(163);
var $Object = __webpack_require__(0).Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(164);
var $Object = __webpack_require__(0).Object;
module.exports = function getOwnPropertyDescriptor(it, key){
  return $Object.getOwnPropertyDescriptor(it, key);
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(165);
var $Object = __webpack_require__(0).Object;
module.exports = function getOwnPropertyNames(it){
  return $Object.getOwnPropertyNames(it);
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(69);
module.exports = __webpack_require__(0).Object.getOwnPropertySymbols;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(166);
module.exports = __webpack_require__(0).Object.getPrototypeOf;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(167);
module.exports = __webpack_require__(0).Object.isExtensible;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(168);
module.exports = __webpack_require__(0).Object.keys;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(169);
module.exports = __webpack_require__(0).Object.preventExtensions;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(170);
module.exports = __webpack_require__(0).Object.setPrototypeOf;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(50);
__webpack_require__(21);
__webpack_require__(22);
__webpack_require__(171);
module.exports = __webpack_require__(0).Promise;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(69);
__webpack_require__(50);
__webpack_require__(173);
__webpack_require__(174);
module.exports = __webpack_require__(0).Symbol;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(21);
__webpack_require__(22);
module.exports = __webpack_require__(49).f('iterator');

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = function(){ /* empty */ };

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(27);

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(11)
  , toLength  = __webpack_require__(46)
  , toIndex   = __webpack_require__(156);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = __webpack_require__(13)
  , IObject  = __webpack_require__(56)
  , toObject = __webpack_require__(32)
  , toLength = __webpack_require__(46)
  , asc      = __webpack_require__(141);
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5)
  , isArray  = __webpack_require__(57)
  , SPECIES  = __webpack_require__(1)('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(140);

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP          = __webpack_require__(6).f
  , create      = __webpack_require__(30)
  , redefineAll = __webpack_require__(42)
  , ctx         = __webpack_require__(13)
  , anInstance  = __webpack_require__(36)
  , defined     = __webpack_require__(26)
  , forOf       = __webpack_require__(27)
  , $iterDefine = __webpack_require__(39)
  , step        = __webpack_require__(58)
  , setSpecies  = __webpack_require__(66)
  , DESCRIPTORS = __webpack_require__(3)
  , fastKey     = __webpack_require__(29).fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(25)
  , from    = __webpack_require__(137);
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global         = __webpack_require__(2)
  , $export        = __webpack_require__(4)
  , meta           = __webpack_require__(29)
  , fails          = __webpack_require__(15)
  , hide           = __webpack_require__(10)
  , redefineAll    = __webpack_require__(42)
  , forOf          = __webpack_require__(27)
  , anInstance     = __webpack_require__(36)
  , isObject       = __webpack_require__(5)
  , setToStringTag = __webpack_require__(20)
  , dP             = __webpack_require__(6).f
  , each           = __webpack_require__(139)(0)
  , DESCRIPTORS    = __webpack_require__(3);

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function(target, iterable){
      anInstance(target, C, NAME, '_c');
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        anInstance(this, C, KEY);
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)dP(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(19)
  , gOPS    = __webpack_require__(62)
  , pIE     = __webpack_require__(41);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 146 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators  = __webpack_require__(16)
  , ITERATOR   = __webpack_require__(1)('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(7);
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create         = __webpack_require__(30)
  , descriptor     = __webpack_require__(31)
  , setToStringTag = __webpack_require__(20)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(10)(IteratorPrototype, __webpack_require__(1)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR     = __webpack_require__(1)('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(19)
  , toIObject = __webpack_require__(11);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(2)
  , macrotask = __webpack_require__(67).set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = __webpack_require__(18)(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(5)
  , anObject = __webpack_require__(7);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(13)(Function.call, __webpack_require__(40).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = __webpack_require__(7)
  , aFunction = __webpack_require__(35)
  , SPECIES   = __webpack_require__(1)('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(45)
  , defined   = __webpack_require__(26);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(45)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(7)
  , get      = __webpack_require__(68);
module.exports = __webpack_require__(0).getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(25)
  , ITERATOR  = __webpack_require__(1)('iterator')
  , Iterators = __webpack_require__(16);
module.exports = __webpack_require__(0).isIterable = function(it){
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(136)
  , step             = __webpack_require__(58)
  , Iterators        = __webpack_require__(16)
  , toIObject        = __webpack_require__(11);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(39)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(142);

// 23.1 Map Objects
module.exports = __webpack_require__(144)('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(4)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(30)});

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(4);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(3), 'Object', {defineProperties: __webpack_require__(59)});

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(4);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(3), 'Object', {defineProperty: __webpack_require__(6).f});

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = __webpack_require__(11)
  , $getOwnPropertyDescriptor = __webpack_require__(40).f;

__webpack_require__(17)('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(17)('getOwnPropertyNames', function(){
  return __webpack_require__(60).f;
});

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = __webpack_require__(32)
  , $getPrototypeOf = __webpack_require__(63);

__webpack_require__(17)('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(5);

__webpack_require__(17)('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(32)
  , $keys    = __webpack_require__(19);

__webpack_require__(17)('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(5)
  , meta     = __webpack_require__(29).onFreeze;

__webpack_require__(17)('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(4);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(153).set});

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY            = __webpack_require__(28)
  , global             = __webpack_require__(2)
  , ctx                = __webpack_require__(13)
  , classof            = __webpack_require__(25)
  , $export            = __webpack_require__(4)
  , isObject           = __webpack_require__(5)
  , aFunction          = __webpack_require__(35)
  , anInstance         = __webpack_require__(36)
  , forOf              = __webpack_require__(27)
  , speciesConstructor = __webpack_require__(154)
  , task               = __webpack_require__(67).set
  , microtask          = __webpack_require__(152)()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[__webpack_require__(1)('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(42)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
__webpack_require__(20)($Promise, PROMISE);
__webpack_require__(66)(PROMISE);
Wrapper = __webpack_require__(0)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(150)(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = __webpack_require__(4);

$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(143)('Map')});

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(48)('asyncIterator');

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(48)('observable');

/***/ }),
/* 175 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 176 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/**
  * vue-router v2.2.1
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert (condition, message) {
  if (!condition) {
    throw new Error(("[vue-router] " + message))
  }
}

function warn (condition, message) {
  if (!condition) {
    typeof console !== 'undefined' && console.warn(("[vue-router] " + message));
  }
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render (h, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children)
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h()
    }

    var component = cache[name] = matched.components[name];

    // inject instance registration hooks
    var hooks = data.hook || (data.hook = {});
    hooks.init = function (vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.prepatch = function (oldVnode, vnode) {
      matched.instances[name] = vnode.child;
    };
    hooks.destroy = function (vnode) {
      if (matched.instances[name] === vnode.child) {
        matched.instances[name] = undefined;
      }
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children)
  }
};

function resolveProps (route, config) {
  switch (typeof config) {
    case 'undefined':
      return
    case 'object':
      return config
    case 'function':
      return config(route)
    case 'boolean':
      return config ? route.params : undefined
    default:
      warn(false, ("props in \"" + (route.path) + "\" is a " + (typeof config) + ", expecting an object, function or boolean."));
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more comformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) { return encodeURIComponent(str)
  .replace(encodeReserveRE, encodeReserveReplacer)
  .replace(commaRE, ','); };

var decode = decodeURIComponent;

function resolveQuery (
  query,
  extraQuery
) {
  if ( extraQuery === void 0 ) extraQuery = {};

  if (query) {
    var parsedQuery;
    try {
      parsedQuery = parseQuery(query);
    } catch (e) {
      process.env.NODE_ENV !== 'production' && warn(false, e.message);
      parsedQuery = {};
    }
    for (var key in extraQuery) {
      parsedQuery[key] = extraQuery[key];
    }
    return parsedQuery
  } else {
    return extraQuery
  }
}

function parseQuery (query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0
      ? decode(parts.join('='))
      : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res
}

function stringifyQuery (obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return ''
    }

    if (val === null) {
      return encode(key)
    }

    if (Array.isArray(val)) {
      var result = [];
      val.slice().forEach(function (val2) {
        if (val2 === undefined) {
          return
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&')
    }

    return encode(key) + '=' + encode(val)
  }).filter(function (x) { return x.length > 0; }).join('&') : null;
  return res ? ("?" + res) : ''
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute (
  record,
  location,
  redirectedFrom
) {
  var route = {
    name: location.name || (record && record.name),
    meta: (record && record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom);
  }
  return Object.freeze(route)
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch (record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res
}

function getFullPath (ref) {
  var path = ref.path;
  var query = ref.query; if ( query === void 0 ) query = {};
  var hash = ref.hash; if ( hash === void 0 ) hash = '';

  return (path || '/') + stringifyQuery(query) + hash
}

function isSameRoute (a, b) {
  if (b === START) {
    return a === b
  } else if (!b) {
    return false
  } else if (a.path && b.path) {
    return (
      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query)
    )
  } else if (a.name && b.name) {
    return (
      a.name === b.name &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query) &&
      isObjectEqual(a.params, b.params)
    )
  } else {
    return false
  }
}

function isObjectEqual (a, b) {
  if ( a === void 0 ) a = {};
  if ( b === void 0 ) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })
}

function isIncludedRoute (current, target) {
  return (
    current.path.replace(trailingSlashRE, '/').indexOf(
      target.path.replace(trailingSlashRE, '/')
    ) === 0 &&
    (!target.hash || current.hash === target.hash) &&
    queryIncludes(current.query, target.query)
  )
}

function queryIncludes (current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false
    }
  }
  return true
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render (h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';
    var compareTarget = location.path ? createRoute(null, location) : route;
    classes[activeClass] = this.exact
      ? isSameRoute(current, compareTarget)
      : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) { on[e] = handler; });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default)
  }
};

function guardEvent (e) {
  // don't redirect with control keys
  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) { return }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) { return }
  // don't redirect if `target="_blank"`
  if (e.target && e.target.getAttribute) {
    var target = e.target.getAttribute('target');
    if (/\b_blank\b/i.test(target)) { return }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true
}

function findAnchor (children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}

var _Vue;

function install (Vue) {
  if (install.installed) { return }
  install.installed = true;

  _Vue = Vue;

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get () { return this.$root._router }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get () { return this.$root._route }
  });

  Vue.mixin({
    beforeCreate: function beforeCreate () {
      if (this.$options.router) {
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      }
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath (
  relative,
  base,
  append
) {
  if (relative.charAt(0) === '/') {
    return relative
  }

  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {
    return base + relative
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '.') {
      continue
    } else if (segment === '..') {
      stack.pop();
    } else {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/')
}

function parsePath (path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  }
}

function cleanPath (path) {
  return path.replace(/\/\//g, '/')
}

/*  */

function createRouteMap (
  routes,
  oldPathMap,
  oldNameMap
) {
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathMap, nameMap, route);
  });

  return {
    pathMap: pathMap,
    nameMap: nameMap
  }
}

function addRouteRecord (
  pathMap,
  nameMap,
  route,
  parent,
  matchAs
) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(
      typeof route.component !== 'string',
      "route config \"component\" for path: " + (String(path || name)) + " cannot be a " +
      "string id. Use an actual component instead."
    );
  }

  var record = {
    path: normalizePath(path, parent),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && route.children.some(function (child) { return /^\/?$/.test(child.path); })) {
        warn(
          false,
          "Named Route '" + (route.name) + "' has a default child route. " +
          "When navigating to this named route (:to=\"{name: '" + (route.name) + "'\"), " +
          "the default child route will not be rendered. Remove the name from " +
          "this route and use the name of the default child route for named " +
          "links instead."
        );
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs
        ? cleanPath((matchAs + "/" + (child.path)))
        : undefined;
      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    if (Array.isArray(route.alias)) {
      route.alias.forEach(function (alias) {
        var aliasRoute = {
          path: alias,
          children: route.children
        };
        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
      });
    } else {
      var aliasRoute = {
        path: route.alias,
        children: route.children
      };
      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
    }
  }

  if (!pathMap[record.path]) {
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(
        false,
        "Duplicate named routes definition: " +
        "{ name: \"" + name + "\", path: \"" + (record.path) + "\" }"
      );
    }
  }
}

function normalizePath (path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') { return path }
  if (parent == null) { return path }
  return cleanPath(((parent.path) + "/" + path))
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

var isarray = index$1;

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCache = Object.create(null);

function getRouteRegex (path) {
  var hit = regexpCache[path];
  var keys, regexp;

  if (hit) {
    keys = hit.keys;
    regexp = hit.regexp;
  } else {
    keys = [];
    regexp = index(path, keys);
    regexpCache[path] = { keys: keys, regexp: regexp };
  }

  return { keys: keys, regexp: regexp }
}

var regexpCompileCache = Object.create(null);

function fillParams (
  path,
  params,
  routeMsg
) {
  try {
    var filler =
      regexpCompileCache[path] ||
      (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true })
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, ("missing param for " + routeMsg + ": " + (e.message)));
    }
    return ''
  }
}

/*  */

function normalizeLocation (
  raw,
  current,
  append
) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, ("path " + (current.path)));
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = (current && current.path) || '/';
  var path = parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : (current && current.path) || '/';
  var query = resolveQuery(parsedPath.query, next.query);
  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  }
}

function assign (a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a
}

/*  */

function createMatcher (routes) {
  var ref = createRouteMap(routes);
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes (routes) {
    createRouteMap(routes, pathMap, nameMap);
  }

  function match (
    raw,
    currentRoute,
    redirectedFrom
  ) {
    var location = normalizeLocation(raw, currentRoute);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        warn(record, ("Route with name '" + name + "' does not exist"));
      }
      var paramNames = getRouteRegex(record.path).keys
        .filter(function (key) { return !key.optional; })
        .map(function (key) { return key.name; });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""));
        return _createRoute(record, location, redirectedFrom)
      }
    } else if (location.path) {
      location.params = {};
      for (var path in pathMap) {
        if (matchRoute(path, location.params, location.path)) {
          return _createRoute(pathMap[path], location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }

  function redirect (
    record,
    location
  ) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function'
        ? originalRedirect(createRoute(record, location))
        : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      process.env.NODE_ENV !== 'production' && warn(
        false, ("invalid redirect option: " + (JSON.stringify(redirect)))
      );
      return _createRoute(null, location)
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, ("redirect failed: named route \"" + name + "\" not found."));
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location)
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""));
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location)
    } else {
      warn(false, ("invalid redirect option: " + (JSON.stringify(redirect))));
      return _createRoute(null, location)
    }
  }

  function alias (
    record,
    location,
    matchAs
  ) {
    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""));
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location)
    }
    return _createRoute(null, location)
  }

  function _createRoute (
    record,
    location,
    redirectedFrom
  ) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom)
  }

  return {
    match: match,
    addRoutes: addRoutes
  }
}

function matchRoute (
  path,
  params,
  pathname
) {
  var ref = getRouteRegex(path);
  var regexp = ref.regexp;
  var keys = ref.keys;
  var m = pathname.match(regexp);

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) { params[key.name] = val; }
  }

  return true
}

function resolveRecordPath (path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true)
}

/*  */


var positionStore = Object.create(null);

function setupScroll () {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll (
  router,
  to,
  from,
  isPop
) {
  if (!router.app) {
    return
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return
    }
    var isObject = typeof shouldScroll === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        position = getElementPosition(el);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition () {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition () {
  var key = getStateKey();
  if (key) {
    return positionStore[key]
  }
}

function getElementPosition (el) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left,
    y: elRect.top - docRect.top
  }
}

function isValidPosition (obj) {
  return isNumber(obj.x) || isNumber(obj.y)
}

function normalizePosition (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  }
}

function isNumber (v) {
  return typeof v === 'number'
}

/*  */

var supportsPushState = inBrowser && (function () {
  var ua = window.navigator.userAgent;

  if (
    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
    ua.indexOf('Mobile Safari') !== -1 &&
    ua.indexOf('Chrome') === -1 &&
    ua.indexOf('Windows Phone') === -1
  ) {
    return false
  }

  return window.history && 'pushState' in window.history
})();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now
  ? window.performance
  : Date;

var _key = genKey();

function genKey () {
  return Time.now().toFixed(3)
}

function getStateKey () {
  return _key
}

function setStateKey (key) {
  _key = key;
}

function pushState (url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState (url) {
  pushState(url, true);
}

/*  */

function runQueue (queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */


var History = function History (router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
};

History.prototype.listen = function listen (cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady (cb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
  }
};

History.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {
    var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, onAbort);
};

History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
    var this$1 = this;

  var current = this.current;
  var abort = function () { onAbort && onAbort(); };
  if (
    isSameRoute(route, current) &&
    // in the case the route map has been dynamically appended to
    route.matched.length === current.matched.length
  ) {
    this.ensureURL();
    return abort()
  }

  var ref = resolveQueue(this.current.matched, route.matched);
    var updated = ref.updated;
    var deactivated = ref.deactivated;
    var activated = ref.activated;

  var queue = [].concat(
    // in-component leave guards
    extractLeaveGuards(deactivated),
    // global before hooks
    this.router.beforeHooks,
    // in-component update hooks
    extractUpdateHooks(updated),
    // in-config enter guards
    activated.map(function (m) { return m.beforeEnter; }),
    // async components
    resolveAsyncComponents(activated)
  );

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort()
    }
    hook(route, current, function (to) {
      if (to === false) {
        // next(false) -> abort navigation, ensure current URL
        this$1.ensureURL(true);
        abort();
      } else if (typeof to === 'string' || typeof to === 'object') {
        // next('/') or next({ path: '/' }) -> redirect
        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to);
        abort();
      } else {
        // confirm transition and pass on the value
        next(to);
      }
    });
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () { return this$1.current === route; };
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    // wait until async components are resolved before
    // extracting in-component enter guards
    runQueue(enterGuards, iterator, function () {
      if (this$1.pending !== route) {
        return abort()
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) { return cb(); });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute (route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase (base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = (baseEl && baseEl.getAttribute('href')) || '/';
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '')
}

function resolveQueue (
  current,
  next
) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}

function extractGuards (
  records,
  name,
  bind,
  reverse
) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard)
        ? guard.map(function (guard) { return bind(guard, instance, match, key); })
        : bind(guard, instance, match, key)
    }
  });
  return flatten(reverse ? guards.reverse() : guards)
}

function extractGuard (
  def,
  key
) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key]
}

function extractLeaveGuards (deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}

function extractUpdateHooks (updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
}

function bindGuard (guard, instance) {
  return function boundRouteGuard () {
    return guard.apply(instance, arguments)
  }
}

function extractEnterGuards (
  activated,
  cbs,
  isValid
) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid)
  })
}

function bindEnterGuard (
  guard,
  match,
  key,
  cbs,
  isValid
) {
  return function routeEnterGuard (to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    })
  }
}

function poll (
  cb, // somehow flow cannot infer this is a function
  instances,
  key,
  isValid
) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

function resolveAsyncComponents (matched) {
  return flatMapComponents(matched, function (def, _, match, key) {
    // if it's a function and doesn't have Vue options attached,
    // assume it's an async component resolve function.
    // we are not using Vue's default async resolving mechanism because
    // we want to halt the navigation until the incoming component has been
    // resolved.
    if (typeof def === 'function' && !def.options) {
      return function (to, from, next) {
        var resolve = once(function (resolvedDef) {
          match.components[key] = resolvedDef;
          next();
        });

        var reject = once(function (reason) {
          warn(false, ("Failed to resolve async component " + key + ": " + reason));
          next(false);
        });

        var res = def(resolve, reject);
        if (res && typeof res.then === 'function') {
          res.then(resolve, reject);
        }
      }
    }
  })
}

function flatMapComponents (
  matched,
  fn
) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) { return fn(
      m.components[key],
      m.instances[key],
      m, key
    ); })
  }))
}

function flatten (arr) {
  return Array.prototype.concat.apply([], arr)
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once (fn) {
  var called = false;
  return function () {
    if (called) { return }
    called = true;
    return fn.apply(this, arguments)
  }
}

/*  */


var HTML5History = (function (History$$1) {
  function HTML5History (router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, this$1.current, true);
        }
      });
    });
  }

  if ( History$$1 ) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go (n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, this$1.current, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL (push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
    return getLocation(this.base)
  };

  return HTML5History;
}(History));

function getLocation (base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash
}

/*  */


var HashHistory = (function (History$$1) {
  function HashHistory (router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return
    }
    ensureSlash();
  }

  if ( History$$1 ) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners () {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push (location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go (n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL (push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    return getHash()
  };

  return HashHistory;
}(History));

function checkFallback (base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(
      cleanPath(base + '/#' + location)
    );
    return true
  }
}

function ensureSlash () {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true
  }
  replaceHash('/' + path);
  return false
}

function getHash () {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1)
}

function pushHash (path) {
  window.location.hash = path;
}

function replaceHash (path) {
  var i = window.location.href.indexOf('#');
  window.location.replace(
    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path
  );
}

/*  */


var AbstractHistory = (function (History$$1) {
  function AbstractHistory (router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go (n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/'
  };

  AbstractHistory.prototype.ensureURL = function ensureURL () {
    // noop
  };

  return AbstractHistory;
}(History));

/*  */

var VueRouter = function VueRouter (options) {
  if ( options === void 0 ) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || []);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, ("invalid mode: " + mode));
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match (
  raw,
  current,
  redirectedFrom
) {
  return this.matcher.match(raw, current, redirectedFrom)
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current
};

VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(
    install.installed,
    "not installed. Make sure to call `Vue.use(VueRouter)` " +
    "before creating root instance."
  );

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(
      history.getCurrentLocation(),
      setupHashListener,
      setupHashListener
    );
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach (fn) {
  this.beforeHooks.push(fn);
};

VueRouter.prototype.afterEach = function afterEach (fn) {
  this.afterHooks.push(fn);
};

VueRouter.prototype.onReady = function onReady (cb) {
  this.history.onReady(cb);
};

VueRouter.prototype.push = function push (location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go (n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back () {
  this.go(-1);
};

VueRouter.prototype.forward = function forward () {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
  var route = to
    ? this.resolve(to).route
    : this.currentRoute;
  if (!route) {
    return []
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key]
    })
  }))
};

VueRouter.prototype.resolve = function resolve (
  to,
  current,
  append
) {
  var location = normalizeLocation(to, current || this.history.current, append);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  }
};

VueRouter.prototype.addRoutes = function addRoutes (routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties( VueRouter.prototype, prototypeAccessors );

function createHref (base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path
}

VueRouter.install = install;
VueRouter.version = '2.2.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["default"] = (VueRouter);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(34)))

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/*!
 * Vue.js v2.2.5
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

/**
 * Convert a value to a string that is actually rendered.
 */
function _toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return typeof value === 'string' || typeof value === 'number'
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str
    .replace(hyphenateRE, '$1-$2')
    .replace(hyphenateRE, '$1-$2')
    .toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject (obj) {
  return toString.call(obj) === OBJECT_STRING
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 */
function noop () {}

/**
 * Always return false.
 */
var no = function () { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */


/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b)
    } catch (e) {
      // possible circular reference
      return a === b
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn();
    }
  }
}

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * List of asset types that a component can own.
   */
  _assetTypes: [
    'component',
    'directive',
    'filter'
  ],

  /**
   * List of lifecycle hooks.
   */
  _lifecycleHooks: [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated'
  ],

  /**
   * Max circular updates allowed in a scheduler flush cycle.
   */
  _maxUpdateCount: 100
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = (function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) { console.error(err); };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) { setTimeout(noop); }
    };
  } else if (typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) { cb.call(ctx); }
      if (_resolve) { _resolve(ctx); }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      })
    }
  }
})();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

var warn = noop;
var tip = noop;
var formatComponentName;

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.error("[Vue warn]: " + msg + " " + (
        vm ? formatLocation(formatComponentName(vm)) : ''
      ));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + " " + (
        vm ? formatLocation(formatComponentName(vm)) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var name = typeof vm === 'string'
      ? vm
      : typeof vm === 'function' && vm.options
        ? vm.options.name
        : vm._isVue
          ? vm.$options.name || vm.$options._componentTag
          : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var formatLocation = function (str) {
    if (str === "<Anonymous>") {
      str += " - use the \"name\" option for better debugging messages.";
    }
    return ("\n(found in " + str + ")")
  };
}

/*  */


var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var arguments$1 = arguments;

    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) {
      args[i] = arguments$1[i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
        inserted = args;
        break
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true,
  isSettingProps: false
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value)) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val
  }
  var ob = (target ).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.splice(key, 1);
    return
  }
  var ob = (target ).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        childVal.call(this),
        parentVal.call(this)
      )
    }
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

config._lifecycleHooks.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal
    ? extend(res, childVal)
    : res
}

config._assetTypes.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent
      ? parent.concat(child)
      : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.computed = function (parentVal, childVal) {
  if (!childVal) { return Object.create(parentVal || null) }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret
};

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + key
      );
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }
  normalizeProps(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = typeof extendsFrom === 'function'
      ? mergeOptions(parent, extendsFrom.options, vm)
      : mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      var mixin = child.mixins[i];
      if (mixin.prototype instanceof Vue$2) {
        mixin = mixin.options;
      }
      parent = mergeOptions(parent, mixin, vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      'Invalid prop: type check failed for prop "' + name + '".' +
      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

/**
 * Assert the type of a value
 */
function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (expectedType === 'String') {
    valid = typeof value === (expectedType = 'string');
  } else if (expectedType === 'Number') {
    valid = typeof value === (expectedType = 'number');
  } else if (expectedType === 'Boolean') {
    valid = typeof value === (expectedType = 'boolean');
  } else if (expectedType === 'Function') {
    valid = typeof value === (expectedType = 'function');
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match && match[1]
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

function handleError (err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (process.env.NODE_ENV !== 'production') {
      warn(("Error in " + info + ":"), vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      "referenced during render. Make sure to declare reactive data " +
      "properties in the data option.",
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' &&
    Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function () {
  var node = new VNode();
  node.text = '';
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isCloned = true;
  return cloned
}

function cloneVNodes (vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res
}

/*  */

var normalizeEvent = cached(function (name) {
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      for (var i = 0; i < fns.length; i++) {
        fns[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (!cur) {
      process.env.NODE_ENV !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (!old) {
      if (!cur.fns) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (!on[name]) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (!oldHook) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (oldHook.fns && oldHook.merged) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (c == null || typeof c === 'boolean') { continue }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
    } else if (isPrimitive(c)) {
      if (last && last.text) {
        last.text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (c.text && last && last.text) {
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (c.tag && c.key == null && nestedIndex != null) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function getFirstComponentChild (children) {
  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
}

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        cbs[i].apply(vm, args);
      }
    }
    return vm
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  var defaultSlot = [];
  var name, child;
  for (var i = 0, l = children.length; i < l; i++) {
    child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) &&
        child.data && (name = child.data.slot)) {
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots
}

function isWhitespace (node) {
  return node.isComment || node.text === ' '
}

function resolveScopedSlots (
  fns
) {
  var res = {};
  for (var i = 0; i < fns.length; i++) {
    res[fns[i][0]] = fns[i][1];
  }
  return res
}

/*  */

var activeInstance = null;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure((name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure((name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = true;
    }
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    if (process.env.NODE_ENV !== 'production') {
      observerState.isSettingProps = false;
    }
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }
  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive == null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var queue = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  queue.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id, vm;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > config._maxUpdateCount) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // reset scheduler before updated hook called
  var oldQueue = queue.slice();
  resetSchedulerState();

  // call updated hooks
  index = oldQueue.length;
  while (index--) {
    watcher = oldQueue[index];
    vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i >= 0 && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options
) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production'
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  if (this.user) {
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    }
  } else {
    value = this.getter.call(vm, vm);
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }
  popTarget();
  this.cleanupDeps();
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse (val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch) { initWatch(vm, opts.watch); }
}

var isReservedProp = { key: 1, ref: 1, slot: 1 };

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      if (isReservedProp[key]) {
        warn(
          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !observerState.isSettingProps) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var i = keys.length;
  while (i--) {
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn(
        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(keys[i])) {
      proxy(vm, "_data", keys[i]);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    }
  }
}

function defineComputed (target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn(
          "method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
    }
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (vm, key, handler) {
  var options;
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  vm.$watch(key, handler, options);
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    if (!vnode.componentInstance._isMounted) {
      vnode.componentInstance._isMounted = true;
      callHook(vnode.componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      activateChildComponent(vnode.componentInstance, true /* direct */);
    }
  },

  destroy: function destroy (vnode) {
    if (!vnode.componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        vnode.componentInstance.$destroy();
      } else {
        deactivateChildComponent(vnode.componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (!Ctor) {
    return
  }

  var baseCtor = context.$options._base;
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  if (!Ctor.cid) {
    if (Ctor.resolved) {
      Ctor = Ctor.resolved;
    } else {
      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
        // it's ok to queue this on every render because
        // $forceUpdate is buffered by the scheduler.
        context.$forceUpdate();
      });
      if (!Ctor) {
        // return nothing if this is indeed an async component
        // wait for the callback to trigger parent update.
        return
      }
    }
  }

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  data = data || {};

  // transform component v-model data into props & events
  if (data.model) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractProps(data, Ctor, tag);

  // functional component
  if (Ctor.options.functional) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  data.on = data.nativeOn;

  if (Ctor.options.abstract) {
    // abstract components do not keep anything
    // other than props & listeners
    data = {};
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
  );
  return vnode
}

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  context,
  children
) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (propOptions) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData);
    }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
  var vnode = Ctor.options.render.call(null, h, {
    props: props,
    data: data,
    parent: context,
    children: children,
    slots: function () { return resolveSlots(children, context); }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (inlineTemplate) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options)
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  cb
) {
  if (factory.requested) {
    // pool callbacks
    factory.pendingCallbacks.push(cb);
  } else {
    factory.requested = true;
    var cbs = factory.pendingCallbacks = [cb];
    var sync = true;

    var resolve = function (res) {
      if (isObject(res)) {
        res = baseCtor.extend(res);
      }
      // cache resolved
      factory.resolved = res;
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        for (var i = 0, l = cbs.length; i < l; i++) {
          cbs[i](res);
        }
      }
    };

    var reject = function (reason) {
      process.env.NODE_ENV !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
    };

    var res = factory(resolve, reject);

    // handle promise
    if (res && typeof res.then === 'function' && !factory.resolved) {
      res.then(resolve, reject);
    }

    sync = false;
    // return in case resolved synchronously
    return factory.resolved
  }
}

function extractProps (data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (!propOptions) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  var domProps = data.domProps;
  if (attrs || props || domProps) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && attrs.hasOwnProperty(keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the delared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey) ||
      checkProp(res, domProps, key, altKey);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (hash) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (on[event]) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (data && data.__ob__) {
    process.env.NODE_ENV !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
      typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (vnode) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return
  }
  if (vnode.children) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (child.tag && !child.ns) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      extend(props, bindObject);
    }
    return scopedSlotFn(props) || fallback
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && process.env.NODE_ENV !== 'production') {
      slotNodes._rendered && warn(
        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
        "- this will likely cause render errors.",
        this
      );
      slotNodes._rendered = true;
    }
    return slotNodes || fallback
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1
  } else {
    return keyCodes !== eventKeyCode
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp
) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      for (var key in value) {
        if (key === 'class' || key === 'style') {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];
        }
      }
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] =
    this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function initRender (vm) {
  vm.$vnode = null; // the placeholder node in parent tree
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$options._parentVnode;
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
}

function renderMixin (Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        vnode = vm.$options.renderError
          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
          : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = _toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var inject = vm.$options.inject;
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    // isArray here
    var isArray = Array.isArray(inject);
    var keys = isArray
      ? inject
      : hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);

    var loop = function ( i ) {
      var key = keys[i];
      var provideKey = isArray ? key : inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            defineReactive$$1(vm, key, source._provided[provideKey], function () {
              warn(
                "Avoid mutating an injected value directly since the changes will be " +
                "overwritten whenever the provided component re-renders. " +
                "injection being mutated: \"" + key + "\"",
                vm
              );
            });
          } else {
            defineReactive$$1(vm, key, source._provided[provideKey]);
          }
          break
        }
        source = source.$parent;
      }
    };

    for (var i = 0; i < keys.length; i++) loop( i );
  }
}

/*  */

var uid = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-init:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(((vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    for (var i = 0; i < latest.length; i++) {
      if (sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$2 (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue$2)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$2);
stateMixin(Vue$2);
eventsMixin(Vue$2);
lifecycleMixin(Vue$2);
renderMixin(Vue$2);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    /* istanbul ignore if */
    if (plugin.installed) {
      return
    }
    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    plugin.installed = true;
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn(
          'Invalid component name: "' + name + '". Component names ' +
          'can only contain alphanumeric characters and the hyphen, ' +
          'and must start with a letter.'
        );
      }
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    config._assetTypes.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  config._assetTypes.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && config.isReservedTag(id)) {
            warn(
              'Do not use built-in or reserved HTML elements as component ' +
              'id: ' + id
            );
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp];

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (pattern instanceof RegExp) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (cache, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cachedNode);
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry (vnode) {
  if (vnode) {
    if (!vnode.componentInstance._inactive) {
      callHook(vnode.componentInstance, 'deactivated');
    }
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created () {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this.cache, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this.cache, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (
        (this.include && !matches(this.include, name)) ||
        (this.exclude && matches(this.exclude, name))
      )) {
        return vnode
      }
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  config._assetTypes.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$2);

Object.defineProperty(Vue$2.prototype, '$isServer', {
  get: isServerRendering
});

Vue$2.version = '2.2.5';

/*  */

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (childNode.componentInstance) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return genClassFromData(data)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: child.class
      ? [child.class, parent.class]
      : parent.class
  }
}

function genClassFromData (data) {
  var dynamicClass = data.class;
  var staticClass = data.staticClass;
  if (staticClass || dynamicClass) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  var res = '';
  if (!value) {
    return res
  }
  if (typeof value === 'string') {
    return value
  }
  if (Array.isArray(value)) {
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (value[i]) {
        if ((stringified = stringifyClass(value[i]))) {
          res += stringified + ' ';
        }
      }
    }
    return res.slice(0, -1)
  }
  if (isObject(value)) {
    for (var key in value) {
      if (value[key]) { res += key + ' '; }
    }
    return res.slice(0, -1)
  }
  /* istanbul ignore next */
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);



var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setAttribute (node, key, val) {
  node.setAttribute(key, val);
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
        refs[key].push(ref);
      } else {
        refs[key] = [ref];
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function sameVnode (a, b) {
  return (
    a.key === b.key &&
    a.tag === b.tag &&
    a.isComment === b.isComment &&
    isDef(a.data) === isDef(b.data) &&
    sameInputType(a, b)
  )
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          inPre++;
        }
        if (
          !inPre &&
          !vnode.ns &&
          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
          config.isUnknownElement(tag)
        ) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        nodeOps.insertBefore(parent, elm, ref);
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
        i !== vnode.context &&
        isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
            warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            );
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }
    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
        isTrue(oldVnode.isStatic) &&
        vnode.key === oldVnode.key &&
        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.elm = oldVnode.elm;
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }
    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue) {
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode)) {
        return false
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (process.env.NODE_ENV !== 'production' &&
                typeof console !== 'undefined' &&
                !bailed) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode) {
    if (isDef(vnode.tag)) {
      return (
        vnode.tag.indexOf('vue-component') === 0 ||
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
            oldVnode.removeAttribute('server-rendered');
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  if (!oldVnode.data.attrs && !vnode.data.attrs) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (attrs.__ob__) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (attrs[key] == null) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (!data.staticClass && !data.class &&
      (!oldData || (!oldData.staticClass && !oldData.class))) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (transitionClass) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;



function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + "," + args)
  }
}

/*  */

/*  */

/**
 * Cross-platform code generation for component v-model
 */


/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var str;
var index$1;

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  var event;
  /* istanbul ignore if */
  if (on[RANGE_TOKEN]) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (on[CHECKBOX_RADIO_TOKEN]) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1 (
  event,
  handler,
  once,
  capture
) {
  if (once) {
    var oldHandler = handler;
    var _target = target$1; // save current target element in closure
    handler = function (ev) {
      var res = arguments.length === 1
        ? oldHandler(ev)
        : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(event, handler, capture);
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners (oldVnode, vnode) {
  if (!oldVnode.data.on && !vnode.data.on) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (!oldVnode.data.domProps && !vnode.data.domProps) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (props.__ob__) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (props[key] == null) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = cur == null ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (
  elm,
  vnode,
  checkVal
) {
  return (!elm.composing && (
    vnode.tag === 'option' ||
    isDirty(elm, checkVal) ||
    isInputChanged(elm, checkVal)
  ))
}

function isDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
  return document.activeElement !== elm && elm.value !== checkVal
}

function isInputChanged (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if ((modifiers && modifiers.number) || elm.type === 'number') {
    return toNumber(value) !== toNumber(newVal)
  }
  if (modifiers && modifiers.trim) {
    return value.trim() !== newVal.trim()
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    el.style[normalize(name)] = val;
  }
};

var prefixes = ['Webkit', 'Moz', 'ms'];

var testEl;
var normalize = cached(function (prop) {
  testEl = testEl || document.createElement('div');
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in testEl.style)) {
    return prop
  }
  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + upper;
    if (prefixed in testEl.style) {
      return prefixed
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (!data.staticStyle && !data.style &&
      !oldData.staticStyle && !oldData.style) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldVnode.data.staticStyle;
  var oldStyleBinding = oldVnode.data.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  vnode.data.style = style.__ob__ ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (newStyle[name] == null) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    el.setAttribute('class', cur.trim());
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame
  ? window.requestAnimationFrame.bind(window)
  : setTimeout;

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
  addClass(el, cls);
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (el._leaveCb) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return
  }

  /* istanbul ignore if */
  if (el._enterCb || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
          pendingNode.tag === vnode.tag &&
          pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (el._enterCb) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (!data) {
    return rm()
  }

  /* istanbul ignore if */
  if (el._leaveCb || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (!fn) { return false }
  var invokerFns = fn.fns;
  if (invokerFns) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (!vnode.data.show) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (!vnode.data.show) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted (el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function () {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var needReset = el.multiple
        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
      if (needReset) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  for (var i = 0, l = options.length; i < l; i++) {
    if (looseEqual(getValue(options[i]), value)) {
      return false
    }
  }
  return true
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition && !isIE9) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) { return }
    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    if (transition && !isIE9) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  return /\d-keep-alive$/.test(rawChild.tag)
    ? h('keep-alive')
    : null
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag; });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' &&
        mode && mode !== 'in-out' && mode !== 'out-in') {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      if (this._hasMove != null) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$2.config.mustUseProp = mustUseProp;
Vue$2.config.isReservedTag = isReservedTag;
Vue$2.config.getTagNamespace = getTagNamespace;
Vue$2.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$2.options.directives, platformDirectives);
extend(Vue$2.options.components, platformComponents);

// install platform patch function
Vue$2.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$2.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$2);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log'](
        'Download the Vue Devtools extension for a better development experience:\n' +
        'https://github.com/vuejs/vue-devtools'
      );
    }
  }
  if (process.env.NODE_ENV !== 'production' &&
      config.productionTip !== false &&
      inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log'](
      "You are running Vue in development mode.\n" +
      "Make sure to turn on production mode when deploying for production.\n" +
      "See more tips at https://vuejs.org/guide/deployment.html"
    );
  }
}, 0);

/* harmony default export */ __webpack_exports__["default"] = (Vue$2);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(34), __webpack_require__(71)))

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Store", function() { return Store; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapState", function() { return mapState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapMutations", function() { return mapMutations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapGetters", function() { return mapGetters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapActions", function() { return mapActions; });
/**
 * vuex v2.2.1
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;
    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook =
  typeof window !== 'undefined' &&
  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */


/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
};

var prototypeAccessors$1 = { state: {},namespaced: {} };

prototypeAccessors$1.state.get = function () {
  return this._rawModule.state || {}
};

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors$1 );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  var this$1 = this;

  // register root module (Vuex.Store options)
  this.root = new Module(rawRootModule, false);

  // register all nested modules
  if (rawRootModule.modules) {
    forEachValue(rawRootModule.modules, function (rawModule, key) {
      this$1.register([key], rawModule, false);
    });
  }
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update(this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  var parent = this.get(path.slice(0, -1));
  var newModule = new Module(rawModule, runtime);
  parent.addChild(path[path.length - 1], newModule);

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) { return }

  parent.removeChild(key);
};

function update (targetModule, newModule) {
  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        console.warn(
          "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
          'manual reload is needed'
        );
        return
      }
      update(targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
  assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");

  var state = options.state; if ( state === void 0 ) state = {};
  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); });
};

var prototypeAccessors = { state: {} };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors.state.set = function (v) {
  assert(false, "Use store.replaceState() to explicit replace store state.");
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    console.error(("[vuex] unknown mutation type: " + type));
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });

  if (options && options.silent) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var entry = this._actions[type];
  if (!entry) {
    console.error(("[vuex] unknown action type: " + type));
    return
  }
  return entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload)
};

Store.prototype.subscribe = function subscribe (fn) {
  var subs = this._subscribers;
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  assert(typeof getter === 'function', "store.watch only accepts a function.");
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule) {
  if (typeof path === 'string') { path = [path]; }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path));
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors );

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () { return fn(store); };
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (namespace) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var namespacedType = namespace + key;
    registerAction(store, namespacedType, action, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) { return }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function () { return store.getters[type]; },
      enumerable: true
    });
  });

  return gettersProxy
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler(local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload, cb) {
    var res = handler({
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    console.error(("[vuex] duplicate getter key: " + type));
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.length
    ? path.reduce(function (state, key) { return state[key]; }, state)
    : state
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  assert(typeof type === 'string', ("Expects string as the type, but found " + (typeof type) + "."));

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue) {
    console.error(
      '[vuex] already installed. Vue.use(Vuex) should be called only once.'
    );
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

// auto install in dist mode
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {
        return
      }
      return this.$store.commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (!(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {
        return
      }
      return this.$store.dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

function normalizeMap (map) {
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (!module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

var index_esm = {
  Store: Store,
  install: install,
  version: '2.2.1',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions
};

/* harmony default export */ __webpack_exports__["default"] = (index_esm);


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(73);


/***/ }),
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(8)(
  /* script */
  __webpack_require__(190),
  /* template */
  __webpack_require__(189),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 189 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "dovemxui-exif-info"
  }, [_c('ui-tabs', {
    attrs: {
      "type": "text"
    }
  }, _vm._l((_vm.exif.categories), function(category, categoryIndex) {
    return _c('ui-tab', {
      attrs: {
        "title": category.title
      }
    }, [_c('ul', _vm._l((category.items), function(keyItem, keyItemIndex) {
      return _c('li', [_vm._v("\n                  " + _vm._s(keyItem.title) + " : " + _vm._s(keyItem.value) + "\n              ")])
    }))])
  }))], 1)
},staticRenderFns: []}

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keenUi = __webpack_require__(9);

exports.default = {
  name: 'dovemxui-exif-info',
  props: {
    exif: {
      type: Object,
      default: {
        categories: [{
          title: '',
          items: {
            key$filePath: {
              title: '',
              type: String,
              value: 'Demo'
            }
          }
        }, {
          title: '',
          items: {}
        }]
      }
    }
  },
  data: function data() {
    return {};
  },

  computed: {
    classes: function classes() {
      return [];
    }
  },
  components: {
    UiIcon: _keenUi.UiIcon,
    UiTabs: _keenUi.UiTabs,
    UiTab: _keenUi.UiTab,
    UiButton: _keenUi.UiButton,
    UiIconButton: _keenUi.UiIconButton,
    UiAlert: _keenUi.UiAlert,
    UiToolbar: _keenUi.UiToolbar,
    UiSelect: _keenUi.UiSelect,
    UiConfirm: _keenUi.UiConfirm,
    UiProgressLinear: _keenUi.UiProgressLinear
  }
};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UIExifInfo = undefined;

var _uiExifInfo = __webpack_require__(188);

var _uiExifInfo2 = _interopRequireDefault(_uiExifInfo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DoveMXComponents = {
  UIExifInfo: _uiExifInfo2.default,

  install: function install(Vue) {
    Vue.component('dovemxui-exif-info', _uiExifInfo2.default);
  }
};

exports.default = DoveMXComponents;
exports.UIExifInfo = _uiExifInfo2.default;

/***/ })
/******/ ]);
//# sourceMappingURL=bundle.js.map